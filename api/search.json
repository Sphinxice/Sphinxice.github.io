[{"id":"8f70db8533248a1b0253678490da59d6","title":"linux命令","content":"linux命令3\ntouch命令 \n$ touch testfile                #修改文件时间属性为当前系统时间  \n$ ls -l testfile                #查看文件的时间属性  \n\n使用指令 “touch” 时，如果指定的文件不存在，则将创建一个新的空白文件\necho “hello” &gt;c.txt 创建c.txt文件并写入“hello”\nmore 命令 查看文件内容，支持翻页查看，而cat命令适合查看内容少的文件\ntail命令  ：默认显示最后十行\ntail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。\n\n-f 循环读取\n-q 不显示处理信息\n-v 显示详细的处理信息\n-c &lt;数目&gt; 显示的字节数\n-n &lt;行数&gt; 显示文件的尾部 n 行内容\n–pid=PID 与 - f 合用，表示在进程 ID,PID 死掉之后结束\n-q, –quiet, –silent 从不输出给出文件名的首部\n-s, –sleep-interval=S 与 - f 合用，表示在每次反复的间隔休眠 S 秒\n\n显示文件 notes.log 的内容，从第 20 行至文件末尾:\ntail -n +20 notes.log\n\n显示文件 notes.log 的最后 10 个字符:\ntail -c 10 notes.log\n\n要跟踪名为 notes.log 的文件的增长情况，也就是实时查看：\ntail -f notes.log\n\nls命令   列出文件夹下默认的文件夹和文件。\nLinux 中 ls 命令可以用来查看系统上的文件、目录和设备的权限：\n# ls -l\ntotal 20\n-rw-rw-r-- 1 ivan1001 ivan1001    0 Apr 29 07:52 file1\n-rw-rw-r-- 1 ivan1001 ivan1001    0 Apr 29 07:52 file2\n-rw-rw-r-- 1 ivan1001 ivan1001    0 Apr 29 07:52 file3\n-rwxrwxr-x 1 ivan1001 ivan1001 7348 Apr 29 07:53 myproc\n-rw-rw-r-- 1 ivan1001 ivan1001  126 Apr 29 07:53 myproc.c\ndrwxrwxr-x 2 ivan1001 ivan1001 4096 Apr 29 07:54 test1\ndrwxrwxr-x 2 ivan1001 ivan1001 4096 Apr 29 07:54 test2\n\n输出结果的第一个字段是描述文件和目录权限的码。这个字段的第一个字符代表了对象的类型：\n\n\n代表文件\n\n\nd 代表目录\nl 代表链接\nc 代表字符型设备\nb 代表块设备\nn 代表网络设备\n\n如果没有某种权限，在该权限位出现单破折线。则 3 组三字码分别对应对象的 3 个安全级别：\n\n对象的属主\n对象的属组\n系统其它用户\n\n下面以 myproc 文件为例：\n# ls -l myproc\n-rwxrwxr-x 1 ivan1001 ivan1001 7348 Apr 29 07:53 myproc\n\n文件 myproc 有下面 3 组权限：\n\nrgw: 文件的属主（设为登录名 ivan1001)\nrgw: 文件的属组（设为组名 ivan1001)\nr-x: 系统上其它人\n\n这些权限说明登录名为 ivan1001 的用户可以读取、写入以及执行这个文件（可以看做有全部权限）。类似地，属组 ivan1001 的成员也可以读取、写入和执行这个文件。然而不属于 ivan1001 组的其他用户只能读取和执行这个文件： w 被单破折线取代了，说明这个安全级别没有写入权限。\nll命令 列出各个文件详细信息\nlinux常用命令2ssh ip  连接远程服务器pwd 查看当前目录位置ipconfig 查看网络设备状态free －h 查看内存df -lh 查看磁盘空间情况ls 查看当前目录文件du -sh * 查看各个文件所占空间cat 查看某个文件内容uname -a 查看系统版本安装软件 yum install 软件名which java 查看java存放位置wget url.tar 下载网路上的某个压缩包tar 命令 解压mv 改名 移动，nohup后台启动jobs查看当前任务ps 查看当前进程 top也可以chomd 设置权限 r4w2x1 \n查看文件 a.txt 的第 190 行到 196 行，sed -n ‘190,196p’ a.txtG 跳转到末行的起始位置是对的，一般我用 gg 跳转到行首。netstat # 查看网络状态．ipconfig 查看ip配置\nlinux常用命令1\ncd 命令，用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。\n\ncd /home 进入 ‘/home’ 目录\ncd .. 返回上一级目录\ncd ../.. 返回上两级目录\ncd 进入个人的主目录\ncd ~user1 进入个人的主目录\ncd - 返回上次所在的目录\n\npwd 命令，显示工作路径\n\n[root@mailvip ~]# pwd\n/root\n\nls 命令，查看文件与目录的命令，list 之意\n\nls 查看目录中的文件\nls -l 显示文件和目录的详细资料\nls -a 列出全部文件，包含隐藏文件\nls -R 连同子目录的内容一起列出 (递归列出)，等于该目录下的所有文件都会显示出来\nls [0-9] 显示包含数字的文件名和目录名\n\ncp 命令，用于复制文件，copy 之意，它还可以把多个文件一次性地复制到一个目录下\n\n-a ：将文件的特性一起复制\n-p ：连同文件的属性一起复制，而非使用默认方式，与 - a 相似，常用于备份\n-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行\n-r ：递归持续复制，用于目录的复制行为 // 经常使用递归复制\n-u ：目标文件与源文件有差异时才会复制\n\\5. mv 命令，用于移动文件、目录或更名，move 之意\n-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\n-i ：若目标文件已经存在，就会询问是否覆盖\n-u ：若目标文件已经存在，且比目标文件新，才会更新\n\nrm 命令，用于删除文件或目录，remove 之意\n\n-f ：就是 force 的意思，忽略不存在的文件，不会出现警告消息\n-i ：互动模式，在删除前会询问用户是否操作\n-r ：递归删除，最常用于目录删除，它是一个非常危险的参数\n二、查看文件内容\n\ncat 命令，用于查看文本文件的内容，后接要查看的文件名，通常可用管道与 more 和 less 一起使用\n\ncat file1 从第一个字节开始正向查看文件的内容\ntac file1 从最后一行开始反向查看一个文件的内容\ncat -n file1 标示文件的行数\nmore file1 查看一个长文件的内容\nhead -n 2 file1 查看一个文件的前两行\ntail -n 2 file1 查看一个文件的最后两行\ntail -n +1000 file1 从 1000 行开始显示，显示 1000 行以后的\ncat filename | head -n 3000 | tail -n +1000 显示 1000 行到 3000 行\ncat filename | tail -n +3000 | head -n 1000\n从第 3000 行开始，显示 1000 (即显示 3000~3999 行)\n三。文件搜索\n\nfind 命令，用来查找系统的\n\nfind / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录\nfind / -user user1 搜索属于用户 ‘user1’ 的文件和目录\nfind /usr/bin -type f -atime +100 搜索在过去 100 天内未被使用过的执行文件\nfind /usr/bin -type f -mtime -10 搜索在 10 天内被创建或者修改过的文件\nwhereis halt 显示一个二进制文件、源码或 man 的位置\nwhich halt 显示一个二进制文件或可执行文件的完整路径\n删除大于 50M 的文件：\nfind /var/mail/ -size +50M -exec rm {} ;\n四。文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消\n\nchmod 命令，改变文件 / 文件夹权限\n\nls -lh 显示权限\nchmod ugo+rwx directory1 设置目录的所有人 (u)、群组 (g) 以及其他人 (o) 以读 (r，4\n)、写 (w，2) 和执行 (x，1) 的权限\nchmod go-rwx directory1 删除群组 (g) 与其他人 (o) 对目录的读写执行权限\n\nchown 命令，改变文件的所有者\n\nchown user1 file1 改变一个文件的所有人属性\nchown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性\nchown user1:group1 file1 改变一个文件的所有人和群组属性\n\nchgrp 命令，改变文件所属用户组\n\nchgrp group1 file1 改变文件的群组\n五。文本处理\n12.\ngrep 命令，分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等\ngrep Aug /var/log/messages 在文件 ‘/var/log/messages’ 中查找关键词 “Aug”\ngrep ^Aug /var/log/messages 在文件 ‘/var/log/messages’ 中查找以 “Aug” 开始的词汇\ngrep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行\ngrep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串 “Aug”\nsed’s/stringa1/stringa2/g’ example.txt 将 example.txt 文件中的 “string1” 替换成\n“string2”\nsed ‘/^$/d’ example.txt 从 example.txt 文件中删除所有空白行\n\npaste 命令\n\npaste file1 file2 合并两个文件或两栏的内容\npaste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用 “+” 区分\n\nsort 命令\n\nsort file1 file2 排序两个文件的内容\nsort file1 file2 | uniq 取出两个文件的并集 (重复的行只保留一份)\nsort file1 file2 | uniq -u 删除交集，留下其他的行\nsort file1 file2 | uniq -d 取出两个文件的交集 (只留下同时存在于两个文件中的文件)\n\ncomm 命令\n\ncomm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容\ncomm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容\ncomm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分\n六、打包和压缩文件\n\ntar 命令，对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序 (如 gzip 和 bzip 等) 进行压缩和解压\n\n-c ：新建打包文件\n-t ：查看打包文件的内容含有哪些文件名\n-x ：解打包或解压缩的功能，可以搭配 - C (大写) 指定解压的目录，注意 - c,-t,-x 不能同时出现在同一条命令中\n-j ：通过 bzip2 的支持进行压缩 / 解压缩\n-z ：通过 gzip 的支持进行压缩 / 解压缩\n-v ：在压缩 / 解压缩过程中，将正在处理的文件名显示出来\n-f filename ：filename 为要处理的文件\n-C dir ：指定压缩 / 解压缩的目录 dir\n压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称查询：tar -jtv -f filename.tar.bz2\n解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录\nbunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’ 的文件\nbzip2 file1 压缩一个叫做 ‘file1’ 的文件\ngunzip file1.gz 解压一个叫做 ‘file1.gz’ 的文件\ngzip file1 压缩一个叫做 ‘file1’ 的文件\ngzip -9 file1 最大程度压缩\nrar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包\nrar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’\nrar x file1.rar 解压 rar 包\nzip file1.zip file1 创建一个 zip 格式的压缩包\nunzip file1.zip 解压一个 zip 格式压缩包\nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个 zip 格式的压缩包\n七。系统和关机 (关机、重启和登出)\nshutdown -h now 关闭系统 (1)\ninit 0 关闭系统 (2)\ntelinit 0 关闭系统 (3)\nshutdown -h hours:minutes &amp; 按预定时间关闭系统\nshutdown -c 取消按预定时间关闭系统\nshutdown -r now 重启 (1)\nreboot 重启 (2)\nlogout 注销\ntime 测算一个命令 (即程序) 的执行时间\n八、进程相关的命令\n\njps 命令，显示当前系统的 java 进程情况，及其 id 号\n\njps (Java Virtual Machine Process Status Tool) 是 JDK\n1.5 提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前 java 进程的一些简单情况。\n\nps 命令，用于将某个时间点的进程运行情况选取下来并输出，process 之意\n\n-A ：所有的进程均显示出来\n-a ：不与 terminal 有关的所有进程\n-u ：有效用户的相关进程\n-x ：一般与 a 参数一起使用，可列出较完整的信息\n-l ：较长，较详细地将 PID 的信息列出\nps aux # 查看系统所有的进程数据\nps ax # 查看不与 terminal 有关的所有进程\nps -lA # 查看系统所有的进程数据\nps axjf # 查看连同一部分进程树状态\n\nkill 命令，用于向某个工作 (% jobnumber) 或者是某个 PID (数字) 传送一个信号，它通常与 ps 和 jobs 命令一起使用\n\n命令格式 : kill [命令参数][进程 id]\n命令参数:\n-l 信号，若果不加信号的编号参数，则使用 “-l” 参数会列出全部的信号名称\n-a 当处理当前进程时，不限制命令名和进程号的对应关系\n-p 指定 kill 命令只打印相关进程的进程号，而不发送任何信号\n-s 指定发送信号\n-u 指定用户\n实例 1：列出所有信号名称 命令：kill -l 输出：\n[root@localhost test6]# kill -l\n\\1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL\n\\5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE\n\\9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2\n\\13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT\n\\17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP\n\\21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU\n\\25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH\n\\29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN\n\\35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4\n\\39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8\n\\43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n\\47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n\\51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n\\55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6\n\\59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2\n\\63) SIGRTMAX-1 64) SIGRTMAX\n说明：\n只有第 9 种信号 (SIGKILL) 才可以无条件终止进程，其他信号进程都有权利忽略。 下面是常用的信号：\nHUP 1 终端断线\nINT 2 中断 (同 Ctrl + C)\nQUIT 3 退出 (同 Ctrl + )\nTERM 15 终止\nKILL 9 强制终止\nCONT 18 继续 (与 STOP 相反， fg/bg 命令)\nSTOP 19 暂停 (同 Ctrl + Z)\n实例 2：得到指定信号的数值\n[root@localhost test6]# kill -l KILL\n[root@localhost test6]# kill -l SIGKILL\n[root@localhost test6]# kill -l TERM\n[root@localhost test6]# kill -l SIGTERM\n[root@localhost test6]#\n实例 3：先用 ps 查找进程，然后用 kill 杀掉\n命令：kill 3268\n[root@localhost test6]# ps -ef|grep vim\nroot 3268 2884 0 16:21 pts/1 00:00:00 vim install.log\nroot 3370 2822 0 16:21 pts/0 00:00:00 grep vim\n[root@localhost test6]# kill 3268\n实例 4：彻底杀死进程\n命令：kill –9 3268 // -9 强制杀掉进程\n\nkillall 命令，向一个命令启动的进程发送一个信号，用于杀死指定名字的进程\n\n命令格式 : killall [命令参数][进程名]\n命令参数：\n-Z 只杀死拥有 scontext 的进程\n-e 要求匹配进程名称\n-I 忽略小写\n-g 杀死进程组而不是进程\n-i 交互模式，杀死进程前先询问用户\n-l 列出所有的已知信号名称\n-q 不输出警告信息\n-s 发送指定的信号\n-v 报告信号是否成功发送\n-w 等待进程死亡\n–help 显示帮助信息\n–version 显示版本显示\n示例\n\n杀死所有同名进程\n\nkillall nginx\nkillall -9 bash\n\n向进程发送指定信号\n\nkillall -TERM ngixn 或者 killall -KILL nginx\n\ntop 命令，是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于 Windows 的任务管理器。\n\n如何杀死进程：\n(1) 图形化界面的方式\n(2) kill -9 pid (-9 表示强制关闭)\n(3) killall -9 程序的名字\n(4) pkill 程序的名字\n查看进程端口号：\nnetstat -tunlp|grep 端口号\n","slug":"linux命令3","date":"2022-01-18T14:32:21.000Z","categories_index":"linux","tags_index":"linux","author_index":"icarus"},{"id":"be4fadc0757b3a2eeaefd20302787665","title":"集合","content":"强引用：创建一个对象并使用引用变量指向它，处于可达状态，不可能被垃圾回收机制回收\n软引用:在内存空间足够时不会被回收，不足时有可能被回收\n弱引用：垃圾回收机制运行时，不管内存是否足够，都会被回收\n虚引用:类似于完全没有引用，也就是没有任何变量指向它。\nStatement执行sql语句时不允许使用问号占位符，需要拼接sql字符串，而preparestatement允许，不需要拼接字符串，只需要使用问号占位符来 代替这些参数，并且还能防注入\n在Iterator或者foreach迭代Collection集合时，不能修改集合，否者会抛出ConcurrentModificationException异常，Iterator迭代器采用的是快速失败（fail-fast）机制，一旦迭代过程检测到该集合被修改，就会抛出异常。\n集合Set集合set集合，因为它放入元素是无序的，所以它不允许重复元素，而list集合是有序放入，所以允许。\nhashset用的比较多，按照hash算法来存储元素的值，放入一个元素时，会调用该元素的hashcode()方法来得到该对象的hashcode值，然后根据值决定存储位置，也就是说如果两个对象equal()返回true，而hashcode()返回值不相等，那也是可以添加成功的，这就和set集合的不能存放重复元素的特点冲突了。所以hashset 判断两个对象相等的标准：equal()相等，hashcode值也相等。\n也就是说，如果需要重写该对象的equal方法，也必须重写hashcode方法。\nhashset就相当于把元素全放在hashmap的key，而value全部设为null\nTreeSet 根据值的大小来排序，放入treeset的元素必须实现了compareble接口，常见的String、bigdecimal、boolean、date、time都实现了该接口。否则会抛出类转换异常，classcastException。\n举个例子，依次放入 0 -1 1 -2 ，调用first()，得到-1，调用last()，得到1\n对于Treeset，判断两个对象是否相等的唯一标准是：两对象通过compareTo(Object obj)方法返回是否为0，为0则相等。所以，需要注意如果equal返回true，compareTo要返回0。\nLinkedHashSet 按插入顺序存放元素。\n这些set都是线程不安全的，如果有多个线程同时访问一个set集合，并且有超过一个线程修改了该set集合\nlist集合如果想ArrayList或Vector集合添加大量元素时，可以使用ensureCapacity(int minCapacity)方法一次性地增加initialCapacity，减少重分配的次数来提高性能。\n因为Vector很古老，有很多名字很长的方法，不方便编程，所以较少使用，但它是线程安全的。\nMap集合Hashmap允许一个key为null，Hashtable不允许，前者线程不安全，后者安全，\n","slug":"引用 集合","date":"2022-01-18T14:32:21.000Z","categories_index":"面试","tags_index":"java","author_index":"icarus"},{"id":"d072989fb1060a7ab47385f712edd6a0","title":"能遇见你，甚是开心","content":"欢迎来到我的世界，这是我的个人博客。基于 Hexo 框架搭建，采用 hexo-theme-aurora 主题。 \n后期也会不定时增加新的功能，敬请期待！！！\n","slug":"引言","date":"2022-01-07T14:32:21.000Z","categories_index":"引言","tags_index":"入站须知","author_index":"icarus"},{"id":"4a4c62b488ae3faf3b7c187892faae11","title":"面试积累","content":"linux：\nDevOps的全名：\nDevelopment Operations 开发自运维\n\n首先来回顾一下整个开发流程：\n需求 - 开发 - 测试 - 发布 - 部署 - 监控运维\n项目管理（需求 &amp; BUG）：redmine\n代码托管：gerrit（gitlab）\n持续集成：jenkins\n测试：单元测试：maven 等，Jmeter，或者是自己编写脚本\n代码扫描：sonar\n制品库：JFrog，或者其他工具，这个我也没有想好 JFrog 收费版可以支持 docker，maven, npm 等等等，多得不行，制品这方面目前没有什么好的开源的软件。\n持续部署：K8S\n日志收集：ELK + KAFKA\n监控显示：zabbix，grafana\n其他工具：nginx, lvs，HA, redis，rabbitmq，ldap, ansible。\n实践想法\n认证：LDAP 发现好多的开源的工具都会选择 ldap 来做认证。OPENLDAP。\n项目管理：redmine，开源，有丰富的插件，至少感觉好像还是挺火的。\n代码托管：gerrit 或者是 gitlab 吧，我这边我会选择 gerrit\n持续集成：jenkins, 可惜 jenkins 竟然不开源，不过插件丰富。\n代码扫描：sonar\n额说得有点重了。LDAP 作为所有工具链的一个认证，这样用户信息就统一起来了。\n来个场景吧.\n\n\nBA 接收到需求之后将其录入 Redmine, 指定好开发人员。\n\n开发人员接收到任务之后，然后从 gerrit 拉取代码到本地，然后进行开发，开发完成后，将写好的代码弄成一个评审单上传到 gerrit, 并通知相关的评审人员进行评审。\n\n在你提交上去的那个刻，jenkins 收到你创建评审单事件，然后开发触发构建的你配置的任务，先拉取你最新提交的代码，然后进行编译构建，扫描你的代码是否符合。代码符合之后，然后进行测试（在构建的时候会先进行单元测试），然后把构建好的包，在测试环境上进行部署，然后拉取自动测试脚本进行测试，测试没有问题之后。jenkins 会对你本次的评审单进行打分。通过了就打 2 分，不过打 - 2 分。这样就避免了浪费大家的时间，在打分通过了的情况下，评审人员才会去评审。\n\n评审人员到 gerrit 上进行评审，如果评审不合格，直接拒绝，开发人员重新进行开发。在提交然后再重复 3 步骤。如果评审通过，进行代码合入，然后再次触发 jenkins 的构建任务，不过这个任务是构建 beta 测试版本，构建到测试版本之后，然后发布到制品库中，然后通知测试人员可以进行测试了。然后这个时候将 redmine 的任务状态更改会开发完成。这个时候会通知测试人员可以进行测试了。\n\n测试人员收到测试任务之后，从制品库中拉取 beta 包进行部署测试，这个部署测试环境，有了 docker 容器其实也是可以一键部署哦，然后再用自动化脚本进行测试，对于个别场景可以进行手工测试，如果有 bug, 测试人员在 redmine 进行录入，然后通知开发人员，这个时候流程又从 1 开始，直到这个 bug 测试通过了，然后 redmine 会更改 bug 状态。\n\n如果测试人员测试通过了，然后又可以出发一次构建任务。将最新的代码构建成 release 版本发到制品库中或者是进行自动部署。而且现在有灰度发布，可以一点一点切流程到新的版本上，看一下运行情况，如果不行直接回退。\n\n\n列举文件abc.log最后十行：\ntail -n 20 abc.log\n\nJenkins是什么？有什么作用\nJenkins 是开源软件项目，基于 Java 开发的持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\nJenkins 的功能\nJenkins 的主要功能是将项目中重复执行的工作自动化的执行。如软件的建造（构建）和在配置文件下设置的 job。具体功能大概有：\n\n软件的持续构建和测试，Jenkins 提供了一个系统，使开发人员可以很容易的将改变集成到工程中。自动化的，持续的构建有利于提高开发效率。\n\n监视 job 的执行，如下图所示，job 可以实现很多的功能，Jenkins 可以对这些项目进行显示，让用户更清楚的注意到这些损毁的 job。（具体情况后文中介绍）\n\n项目源代码修改的检测，jenkins 能够从项目的 Subversion/CVS 生成最近修改的集合列表，且不会增加 Subversion/CVS Repository 的负载。\n\n分布式构建，Jenkins 可以将工程构建到多台机器，更好地利用硬件资源，节省时间。\n\n\n其他，Jenkins 代码开源，用户可以自己编写插件。所以 jenkins 可以实现很多的功能。\n列举全部的java进程\nps -ef | grep java\n\n\n扩展：停止特定 java 进程命令：kill -9 java 进程序号     比如:kill -9 97993\n从 http://www.somewebsite.com/file.tar.gz下载一个文件\nweget  http://www.somewebsite.com/file.tar.gz\n数据库：\ndelete和truncate的区别\nDELETE 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。\nTRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。\ndrop 语句将表所占用的空间全释放掉。\nStatement和PrepareStatement的区别\nStatement 每次执行 sql 语句，数据库都要执行 sql 语句的编译，最好用于仅执行一次查询并返回结果的情形，效率高于 PreparedStatement. 但存在 sql 注入风险。PreparedStatement 是预编译执行的。在执行可变参数的一条 SQL 时，PreparedStatement 要比 Statement 的效率高，因为 DBMS 预编译一条 SQL 当然会比多次编译一条 SQL 的效率高。安全性更好，有效防止 SQL 注入的问题。对于多次重复执行的语句，使用 PreparedStatement 效率会更高一点。\n列举什么字段适合建索引\n1、表的主键、外键必须有索引；2、数据量超过 300 的表应该有索引；3、经常与其他表进行连接的表，在连接字段上应该建立索引；4、经常出现在 Where 子句中的字段，特别是大表的字段，应该建立索引；5、索引应该建在选择性高的字段上；6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替8、不包含有 NULL 值的列\nunion和union all 有什么不同\n在数据库中，union 和 union all 关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。\nunion 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果\n 而 union all 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。   从效率上说，union all 要比 union 快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用 union all\nCHAR和VARCHAR的区别是什么\nCHAR 和 VARCHAR 最大的不同就是一个是固定长度，一个是可变长度。 由于是可变长度，因此实际存储的时候是实际字符串再加上一个记录字符串长度的字节 (如果超过 255 则需要两个字节)。 如果分配给 CHAR 或 VARCHAR 列的值超过列的最大长度，则对值进行裁剪以使其适合。 如果被裁掉的字符不是空格，则会产生一条警告\n\n前端：请说出两种减少页面加载时间的方法：\n\n重复的 HTTP 请求数量应尽量减少\n压缩 Javascript、CSS 代码\n在文件头部放置 css 样式的定义\n在文件末尾放 Javascript 脚本\ncss、javascript 改由外部调用\n尽可能减少 DCOM 元素\n避免使用 CSS 脚本 (CSS Expressions)\n服务器启用 gzip 压缩功能\nAjax 采用缓存调用\nAjax 调用尽量采用 GET 方法调用\n养成良好的开发维护习惯，尽量避免脚本重复调用\n缩减 iframe 的使用，如无必要，尽量不要使用参考链接：https://blog.csdn.net/Rayshaan/article/details/112130992\n\nhtml中doctype(文档类型)的作用是什么？你知道多少种文档类型\ndoctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。\n1、HTML5 &lt;!DOCTYPE&gt; 声明\nHTML5 规定了一种 &lt;!DOCTYPE&gt; 声明，它能向前向后兼容，代码也更加简洁，刘代码推荐使用。\nMarkup\n&lt;!doctype html&gt;\n\n2、HTML 4.01 Strict\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\nMarkup\n&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;\n\n3、HTML 4.01 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\nMarkup\n&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;\n\n 什么是闭包，如何使用它，为什么要使用它？\n\n闭包是指有权访问另一个函数作用域中的变量的函数。\n创建闭包的常见方式，就是在一个函数内部创建另一个函数。\n闭包可以用在许多地方。它的最大用处有两个：\n可以读取函数内部的变量\n让这些变量的值始终保存在内存中\n\n\n\n由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n闭包的真正意义是： 闭包是由于局部变量无法共享和长久的保存，而全局变量可能造成变量污染，当我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 function f1 () { var a=10; return function (){ a++; console.log (a); }; }; var f = f1 (); f (); 当 f () 在不断调用时，a 的状态会被保存，不会在 f1 () 执行完后释放 总结下： 闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装私有变量，这是优点也是缺点，不必要的闭包只会徒增内存消耗！\n请描述一下cookies、sessionStorage和localStorage的区别\n共同点：都是保存在浏览器端，且同源的。\n区别：\n\ncookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。\n存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。\n数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。\n作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。\n\n什么是mvvm，前端mvvm里面的view model指什么？\nModel–View–ViewModel  是一个软件架构设计模式\nMVVM 分层示意图\n分层设计一直是软件架构的主流设计思想之一，MVVM 也不例外。\nView 层\nView 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2 等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。\nModel 层\nModel 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。后端的处理通常会非常复杂：\n前后端对比后端：我们这里的业务逻辑和数据处理会非常复杂！前端：关我屁事！\n后端业务处理再复杂跟我们前端也没有半毛钱关系，只要后端保证对外接口足够简单就行了，我请求 api，你把数据返出来，咱俩就这点关系，其他都扯淡。\nViewModel 层\nViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。看到了吧，View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。\nVue 的 View 模板：\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;\n    &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;Click me&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n \n\nVue 的 ViewModel 层（下面是伪代码）：\nvar app &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;     &#x2F;&#x2F; 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）\n        message: &#39;Hello Vue!&#39;,  &#x2F;&#x2F; 纯前端定义\n        server: &#123;&#125;, &#x2F;&#x2F; 存放基于 Model 层数据的二次封装数据\n    &#125;,\n    methods: &#123;  &#x2F;&#x2F; 用于描述视图行为（完全前端定义）\n        showMessage()&#123;\n            let vm &#x3D; this;\n            alert(vm.message);\n        &#125;\n    &#125;,\n    created()&#123;\n        let vm &#x3D; this;\n\n        &#x2F;&#x2F; Ajax 获取 Model 层的数据\n        ajax(&#123;\n            url: &#39;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&#39;,\n            success(res)&#123;\n                &#x2F;&#x2F; TODO 对获取到的 Model 数据进行转换处理，做二次封装\n                vm.server &#x3D; res;\n            &#125;\n        &#125;);\n    &#125;\n&#125;)\n \n\n服务端的 Model 层（省略业务逻辑处理，只描述对外接口）：\n&#123;\n    &quot;url&quot;: &quot;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&quot;,\n    &quot;res&quot;: &#123;\n        &quot;success&quot;: true,\n        &quot;name&quot;: &quot;IoveC&quot;,\n        &quot;domain&quot;: &quot;www.cnblogs.com&quot;\n    &#125;\n&#125;\n \n\n这就是完整的 MVVM 编程模式。\n代码执行之后双向绑定的效果如下:\nVue 实现的响应的数据绑定\n嘿嘿，前后端可以成功分手了，以后再也不用关心后端个锤子开发进度 \\ 暴怒脸，复杂实现，blabla…，尽情享用前端如丝般顺滑的开发快感吧：)\n后端：java中int和Integer有什么区别：\nInteger 是 int 的包装类；int 是基本数据类型； Integer 变量必须实例化后才能使用；int 变量不需要； Integer 实际是对象的引用，指向此 new 的 Integer 对象；int 是直接存储数据值； Integer 的默认值是 null；int 的默认值是 0。\njava构造器是否可被重写：\n不可以\njava如何实现对象克隆，说出一种方法：\n浅克隆 (ShallowClone) 和 深克隆 (DeepClone)\n在 Java 语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括 int、double、byte、boolean、char 等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。\n一般步骤是（浅克隆）：\n\n被复制的类需要实现 Clonenable 接口（不实现的话在调用 clone 方法会抛出 CloneNotSupportedException 异常)， 该接口为标记接口 (不含任何方法)\n\n覆盖 clone () 方法，访问修饰符设为 public。 方法中调用 super.clone () 方法得到需要的复制对象。（native 为本地方法)\n\n\n深克隆\npublic class Student implements Cloneable&#123;\n    private int number;\n\n    public void setNumber(int number) &#123;\n        this.number &#x3D; number;\n    &#125;\n\n    public int getNumber() &#123;\n\n        return number;\n    &#125;\n    @Override\n    public Object clone()&#123;\n        Student stu &#x3D; null;\n        try &#123;\n            stu &#x3D; (Student) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return stu;\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Student stu1 &#x3D; new Student();\n        stu1.setNumber(12345);\n        Student stu2 &#x3D; (Student) stu1.clone();\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber());\n\n        stu2.setNumber(54321);\n\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber());\n        System.out.println(stu1&#x3D;&#x3D;stu2);\n    &#125;\n&#125;\n输出：\n学生1:12345\n学生2:12345\n学生1:12345\n学生2:54321\nfalse\n\n浅复制（浅克隆）被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。\n换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。\nclass Address  &#123;\n    private String add;\n&#x2F;&#x2F;省略getset方法\n&#125;\nclass Student implements Cloneable&#123;\n    private int number;\n\tprivate Address addr;\n\npublic Address getAddr() &#123;\n    return addr;\n&#125;\n\npublic void setAddr(Address addr) &#123;\n    this.addr &#x3D; addr;\n&#125;\n\npublic int getNumber() &#123;\n    return number;\n&#125;\n\npublic void setNumber(int number) &#123;\n    this.number &#x3D; number;\n&#125;\n\n@Override\npublic Object clone() &#123;\n    Student stu &#x3D; null;\n    try&#123;\n        stu &#x3D; (Student)super.clone();\n    &#125;catch(CloneNotSupportedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    return stu;\n&#125;\n&#125;\npublic class Test &#123;\npublic static void main(String args[]) &#123;\n\n    Address addr &#x3D; new Address();\n    addr.setAdd(&quot;杭州市&quot;);\n    Student stu1 &#x3D; new Student();\n    stu1.setNumber(123);\n    stu1.setAddr(addr);\n\n    Student stu2 &#x3D; (Student)stu1.clone();\n\n    System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());\n    System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());\n&#125;\n&#125;\n       &#x2F;&#x2F;输出：\n        &#x2F;&#x2F;学生1:12345,地址:杭州市\n\t\t&#x2F;&#x2F;学生2:12345,地址:杭州市\n&#x2F;&#x2F;改变一下add，结果两个都一样，因为引用的ADDRESS没有实现clone方法。\n\n深复制（深克隆）被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。\n那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。\n换言之，深复制把要复制的对象所引用的对象都复制了一遍。（引用的对象也要实现clone方法）\npublic class Student implements Cloneable&#123;\n    private int number;\n\tprivate Address addr;\n&#x2F;&#x2F;在这省略getset方法\n    @Override\n    public Object clone()&#123;\n        Student stu &#x3D; null;\n        try &#123;\n            stu &#x3D; (Student) super.clone(); &#x2F;&#x2F;浅复制\n        &#125; catch (CloneNotSupportedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        stu.addr &#x3D; (Address) addr.clone();&#x2F;&#x2F;深度复制\n        return stu;\n    &#125;\n&#125;\n\n class Address implements Cloneable&#123;\n    private String add;\n&#x2F;&#x2F;省略getset构造方法\n    @Override\n     public Object clone()&#123;\n         Address addr &#x3D; null;\n        try &#123;\n            addr &#x3D; (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return addr;\n    &#125;\n     \n     public class Test &#123;\n    public static void main(String[] args) &#123;\n        Address addr &#x3D; new Address();\n        addr.setAdd(&quot;西湖区&quot;);\n        Student stu1 &#x3D; new Student();\n        stu1.setNumber(12345);\n        stu1.setAddr(addr);\n        Student stu2 &#x3D; (Student) stu1.clone();\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());\n        addr.setAdd(&quot;杭州市&quot;);\n&#x2F;&#x2F;        stu2.setAddr(new Address(&quot;杭州市&quot;));\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());\n        &#x2F;**\n        输出：\n        学生1:12345,地址:西湖区\n\t\t学生2:12345,地址:西湖区\n\t\t学生1:12345,地址:杭州市\n\t\t学生2:12345,地址:西湖区\n\t\t*&#x2F;\n\n\n\n什么时候使用断言断言（Assertion）是一种调试程序的方式。在 Java 中，使用 assert 关键字来实现断言。\n我们先看一个例子：\npublic static void main(String[] args) &#123;\n    double x &#x3D; Math.abs(-123.45);\n    assert x &gt;&#x3D; 0;\n    System.out.println(x);\n&#125;\n\n语句 assert x &gt;= 0; 即为断言，断言条件 x &gt;= 0 预期为 true。如果计算结果为 false，则断言失败，抛出 AssertionError。\n使用 assert 语句时，还可以添加一个可选的断言消息：\nassert x &gt;&#x3D; 0 : &quot;x must &gt;&#x3D; 0&quot;;\n\n这样，断言失败的时候，AssertionError 会带上消息 x must &gt;= 0，更加便于调试。\nJava 断言的特点是：断言失败时会抛出 AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。\n对于可恢复的程序错误，不应该使用断言。例如：\nvoid sort(int[] arr) &#123;\n    assert arr !&#x3D; null;\n&#125;\n\n应该抛出异常并在上层捕获：\nvoid sort(int[] arr) &#123;\n    if (arr &#x3D;&#x3D; null) &#123;\n        throw new IllegalArgumentException(&quot;array cannot be null&quot;);\n    &#125;\n&#125;\n\n当我们在程序中使用 assert 时，例如，一个简单的断言：\n&#x2F;&#x2F; assert\n\n Run\n-1\n断言 x 必须大于 0，实际上 x 为 -1，断言肯定失败。执行上述代码，发现程序并未抛出 AssertionError，而是正常打印了 x 的值。\n这是怎么肥四？为什么 assert 语句不起作用？\n这是因为 JVM 默认关闭断言指令，即遇到 assert 语句就自动忽略了，不执行。\n要执行 assert 语句，必须给 Java 虚拟机传递 -enableassertions（可简写为 -ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果：\n$ java -ea Main.java\nException in thread &quot;main&quot; java.lang.AssertionError\n\tat Main.main(Main.java:5)\n\n还可以有选择地对特定地类启用断言，命令行参数是：-ea:com.itranswarp.sample.Main，表示只对 com.itranswarp.sample.Main 这个类启用断言。\n或者对特定地包启用断言，命令行参数是：-ea:com.itranswarp.sample...（注意结尾有 3 个.），表示对 com.itranswarp.sample 这个包启动断言。\n实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解 JUnit 的使用。\n小结\n断言是一种调试方式，断言失败会抛出 AssertionError，只能在开发和测试阶段启用断言；\n对可恢复的错误不能使用断言，而应该抛出异常；\n断言很少被使用，更好的方法是编写单元测试。\nspring框架中单例beans是线程安全的吗\n不是，Spring 框架中的单例 bean 不是线程安全的。spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 “singleton” 变更为 “prototype”，这样请求 bean 相当于 new Bean () 了， 保证线程安全了。\n有状态就是有数据存储功能。无状态就是不会保存数据。\nSpring 如何处理线程并发问题？一般只有无状态的 Bean 才可以在多线程下共享，大部分是无状态的 Bean。当存有状态的 Bean 的时候，spring 一般是使用 ThreadLocal 进行处理，解决线程安全问题。\nThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了 “时间换空间” 的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了 “空间换时间” 的方式。ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。\n\n在 @Controller/@Service 等容器中，默认情况下，scope 值是单例 - singleton 的，也是线程不安全的。\n尽量不要在 @Controller/@Service 等容器中定义静态变量，不论是单例 (singleton) 还是多实例 (prototype) 他都是线程不安全的。\n默认注入的 Bean 对象，在不设置 scope 的时候他也是线程不安全的。\n一定要定义变量的话，用 ThreadLocal 来封装，这个是线程安全的。\n\nSpring Bean 作用域Spring 的 bean 作用域（scope）类型有 5 种：\n1、singleton: 单例，默认作用域。\n2、prototype: 原型，每次创建一个新对象。\n3、request: 请求，每次 Http 请求创建一个新对象，适用于 WebApplicationContext 环境下。\n4、session: 会话，同一个会话共享一个实例，不同会话使用不用的实例。\n5、global-session: 全局会话，所有会话共享一个实例。\n线程安全这个问题，要从单例与原型 Bean 分别进行说明。\n「原型 Bean」对于原型 Bean, 每次创建一个新对象，也就是线程之间并不存在 Bean 共享，自然是不会有线程安全的问题。\n「单例 Bean」对于单例 Bean, 所有线程都共享一个单例实例 Bean, 因此是存在资源的竞争。\n如果单例 Bean, 是一个无状态 Bean，也就是线程中的操作不会对 Bean 的成员执行「查询」以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。\nspring 单例，为什么 controller、service 和 dao 确能保证线程安全？Spring 中的 Bean 默认是单例模式的，框架并没有对 bean 进行多线程的封装处理。实际上大部分时间 Bean 是无状态的（比如 Dao） 所以说在某种程度上来说 Bean 其实是安全的。\n但是如果 Bean 是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变 bean 的作用域 把  singleton 改为 protopyte， 这样每次请求 Bean 就相当于是 new Bean () 这样就可以保证线程的安全了。\n有状态就是有数据存储功能 无状态就是不会保存数据\ncontroller、service 和 dao 层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。\nJava虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。\n局部变量的固有属性之一就是封闭在执行线程中。\n它们位于执行线程的栈中，其他线程无法访问这个栈。\n\n所以其实任何无状态单例都是线程安全的\n首先问 @Controller @Service 是不是线程安全的？\n答：默认配置下不是的。为啥呢？因为默认情况下 @Controller 没有加上 @Scope，没有加 @Scope 就是默认值 singleton，单例的。意思就是系统只会初始化一次 Controller 容器，所以每次请求的都是同一个 Controller 容器，当然是非线程安全的。\n","slug":"面试积累","date":"2022-01-10T14:32:21.000Z","categories_index":"面试积累","tags_index":"前后端","author_index":"icarus"},{"id":"3af103a46c3b6ba55fd2cb594bfaa7e8","title":"网上的面试题","content":"3.1 Java 相关3.1.1 ArrayList\n使用场景：ArrayList 的底层是一个数组，适合快速匹配，不适合频繁的增删\n允许 add null 值，会自动扩容，其中 size (),isEmpty (),get (),add () 方法的复杂度为 O (1)\n使用 Collentions.synchronizedList ()，实现线程安全或者 Vector 也可（Vector 在方法上加的 synchronized 锁）\n调用无参构造函数的时候，在 JDK1.8 默认为空数组（DEFAULT_EMPTY_ELEMENTDATA = {}），数字大小为 10 是我们第一次调用 add 方法是进行扩容的数组大小若我们在执行构造函数传入的数组大小为 0 时，它使用的不是 DEFAULT_EMPTY_ELEMENTDATA，而是另一个空数组 EMPTY_ELEMENTDATA = {}（这个知识点面试没说过）\nadd 方法的过程先确定数组大小是否足够，如果我们创建 ArrayList 的时候指定了大小，那么则以给定的大小创建一个数组，否则默认大小为 10；容量够大的情况，直接赋值；如果容量不够大，则进行扩容方法 grow ()，扩容的大小为原来大小的 1.5 倍（newCapicity = oldCapicity + oldCapicity&gt;&gt; 1，其中 &gt;&gt;1，右移一位除以 2），如果扩容后的大小还不够的话，则会将数组大小直接设置为我们需要的大小，扩容的最大值为 Integer.MAX_VALUE，之后会调用 Arrays.copyOf () 方法将原数组中的数组复制过来其中 Arrays.copyOf () 底层调用的是 System.arrayCopy ()，大家可以去简单了解下\nremove 方法该方将被删除位置后的元素向前复制，底层调用的也是 System.arrayCopy () 方法，复制完成后，将数组元素的最后一个设置为 null（因为向前复制一个位置，所以最后位置的元素是重复的），这样就解决了复制重复元素的问题\n迭代器和增强 for 是一样的（这是一个 Java 语法糖，我后边还会再写语法糖相关的），过程中会判断 modCount 的值是否符合循环过程中的期望，如果不符合的话则会抛出并发修改异常，比较常见的情况就是在增强 for 中进行删除操作\n\n3.1.2 LinkedList\n使用场景：适合增删，不适合快速匹配\n底层数据结构是双向链表，每一个节点为 Node，有 pre 和 next 属性\n提供从头添加和从尾添加的方法，节点删除也提供了从头删除和从尾删除的方法\n\n3.1.3 HashMap\n底层数据结构：数组 + 链表 + 红黑树\n允许 put null 值，HashMap 在调用 hash 算法时，如果 key 为 null，那么 hash 值为 0，这一点区别于 HashTable 和 ConcurrentHashmap(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\nloadFactor：负载因子默认为 0.75，是均衡了时间和空间损耗计算出来的，较高的值会减少空间的开销，扩容减小，数组大小增加速度变慢，但是增加了查找的成本，hash 冲突增加，链表变长\n如果有很多需要储存到 HashMap 中的数据，要在一开始把它的容量设置为足够大，防止出现不断扩容\n通过 Collections.synchronizedMap () 来实现线程安全或者使用 ConcurrentHashmap\n需要记住的字段如下\n\nDEFAULT_INITIAL_CAPICITY &#x3D; 1 &lt;&lt; 4; 默认大小为16\nMAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30; 最大容量\nDEFAULT_LOAD_FACTOR &#x3D; 0.75f; 默认负载因子\nTREEIFY_THRESHOLD &#x3D; 8; UNTREEIFY_THRESHOLD &#x3D; 6; 树化和退化为链表的阈值\nMIN_TREEIFY_CAPACITY &#x3D; 64; 链表转化为红黑树时需要的数组大小\nthreshold 表示扩用的阈值，大小为 数组大小*负载因子\n\n\nput 过程首先会判断数组有没有进行初始化，没有的话，先执行初始化操作，resize () 方法(n - 1) &amp; hash 用来定位到数组中具体的位置，如果数组中的该位置为空，直接在该位置添加值如果数组当前位置有值的话，如果是链表，采用的是尾插发，并且当链表长度大于等于 8 时，会进行树化操作；如果是红黑树的话，则会调用红黑树的插入值的方法；添加完成后，会判断 size 是否大于 threshold，是否需要扩容，若扩容的话，数组大小为之前的 2 倍大小，扩容完成后，将原数组上的节点移动到新数组上。一篇我觉得写得不错的博客儿：HashMap 扩容时的 rehash 方法中 (e.hash &amp; oldCap) == 0 算法推导\n为什么树化操作的阈值是 8？链表的查询时间复杂度为 O (n)，红黑树的查询时间复杂度为 O (logn)，在数据量不多的时候，使用链表比较快，只有当数据量比较大的时候，才会转化为红黑树，但是红黑树占用的空间大小是链表的 2 倍，考虑到时间和空间上的损耗，所以要设置边界值（其实链表长度为 8 的概率很低，在 HashMap 注释中写了，出现的概率不择千万分之一，红黑树只是为了在极端情况下来保证性能）\n为什么还要有一个阈值是 6？（去年面试快手的时候问过）避免频繁的进行树退化为链表的操作，因为退化也是有开销的，当我们移除一个红黑树上的值的时候，如果只有阈值 8 的话，那么它会直接退化，我们若再添加一个值，它有可能又需要变为红黑树了，添加阈值 6 相当于添加了一个缓冲\nhash 算法(key == null) ? 0 : (h = key.hashCode ()) ^ (h &gt;&gt;&gt; 16)，右移 16 位的操作使得 hash 值更加分散\n为什么数组大小始终为 2 的 n 次幂？因为在确定某个值在数组位置的下标时，采用的是（数组大小 - 1）位与上 hash 值，而数组大小减一之后，用 2 进制表示最后几位都是 1，这样每位在位与运算之后，不是 0 就是 1，如果我们 hash 值是均匀分布的话，那么我们得到的数组下表也是均匀分布的，而如果我们的数组容量不是 2 的 n 次幂，那么就没有这个特性了\n数组大小为什么默认是 16？16 是一个经验值，2，4，8 有些小，会频繁的扩容，32 有些大，这样就多占用了空间\n为什么 JDK1.8 采用了尾插法？JDK1.7 时采用的是头插法，它在扩容后 rehash，会使得链表的顺序颠倒，引用关系发生了改变，那么在多线程的情况下，会出现链表成环而死循环的问题，而尾插法就不会有这样的问题，rehash 后链表顺序不变，引用关系也不会发生改变，也就不会发生链表成环的问题\n红黑树的 5 个特点根节点是黑色；所有叶子节点是黑色；其他节点是红色或黑色；从每个叶子节点到根节点所有路径上不能有两个连续的红色节点；从任一节点到每个叶子节点的所有简单路径上包含相同数量的黑色节点\nHashMap 和 Hashtable 的区别实现方式不同：Hashtable：继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类初始容量不同：HashMap 的初始容量为 16，Hashtable 为 11，负载因子都是 0.75扩容机制不同：HashMap 是翻 2 倍，Hashtable 是翻两倍 + 1\n\n3.1.4 HashSet、TreeMap、TreeSet、LinkedHashMap、LinkedHashSet\nHashSet 底层基于 HashMap 实现，若想实现线程安全，需要使用 Collections.synchronizedSet ();它在底层组合的 HashMap，并没有继承关系，其中 Value 值使用的都是被声明为 Object 的 PRESENT 对象private static final Object PRESENT = new Object();\nTreeMap 的底层数据结构是红黑树，会对 key 进行排序，维护 key 的大小关系我们可以传入比较器 Comparator 或者让作为 key 对象的类实现 Comparable 接口重写 compareTo 方法禁止添加 null 值\nLinkedHashMap 本身继承了 HashMap，拥有 HashMap 的所有特性，在此基础上添加了两个新的特性：能按照插入的顺序进行访问（不过它仅仅提供了单向访问，即按照插入的顺序从头到尾访问）；能实现访问最少最先删除的功能（LRU 算法）\nLinkedHashSet 底层基于 LinkedHashMap 实现\n\n3.1.5 ConcurrentHashMap（JDK1.8）\n底层基于 CAS + synchronized 实现，所有操作都是线程安全的，允许多个线程同时进行 put、remove 等操作\n底层数据结构：数组、链表和红黑树的基础上还添加了一个转移节点，在扩容时应用\ntable 数组被 volatile 修饰\n其中有一个比较重要的字段，sizeCtl= -1 时代表 table 正在初始化table 未初始化时，代表需要初始化的大小table 初始化完成，表示 table 的容量，默认为 0.75table 大小\nput 过程key 和 value 都是不能为空的，否则会产生空指针异常，之后会进入自旋（for 循环自旋），如果当前数组为空，那么进行初始化操作，初始化完成后，计算出数组的位置，如果该位置没有值，采用 CAS 操作进行添加；如果当前位置是转移节点，那么会调用 helptransfer 方法协助扩容；如果当前位置有值，那么用 synchronized 加锁，锁住该位置，如果是链表的话，采用的是尾插发，如果是红黑树，则采用红黑树新增的方法，新增完成后需要判断是否需要扩容，大于 sizeCtl 的话，那么执行扩容操作\n初始化过程在进行初始化操作的时候，会将 sizeCtl 利用 CAS 操作设置为 - 1，CAS 成功之后，还会判断数组是否完成初始化，有一个双重检测的过程过程：进入自旋，如果 sizeCtl &lt;0, 线程礼让（Thread.yield ()）等待初始化；否则 CAS 操作将 sizeCtl 设置为 - 1，再次检测是否完成了初始化，若没有则执行初始化操作\n在 JDK1.7 采用的是 Segment 分段锁，默认并发度为 16\n\n3.1.6 CopyOnWriteArrayList\n线程安全的，通过锁 + 数组拷贝 + volatile 保证线程安全（底层数组被 volatile 修饰）\n每次进行数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作之后再赋值回去\n对数组的操作，一般分为四步1 加锁2 从原数组中拷贝出新数组3 在新数组上进行操作，并把新数组赋值给原引用4 解锁\n已经加锁了，为什么还需要拷贝新数组？因为在原数组上进行修改，没有办法触发 volatile 的可见性，需要修改内存地址，即将新拷贝的数组赋值给原引用\n在进行写操作的时候，是能读的，但是读的数据是老数组的，能保证数组最终的一致性，不能保证实时一致性；\n存在内存占用问题，写时复制比较影响性能\n\n3.1.7 String\n不变性：类被 final 修饰，不可被继承；String 中保存的是一个字符数组，被 final 修饰，这样它的内存地址是不能改变的，另外它的访问权限是 private，外部无法访问，也没有公开出对其直接修改的 API，所以能保持不变\nequals 方法得看一看\n\npublic boolean equals(Object anObject) &#123;\n    if (this &#x3D;&#x3D; anObject) &#123;\n        &#x2F;&#x2F;内存地址一致的话，为true\n        return true;\n    &#125;\n    &#x2F;&#x2F;判断是不是String类\n    if (anObject instanceof String) &#123;\n        String anotherString &#x3D; (String)anObject;\n        int n &#x3D; value.length;\n        &#x2F;&#x2F;判断字符串长度是否相等，不等直接返回不等\n        if (n &#x3D;&#x3D; anotherString.value.length) &#123;\n            char v1[] &#x3D; value;\n            char v2[] &#x3D; anotherString.value;\n            int i &#x3D; 0;\n            &#x2F;&#x2F;依次比较每个字符\n            while (n-- !&#x3D; 0) &#123;\n                if (v1[i] !&#x3D; v2[i])\n                    return false;\n                i++;\n            &#125;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\n3.1.8 基本类型包装类\n自动装箱与拆箱是 Java 语法糖，发生在编译期（深入理解 JVM 中的前端编译优化）\nCharacter 的缓存为 0-127；Byte、Short、Integer、Long 的缓存为 -128-127，若使用的值是这个范围的值，则直接在缓存中取\nfloat 和 double 在计算中发生精度损失的问题十进制数能转化为二进制数；而小数有时候不能用二进制数进行表示，会造成精度丢失解决办法：使用 BigDecimal，传入构造函数的参数是 String\n\n3.1.9 hashCode () 和 equals () 方法\nhashCode 是 Object 类中一个被 native 修饰的方法，通常是将对象的内存地址转换为整数后返回\n为什么重写 hashCode 必须重写 equals？两个对象相等，hashCode 一定相等；而 hashCode 相等，两个对象不一定相等，需要用 equals 进一步比较\n\n3.1.10 封装、继承和多态\n你是如何理解面向对象的三个特征的？（京东一面问过）面向对象的特性是封装、继承和多态，封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化，这样做使得代码的复用性更高；继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性，这样做扩展了已存在的代码块，进一步提高了代码的复用性；多态是为了实现接口重用，多态的一大作用就是为了解耦，允许父类引用 (或接口) 指向子类 (或实现类) 对象。多态的表现形式有重写和重载\n说说重写和重载重写发生在父类与子类之间，方法名相同，参数列表相同，返回值可以 “变小”，抛出的异常可以 “变小”，访问修饰符权限不能变小，发生在运行期重载实在一个类中，方法名相同，参数列表不同（参数顺序不同也行），返回值和访问修饰符可以不同，发生在编译期\n\n3.1.11 反射\n对于任何一个类，都能获取它的方法和属性，动态获取信息和动态调用方法的功能是反射\n\n3.1.12 Java 语法糖（《深入理解 JVM 第三版》第 10 章 前端编译优化）\n泛型 Java 选择的是 “类型擦除似泛型”，在.java 源代码经过编译成.class 文件后，泛型相关的信息就消失了，泛型是在编译器层面来保证的泛型上界，编译器指导里边存的是 T 的子类，但是不知道是什么具体的类型，只能取，不能往里放泛型下界，能往里放，也能往外拿，但是拿出来的全是 Object 类型，这就使得元素类型失效了\n自动装箱和拆箱\n增强 for 循环，编译后会变为使用迭代器的形式\n条件编译，在 if 条件中，若条件为布尔常量，编译器会把分支中不成立的代码消除掉\n字符串拼接，编译时会自动创建 StringBuilder 对象执行 append 方法拼接\n枚举，编译器会自动创建一个被 final 修饰的枚举类继承了 Enum，所以自定义枚举类型是无法被继承的\n还有其他的语法糖，lambda 表达式等等，大家感兴趣可以再去了解…\n\n3.2 JVM （《深入理解 JVM 第三版》 紫皮儿的，求求了，看看吧，真的挺好的）3.2.1 Java 内存区域\n程序计数器：当前线程的字节码行号指示器，字节码解释器的工作就是通过改变计数器的值来来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成线程私有，没有 OutOfMemoryError 情况\nJava 虚拟机栈：Java 方法执行的线程内存模型，每个方法被执行的时候，Java 虚拟机都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接、方法出口等信息局部变量表中存储的是基本数据类型，对象的引用和 returnAddress 类型线程私有，生命周期与线程相同如果线程请求的栈深度大于虚拟机所允许的深度，会发生 StackOverflowError，若栈容量支持动态扩展，那么可以发生 OutOfMemoryError 情况，在 HotSpot 虚拟机中不会发生 OutOfMemoryError\n本地方法栈：为被 native 修饰的方法提供服务，与虚拟机栈类似\nJava 堆：所有对象实例以及数组都在堆上分配内存，也是垃圾回收器主要管理的内存区域被所有线程共享的一块区域，当堆内存不够用时，会抛出 OutOfMemoryError\n方法区用于储存被虚拟机加载的：类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据；在 JDK1.8 采用元空间来实现也是线程共享的区域，垃圾回收主要针对常量池的回收和类型卸载，但是类型卸载比较苛刻当方法区无法满足内存分配需求时，将会抛出 OutOfMemoryError\n类型卸载的条件该类所有实例已经被回收加载该类的类加载器已经被回收（Java 自带的三个类加载器不会被回收，那么只有我们自己创建的类加载器加载的类型能被回收）该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法\n\n3.2.2 对象的创建过程？\n当 Java 虚拟机遇到一条 new 指定后，首先检查这个这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过（简单点儿说，首先检查对应的类型是否被加载过），若没有，则需要先执行类加载的过程，类加载通过后，为新生对象分配内存，并附上初始值 0 值并设置对象头信息，之后执行构造函数，进行对象的初始化，完成对象的创建\n对象的组成？对象头：MarkWord 和类型指针（确定该对象是哪个类的实例）实例数据：存储各种类型的字段对其填充：任何对象都是 8 字节的整数倍，不足时用它来补齐，非必须有\n啥是 MarkWord？MarkWord 是一个有着动态定义的数据结构，包括哈希码，GC 分代年龄，线程持有的锁，偏向线程 Id，偏向时间戳等（图：《深入理解 JVM 》 p482）\n\n\n3.2.3 内存溢出你给我说说？OutOfMemoryError 和 StackOverFlowError\n如何产生 OutOfMemory？堆内存不够用了，会抛出这个 OutOfMemoryError\n你能用什么方法来抛出这个 Error？可以通过把堆内存通过参数 - Xmx 调小一些，然后写一个 while 的死循环，不断的执行 append 操作\n那如何产生 Stack Overflow Error？这个是栈溢出，我们可以通过写两个方法，A 方法调用 B 方法，B 方法在调用 A 方法，这样可以产生这个 Error\n你还知道其他的 JVM 参数嘛？知道，-Xms 指定堆的初始大小，-Xss 指定栈的大小，-XX:+HeapDumpOnOutOfMemoryError 内存快照的 Dump 文件，可以分析 Dump 文件来查看 OutOfMemoryError\n列举一些垃圾回收的参数（大家随便看看吧，面试没人问过我）指定期望的 GC 的停顿时间（在 Parallel Scavenge、Parallel Old 和 G1 回收器中指定）：-XX:MaxGCPauseMills改变 G2 的 Rigion 容量：-XX:G1HeapRegionSize年轻代大小:-Xmn比例：-XX:SurvivorRatio=8 (8:1:1)大对象直接进入老年代的阈值：-XX:PretenureSizeThreshold\n\n3.2.4 判断对象已死的算法？\n引用计数算法Java 没有采用这种算法，如果产生对象的循环引用会使对象无法被回收\n可达性分析算法从 GC Roots 根据引用关系乡下搜索，搜索过程中所走过的路径为 “引用链”，如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再使用的\n你给我说说啥样的对象是 GC Roots？（《深入理解 JVM 》 p70）在虚拟机栈中引用的对象在方法区中静态属性引用的对象在方法区中常量引用的对象在本地方法栈中引用的对象Java 虚拟机内部的引用（基本数据类型对应的 Class 对象，一些常驻的异常对象：NullPointException，OutOfMemoryError，还有系统类加载器）被同步锁持有的对象反映 Java 虚拟机内部情况的 JMXBean，JVMTI 中注册的回调，本地代码缓存等（面试我从没有说过这一条，再往下问我我不知道该怎么解释）\n对象不能被 GCRoots 引用关联就立即被回收嘛？其实也不是的，通过可达性分析算法分析后发现对象没有和 GCRoots 发生引用，那么它会第一次被标记为可回收，对象可以实现 finalize () 方法，如果在该方法中能够使得对象再次发生与 GCRoots 引用，那么便可以避免被回收，这个方法只会被调用一次\n\n3.2.5 引用关系 （《深入理解 JVM 》 p71）\n强引用：引用赋值操作 Object o = new Object (); 无论什么情况下只用有强引用关系存在，那么对象就不会被回收\n软引用：SoftReference，还有用但是非必须的对象，在发生内存溢出前，会对这些对象进行回收，如果回收完成后再不够用，便抛出内存异常错误\n弱引用：WeakReference，在进行垃圾回收时，不论当前内存是否够用，都会将该引用的对象回收掉\n虚引用：PhantomReference，最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知\n\n3.2.6 垃圾回收算法\n标记复制算法：年轻代采用的都是标记复制算法，当一块内存用完了就把仍然存活的对象复制到另一块内存， 必然会产生一定空间的浪费，但是不会出现空间碎片的情况\n为什么 HotSpot 虚拟机采用 8：1：1 的比例分区？根据绝大多数的对象都熬不过第一轮 GC，Hotspot 采用 8：1：1 的分配策略，90% 的空间为新生代可用内存空间，浪费的是 10%，符合对象朝生夕灭的特点，但是如果 10% 的内存不够用时，有逃生门策略来分配对象（逃生门指的是不够分配的对象直接到老年代）\n跨代引用的问题是如何解决的？（《深入理解 JVM 》 p84）垃圾回收器在新生代中建立了记忆集数据结构，用来避免进行垃圾回收的时候把整个老年代的 GC Roots 都扫描一遍（卡表是记忆集的一种具体实现）\n标记清除算法：CMS 垃圾回收器采用的算法，这种算 *** 产生空间碎片\n标记整理算法：让所有的存活对象都向内存空间的一端移动，然后清理掉边界以外的内存，没有空间碎片的烦恼\n\n3.2.7 几种垃圾回收器\nSerial，面向年轻代的，单线程的的垃圾回收器，采用的是标记复制算法，在进行垃圾回收的时候，必须执行 Stop the world\nParNew，实际上是 Serial 的多线程版本，同样是标记复制算法，也需要在垃圾回收的时候 Stop the world\nParallel Scavenge，面向年轻代，也是多线程的，关注的是达到一个可控制的吞吐量，采用的是标记复制算法，也需要在垃圾回收的时候 Stop the world\nSerial Old，Serial 的老年代版本，采用的是标记整理算法，执行垃圾回收需要 Stop the world\nParallel Old，是 Parallel Scavenge 的老年代版本，支持多线程并行收集，采用标记整理算法，同样也是关注吞吐量\nCMS，获取最短回收停顿为目标，更加关注服务器的响应速度，希望给用户更好交互体验，采用的是标记清除算法，执行过程分为如下四步（两停顿两并发），会产生空间碎片，无法解决 “浮动垃圾”1 初始标记：标记 GC Roots 直接关联的对象，需要 Stop the world2 并发标记：从 GC Roots 遍历能引用到的所有对象3 重新标记：对并发标记阶段的标记进行修正，需要 Stop the world4 并发清除：与用户线程一起运行，执行垃圾回收\nGarbage First，一个浪漫的名字，它是一款面向服务器端应用的垃圾回收器，发布的初衷是为了替代掉 CMS 垃圾回收器，它的垃圾回收机制是面向整个堆，并将其划分为各个大小相等的 Region，采用的算法是标记复制算法，它会维护一个优先级列表，根据我们设置的停顿时间来选择回收收益最大的 Region 进行垃圾回收，将存活的对象复制到空的 Region 中，通过设置停顿时间可以达到在吞吐量和响应速度上的协调，它还有一个 Humongous 区域，只要对象大小超过 Region 的一半，便直接放在这个区域中，它的执行过程为以下四个步骤（三停顿一并发）1 初始标记：标记 GC Roots 直接关联的对象，需要 Stop the world2 并发标记：从 GC Roots 遍历能引用到的所有对象 （前连个阶段和 CMS 基本一致？？？）3 最终标记：处理并发标记后的修正操作，需要 Stop the world4 筛选回收：对各个 Rigion 的回收价值进行排序，根据用户期望的停顿时间按计划回收，并将被回收的 Region 中存活的对象复制到空的 Region 中，再清理掉旧的 Region，需要 Stop the world\nShenandoha 和 ZGC 这个不大问\n\n3.2.8 类加载（《深入理解 JVM 》 第七章）\n讲讲类的生命周期类的生命周期是七个阶段，首先类的加载，然后是连接，连接阶段分为三个步骤，是验证、准备和解析，连接完成之后是初始化，完成初始化之后是类的使用，最后是类的卸载\n说说类加载的过程类加载分三个阶段，加载、连接和初始化，其中连接阶段分为验证、准备和解析。1 加载主要是加载二进制字节流，比如 Class 文件，在方法区中生成 Class 对象2 验证阶段是确保 Class 文件中的字节流包含的信息是否符合《Java 虚拟机规范》的全部约束要求，保证这些信息不会危害虚拟机的安全（有文件格式验证、元数据验证、字节码验证、符号引用验证，我面试从没被问过具体的这几个阶段）3 准备阶段是为类中定义的变量（静态变量）分配内存并设置变量的初始值，但是有一种特殊情况，被 final 修饰的话，则会直接赋值为我们要指定的值（初始值！就是 0，false，null 那种，初始化阶段才是我们程序员写的值，谨记）4 解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程，有类和接口的解析，字段解析、方法解析和接口方法解析（符号引用是以一组符号来描述所引用的目标，它是编译原理方面的概念，有被模块到处或者开放的包，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符，方法的句柄和方法类型，动态调用点和动态常量 《深入理解 JVM 》 p218；直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄）5 初始化阶段是类加载的最后一个步骤，它会收集所有为类变量赋值和静态语句块中的语句，为这些静态变量赋值\n类加载的触发条件1 使用 new 关键字实例化对象的时候2 读取或设置一个类型的静态字段3 调用一个类型的静态方法4 使用反射的方法对类型进行反射调用的时候5 进行类初始化时，如果父类没有初始化，要先触发其父类的初始化6 当一个接口中定义了 JDK8 加入的默认方法，如果有这个接口的实现类发生了初始化，那么接口需要在这之前完成初始化\n比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被用一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等\n双亲委派机制\n\n\n工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类反馈自己无法完成这个加载请求，子加载器才会尝试自己去完成类加载的过程。\n\n双亲委派机制的作用：使得 Java 中的类随它的类加载器一起具备了层级关系，例如 Object 类，无论哪个类加载器要加载这个类，最终都会被启动类加载器加载，这样就使得 Object 类在类加载环境中始终是同一个类，若没有双亲委派机制的话，我们自己定义一个在 java.lang 目录下的 Object 类，那么系统中就会出现多个 Object 类\n如何破坏双亲委派机制？重写 ClassLoader 中的 loadClass () 方法\n\n3.2.9 如果大家有书的话，可以看看《深入理解 JVM 》的第十章和第十一章，前端编译优化和后端编译优化，可能第十章的语法糖能在面试的时候被问一下，第十一章就不大问，不过我实习的时候，带我的 mentor 说还蛮重要的3.2.10 JVM 对锁的优化（《深入理解 JVM 》 p479）\n自旋锁与自适应自旋：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，如果我们可以通过上后面请求锁的线程自旋一会儿，那么将会避免线程切换的开销，但是它还是要占用处理器时间的，如果自旋时间很短的话，它的效果很好，否则长时间的自旋只会白白的浪费处理器时间，自旋的默认值是 10 次；自适应自旋意味着自旋次数不再是固定的了，而是由前一个在同一个锁上的自旋时间及锁的拥有者的状态来决定的，如果很可能获得到锁，那么将自旋等待的次数增多，否则直接省略掉自旋过程，进入阻塞状态，避免浪费处理器资源\n锁消除：对被检测到不可能存在共享数据竞争的锁进行消除\n\npublic String method(String s1, String s2, String s3) &#123;\n  StringBuffer stringBuffer &#x3D; new StringBuffer();\n  stringBuffer.append(s1);\n  stringBuffer.append(s2);\n  stringBuffer.append(s3);\n  return stringBuffer.toString();\n&#125;\n\n\n锁粗化：如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，虚拟机将会把同步锁的范围扩大到整个操作序列的外部，比如上例中，加锁到第一个 append 操作，解锁到最后一个 append 结束\n轻量级锁：是通过 MarkWord 来实现的，在进入同步块的时候，虚拟机会在当前线程的栈帧空开辟出锁记录的空间，用来存储锁对象的 MarkWord 的拷贝，加锁操作是使用一次 CAS 操作把对象的 MarkWord 更新为指向锁记录的指针，解锁操作也是通过一次 CAS 操作实现的，把复制到锁记录空间的 MarkWord 替换回来；但是轻量级锁不能发生竞争，如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效了，必须要膨胀为重量级锁\n偏向锁：在无竞争的情况下把整个同步都消除掉，连 CAS 操作都省去了，（偏就是偏袒的意思，会偏向第一个获取到它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不再需要进行同步），当锁对象第一次被线程获取的时候，通过 CAS 操作把获取到这个锁的线程 ID 记录到对象的 MarkWord 中，CAS 成功的话，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都不会再进行任何同步操作，一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式立刻宣告结束。当对象进入偏向状态的时候，MarkWord 大部分空间都用于存储持有锁的线程 ID 了，若计算一次哈希值后，就需要在该位置存储哈希值，而不能再进入偏向锁模式了，而当一个对象处于偏向锁模式，又收到了需要计算其一致性哈希值的请求，它的偏向模式会理解被撤销，并且锁会膨胀为重量级锁\n\n3.3 Java 并发编程3.3.1 创建线程的 3 种方式public class StarThread1 extends Thread&#123;\n\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;开启线程的第一种方式，继承Thread并重写它的run方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StarThread1 starThread1 &#x3D; new StarThread1();\n\n        starThread1.start();\n    &#125;\n&#125;\npublic class StarThread2 implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;实现runnable接口，重写run方法，并在开启线程时将其传入&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new Thread(new StarThread2()).start();\n    &#125;\n&#125;\npublic class StarThread3 implements Callable&lt;Void&gt; &#123;\n\n    @Override\n    public Void call() &#123;\n        System.out.println(&quot;创建线程的第三种方式，实现Callable接口&quot;);\n        System.out.println(&quot;用Callable接口创建任务，用线程池对其就行提交，返回值为Future，再调用get()方法，获取结果&quot;);\n        System.out.println(&quot;或者将其作为参数传入新建的线程中&quot;);\n        return null;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ExecutorService pool &#x3D; Executors.newFixedThreadPool(1);\n        Future&lt;Void&gt; task &#x3D; pool.submit(new StarThread3());\n        task.get();\n        pool.shutdown();\n        System.out.println(&quot;--------------------------------------&quot;);\n        StarThread3 starThread3 &#x3D; new StarThread3();\n        FutureTask&lt;Void&gt; task1 &#x3D; new FutureTask&lt;&gt;(starThread3);\n        new Thread(task1).start();\n    &#125;\n&#125;\n\n3.3.2 线程池相关import java.util.concurrent.*;\n\npublic class LearnThreadPoolExecutor &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F;CPU密集型,设置最大线程数为：CPU核数\n        Runtime.getRuntime().availableProcessors();\n        &#x2F;&#x2F;IO密集型，根据io任务的线程数来规定最大线程数量\n\n        &#x2F;&#x2F;核心线程数\n        &#x2F;&#x2F;最大线程数，线程池的伸缩性，达到开启条件后，才会不断开启\n        &#x2F;&#x2F;开启条件：当阻塞队列是ArrayBlockingQueue的时候，核心线程全部都处于工作状态，↓\n        &#x2F;&#x2F;且阻塞队列已经被任务塞满了，那么再来新的任务请求，便会开启新的线程\n        &#x2F;&#x2F;若是LinkedBlockingQueue的话，它会不断的存储任务，永远都不会向最大线程数进行线程的扩展！！！\n        &#x2F;&#x2F;活跃时间和活跃时间的单位，当线程的空闲时间超过活跃时间，线程就会被回收\n        &#x2F;&#x2F;阻塞队列：全部核心线程处于忙碌状态，新来的任务放在阻塞队列中\n        &#x2F;&#x2F; 最大承载：队列大小（如果是ArrayBlockingQueue的话）+最大的线程数\n        &#x2F;&#x2F;线程工厂，用于创建线程\n        &#x2F;&#x2F;拒绝策略:AbortPolicy:超过最大承载的话，会发生异常RejectedExecutionException\n        &#x2F;&#x2F;CallerRunsPolicy:哪来的去哪里执行，这里安排不了了\n        &#x2F;&#x2F;DiscardPolicy():多的任务都给我扔了，不执行！\n        &#x2F;&#x2F;DiscardOldestPolicy():将最早执行的任务停止掉，来执行新来的任务\n        ExecutorService threadPool &#x3D; new ThreadPoolExecutor(3, 5,\n                5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3),\n                Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy());\n\n        for (int i &#x3D; 0; i &lt; 33; i++) &#123;\n            int finalI &#x3D; i;\n            threadPool.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; ok &quot; + finalI);\n            &#125;);\n        &#125;\n\n        threadPool.shutdown();\n\n        &#x2F;&#x2F;线程池的作用：统一管理线程，实现线程的复用，更好的利用系统资源\n        &#x2F;&#x2F;四大方法，单个线程的池子；固定线程数的池子；自由伸缩的池子；执行定时任务的池子\n        &#x2F;&#x2F;前两个的阻塞队列为LinkedBlockingQueue\n        &#x2F;&#x2F;CachedThreadPool的阻塞队列为SynchronousQueue\n        ExecutorService singleThreadExecutor &#x3D; Executors.newSingleThreadExecutor();\n        ExecutorService fixedThreadPool &#x3D; Executors.newFixedThreadPool(8);\n        ExecutorService cachedThreadPool &#x3D; Executors.newCachedThreadPool();\n        ScheduledExecutorService scheduledThreadPool &#x3D; Executors.newScheduledThreadPool(10);\n\n        for (int i &#x3D; 0; i &lt; 33; i++) &#123;\n            cachedThreadPool.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName());\n            &#125;);\n        &#125;\n\n        &#x2F;&#x2F;关闭别忘了\n        cachedThreadPool.shutdown();\n\n        &#x2F;&#x2F;TODO 线程池的五种状态\n        &#x2F;&#x2F;RUNNING 接收新任务并处理排队中的任务\n        &#x2F;&#x2F;SHUTDOWN 不接受新任务，处理剩下的任务\n        &#x2F;&#x2F;STOP 不再接收新任务，不处理剩下的任务\n        &#x2F;&#x2F;TIDYING 所与线程都执行完了\n        &#x2F;&#x2F;TERMINATED 线程池终止了\n\n        &#x2F;&#x2F;TODO 线程池的执行流程\n        &#x2F;&#x2F;1. 如果要执行的线程小于核心线程数的话，开启核心线程，直接执行\n        &#x2F;&#x2F;2. 如果大于核心线程数的话，将进程放入阻塞队列中进行排队\n        &#x2F;&#x2F;3. 如果队列中满了话，会开启临时线程执行线程任务\n        &#x2F;&#x2F;4. 如果线程任务超过最大的阈值，也就是大于最大线程数+阻塞队列的值的话，就会采用拒绝策略\n\n        &#x2F;&#x2F;判断是否停止了\n        cachedThreadPool.isTerminated();\n        &#x2F;&#x2F;等待3秒后再进行判断\n        cachedThreadPool.awaitTermination(3, TimeUnit.SECONDS);\n\n        cachedThreadPool.execute( () -&gt; System.out.println(&quot;在shutDown之后，将不再能继续执行任务&quot;));\n\n        &#x2F;&#x2F;强制的立即结束\n        fixedThreadPool.shutdownNow();\n    &#125;\n&#125;\n\n美团技术团队的博客：Java 线程池实现原理及其在美团业务中的实践\n3.3.3 锁！\nsynchronized 的原理依赖对象头中的 MarkWord 和 monitor 监视器，在 Hotspot 虚拟机中，是 ObjectMonitor 对象其中 MarkWord 是实现偏向锁和轻量级锁的关键monitor 是实现重量级锁的原理，当系统检测到是重量级锁的时候，会把等待想到获取锁的线程进行阻塞，被阻塞的线程不会消耗 CPU，但是阻塞和唤醒一个线程时，都需要操作系统来实现，而要完成用户态与内核态之间的转换，状态转换的开销会很大，对应的字节码指令是 monitorenter 和 monitorexit\nsynchronized 和 Lock 的区别1 synchronized 是 java 的关键字，在 JVM 层面；Lock 是 Java 的接口2 synchronized 是非公平锁；Lock 可以设置为公平锁；都是可重入锁3 synchronized 被线程获取后，其他线程必须等待；Lock 可以使用 tryLock 方法尝试获取锁，获取不到可以不等待4 synchronized 会自动释放锁；Lock 需要在 finally 块中手动释放锁5 ReentrantLock 可以绑定多个锁条件（Condition）\nReentrantLock 的原理（你了解 AQS 嘛？）ReentrantLock 的静态内部类 Sync 实现了抽象类 AQS（AbstractQueuedSynchronizer），其中有一个重要的字段是 state，它在 ReentrantLock 中代表的是重入次数，为 0 是代表锁没有被任何线程持有，为 1 是被一个线程持有，每重入一次，state 加一，每执行一次 unlock 方法，state 减一；而 ReentrantLock 的公平锁和非公平锁机制是通过 AQS 中的队列来实现的，若是公平锁的话，每有一个线程想要获取这个锁，需要进入队列排队，而且不能插队，若是非公平锁的话，队列中的线程是可以插队的\nCountDownLatch、Semaphore 的底层也是 AQS，也可以看看\n\n3.3.4 CAS 是啥呀？\nCAS，比较并交换，实现它有三个重要的值，内存值、期望值和要修改的值，如果内存值和我们的期望值一致的话，才会将内存值修改为我们要修改的值，否则不进行修改\nABA 问题，简单去了解一下吧，可以用 AtomicStampedReference 来避免\n\n3.3.5 volatile？\n它有两个特性，一个是可见性，另一个是禁止指令重排可见性是通过 JMM（Java 内存模型）来实现的，JMM 中有主内存，每个线程有自己的工作内存，线程需要对变量进行操作的时候需要将主内存中的值读到工作内存中，修改完成后，volatile 会使其他线程工作内存中的值失效，而且该线程必须将该值同步到主内存中，这样来保证可见性禁止指令重排是通过内存屏障来实现的，在汇编层面，多执行了一个 “lock addl $0x0,(% esp)”，指令重排序是不能把后面的指令重排序到内存屏障之前的位置（《深入理解 JVM p448》）\n\n3.3.6 其实说到 volatile，建议主动交代一下单例模式\n双重检测锁单例\n\npublic class DCLSingle &#123;\n\n  private static volatile DCLSingle single;\n\n  public static DCLSingle getSingle () &#123;\n      if (single &#x3D;&#x3D; null) &#123;\n          synchronized (DCLSingle.class) &#123;\n              if (single &#x3D;&#x3D; null)\n                  single &#x3D; new DCLSingle();\n          &#125;\n      &#125;\n      return single;\n  &#125;\n&#125;\n\n\n饿汉式\n\npublic class Hungry &#123;\n\n  private static final Hungry hungrySingle &#x3D; new Hungry();\n\n  public static Hungry getInstance() &#123;\n      return hungrySingle;\n  &#125;\n&#125;\n\n\n懒汉式\n\npublic class Lazy &#123;\n  private static Lazy lazySingle;\n\n  public Lazy() &#123;\n\n  &#125;\n\n  public static Lazy getLazySingle() &#123;\n      if (lazySingle &#x3D;&#x3D; null) &#123;\n          lazySingle &#x3D; new Lazy();\n      &#125;\n      return lazySingle;\n  &#125;\n&#125;\n\n\n静态内部类\n\npublic class InnerClassLazy &#123;\n\n  &#x2F;&#x2F;静态内部类单例的持有者\n  private static class InnerSingleHolder &#123;\n      public static InnerClassLazy INSTANCE &#x3D; new InnerClassLazy();\n  &#125;\n\n  public static InnerClassLazy getSingleton () &#123;\n      return InnerSingleHolder.INSTANCE;\n  &#125;\n&#125;\n\n\n枚举\n\npublic enum EnumSingle &#123;\n  ENUM_SINGLE;\n  public static EnumSingle getEnumSingle() &#123;\n      return ENUM_SINGLE;\n  &#125;\n&#125;\n\n3.3.7 ThreadLocal我写过的一篇关于 ThreadLocal 的博客儿\n3.3.8 引用逃逸（this escape）public class ThisEscape &#123;\n    &#x2F;&#x2F;this引用逃逸 在构造函数中使用了this，该this代表的就是正在执行构造函数的对象（实例中 B构造的对象）\n    &#x2F;&#x2F;我们按线程来调断点\n    &#x2F;&#x2F;我们在B线程中执行的时候先把obj的引用暴露出去了，并让B线程在这里停下（打一个断点）\n    &#x2F;&#x2F;然后A线程会提前拿到这个引用，然而B线程中该构造器并没有执行完，是的i和j的值都为0，这就是引用逃逸\n    int i;\n    int j;\n    public static ThisEscape obj;\n\n    public ThisEscape() &#123;\n        obj &#x3D; this;\n        this.i &#x3D; 1;\n        this.j &#x3D; 1;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Thread threadB &#x3D; new Thread(() -&gt; &#123;\n            obj &#x3D; new ThisEscape();\n        &#125;,&quot;B&quot;);\n\n        Thread threadA &#x3D; new Thread( () -&gt; &#123;\n            ThisEscape objB &#x3D; obj;\n            System.out.println(objB.j);\n            System.out.println(objB.i);\n        &#125;,&quot;A&quot;);\n\n        threadB.start();\n        threadA.start();\n    &#125;\n&#125;\n\n\nthis 引用逃逸，一般和 final 的禁止指令重排联系起来被 final 修饰的变量在若在构造器中赋值，它是不会被重排到构造器之外的，除非出现 this 的引用逃逸，若没有逃逸的话，执行完构造函数，那么被 final 修饰的值一定是我们代码中给它赋的值\n\n3.4 Spring、SpringMVC，MyBatis，SpringBoot（我只了解个皮毛罢了）\nBeanFactory 和 ApplicationContextBeanFactory 是 Spring 的底层接口，实现了对 Bean 的配置和管理；ApplicationContext 是 BeanFactory 的子接口，并且扩展了一些功能，包括 AOP，国际化，事件驱动，BeanPostProcessor 和 BeanFactoryPostProcessor\nBean 的生命周期它分两个阶段，一个是 BeanDefinition 阶段，另一个是 Bean 实例阶段在 BeanDefinition 阶段，加载 xml 配置文件，将声明的 &lt;bean&gt; 转换为 BeanDefinition，解析注解配置类，在 refresh () 方法的 beanDefinitionRegistryPostProcessor 执行阶段，实现对 @Bean 注解方法的解析并封装成 BeanDefinition在 Bean 实例阶段，首先进行 Bean 的实例化，在 refresh () 方法的 finishBeanFactoryInitialization () 方法中，初始化所有非延迟加载的 bean，实例化入口是 getBean (),doGetBean (), 先从三级缓存中去拿，如果缓存中没有的话，执行 createBean (),doCreateBean () 方法，通过调用 createBeanInstance () 方法生成 Bean 实例；之后进行 Bean 的初始化，执行 populateBean () 方法进行属性赋值和依赖注入，以及初始化阶段的方法回调，回调方法分别是被 @PostConstract 注解修饰的方法，之后执行的是 InitializingBean 的 afterPropertiesSet () 方法，再之后是 init-method 方法，之后再是后置处理器的后置回调；接下来是 Bean 的使用阶段；使用完成后要进行 Bean 的销毁，同样有三个回调方法，被 @PreDestroy 注解修饰的方法，DisposableBean 的 destroy () 方法，destroy-method 方法（注：初始化回调和销毁回调都是有先后顺序的，我就是按执行的先后顺序介绍的）\nBean 的实例化方式1 通过 &lt;bean&gt;, @Bean, @Component 的方式注册 Bean 后实例化2 借助 FactoryBean 实例化 Bean (factory-bean + factory-method)3 使用静态工厂实例化 Bean (factory-method)\nSpring 容器的三级缓存\n\n&#x2F;&#x2F;一级缓存：用于存放完全初始好的bean，拿出来可以直接使用\nMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;(256);\n&#x2F;&#x2F;二级缓存：提前曝光的单例对象缓存，存放原始的bean对象（未填充属性），用于解决循环依赖\nMap&lt;String, Object&gt; earlySingletonObjects &#x3D; new HashMap&lt;&gt;(16);\n&#x2F;&#x2F;三级缓存：单例对象缓存，存放bean工厂对象，用于解决循环依赖\nMap&lt;String, ObjectFactory&gt; singltonFactories &#x3D; new HashMap&lt;&gt;(16);\n\n\nSpring 事务的传播行为1 REQUIRED：必需的（默认值）如果当前没有事务运行，则会开启一个新的事务；如果当前已经有事务运行，则方 *** 运行在当前事务中，“你没有，我开启，你有了，我加入”2 REQUIRES_NEW：新事务如果当前没有事务事务运行，则会开启一个新的事务；如果当前已经有事务运行，则会将原事务挂起，重新开启一个新的事务。当新的事务运行完毕后，再将原来的事务释放，“你没有我开启，你有了我造新的”3 SUPPORTS：支持如果当前有事务运行，则方法运行在当前事务中；如果没有事务运行，则不在事务中运行，“有就有，没有拉到”4 NOT_SUPPORTED：不支持如果当前事务运行，则会将事务挂起，如果当前没有事务运行，则它也不会运行在事务中，“有我不要，没有正好”5 MANDATORY：强制当前方法必须在事务中，如果没有事务，则直接抛出异常，“要干活必须有，没有就打死不干”6 NEVER：不允许当前方法不允许运行在事务中，如果当前已经有事务运行，则抛出异常，“要干活不准有，有了不干活”7 NESTED：嵌套如果当前没有事务运行，则开启一个新的事务；如果当前已经有事务运行，则会记录一个保存点，并继续运行在当前事务中。如果子事务运行中出现异常，则不会全部回滚，而是回滚到哦上一个保存点\nSpring MVC 的处理流程\n\n\n所有的请求发送给 DispatcherServlet 进行处理，DispatcherSerclet 去请求 HandlerMapping，找出容器中被 @Controller 注解修饰的 Bean 以及被 @RequestMapping 修饰的方法，生成 Handler 和 HandlerInterceptor 封装起来并以 HandlerExcutionChain 对象返回，之后 DispatcherServlet 会将 HandlerExcutionChain 发送给 HandlerAdaptor，通过 HandlerAdaptor 执行 Handler 的方法，执行完成后返回 ModelAndView 对象，DispatcherServlet 会把 ModelAndView 发送给 ViewResolver 进行解析，解析完成后返回 View 对象，并进行渲染发送给客户端\n\nMyBatis 缓存使用缓存来减少与数据库交互的次数，从而提高运行效率，进行查询后，将结果放在缓存中，查询时从缓存中拿一级缓存：是 SQLSession 级别的，操作数据库需要 SQLSession 对象，在对象中有一个 HashMap 用来缓存数据，在同一个 SQLSession 中执行两次相同的查询时，第一次会进行缓存，第二次从缓存中拿，执行修改操作后，缓存失效，保证数据的有效性二级缓存：默认是关闭的，是 Mapper 级别的，当多个 SQLSession 使用同一个 Mapper 的 SQL 语句操作数据库的时候，得到的数据会在二级缓存中，也用 HashMap 存，作用域是 Mapper 的 namespace，不同的 SQLSession 两次执行相同的 SQL，第二次会从二级缓存中拿\nSpringBoot 的自动装配原理\n\n3.5 计算机网络和操作系统（准备这里的面试，我更像是一个赌徒）3.5.1 七层和五层\n七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n五层：应用层、传输层、网络层、数据链路层、物理层\n应用层定义应用进程之间的通信和交互规则，有支持域名的 DNS，支持万维网的 HTTP，支持邮件的 SMTP\n传输层负责两台主机进程之间的通信，有 TCP 和 UDP 协议\n网络层负责不同主机间的通信，分数据平面和控制平面，数据平面负责转发，从输入链路接口到输出链路接口；控制平面负责路由选择，从源主机到目的主机的路由器该如何转发数据，有 IP 协议\n数据链路层是将网络层传递下来的 IP 数据报组装成帧，在两个相邻的节点之间链路上传输帧\n\n3.5.2 TCP\nTCP 是面向连接的传输层协议，提供全双工通信，连接是点对点的，提供可靠的交付服务\nTCP 报文结构：源端口和目的端口；序号（客户端和服务端随机生成一个初始值）；确认号（期望收到对方下一个报文段的第一个序号）；标志字段（URG 紧急标志，SYN 同步标志，FIN 终止标志）；接收窗口；校验和\nTCP 可靠原理1 使用检验和来验证传输报文中的错误2 使用定时器来用于超时重传3 使用序号来检测丢失和冗余，使用确认应答来告诉发送方确认收到信息4 TCP 使用流量控制和拥塞控制来保证可靠性流量控制：发送方的发送速率与接收方的接收速率相匹配，通过报文中的接收窗口大小来指定流量拥塞控制：在网络中对资源的请求超过资源可用量的情况叫拥塞（吞吐量小于理想吞吐量），TCP 的发送方会根据在目的路径之间没什么拥塞而增加发送速率，若有拥塞则降低发送速率。通过超时或连续接收到 3 个冗余的 ACK 来判断拥塞，发送速率由拥塞窗口来控制\n拥塞控制算法发送方维护一个叫做拥塞窗口的状态变量 Cwnd，其值取决于网络拥塞程度，动态变化，慢开始算法阈值 ssthresh，发送窗口大小 Swnd慢开始算法：发送窗口大小 = 拥塞窗口大小（一个较小的值 MSS），随着双方通信，收到确认应答报文，拥塞窗口指数级增长，超过慢开始阈值后，使用拥塞避免算法拥塞避免算法：拥塞窗口随着传输轮次，呈线性增长快重传算法：在传输过程中有报文丢失，发送方累计连续 3 次收到重复确认报文，就将相应的报文段立即重传，而不是在该报文段的超时重传计时器超时重传快恢复：减小拥塞窗口的大小，再进行线性增长，开启拥塞避免算法\n三次握手第一次握手：客户端发送建立连接的请求报文给服务器，其中 SYN = 1，ACK = 0第二次握手：服务端收到连接请求报文后，发送一个确认建立连接的应答报文，其中 SYN = 1， ACK = 1第三次握手：客户端收到服务器确认建立连接报文后，还要发送确认应答报文给服务器，其中 ACK = 1\n三次握手的原因1 防止已经失效的连接请求报文突然传送到服务器产生脏连接2 为了实现可靠的数据传输，TCP 连接双方都需要维护一个序列号，若是两次握手的话，服务端发送的序列号得不到确认（客户端可以接收到序列号，但是没有确认收到的回应发送给服务器）\n四次挥手第一次挥手：客户端向服务器发送一个终止连接报文，FIN = 1第二次挥手：服务器收到该报文后，发送给客户端一个确认报文，ACK = 1第三次挥手：服务器在发送完数据，准备释放连接连接时，会向客户端发送终止连接报文，FIN = 1第四次挥手：客户端收到后，发送确认报文，等待 2MSL 后，进入关闭状态\n四次挥手的原因客户端和服务器采用的是全双工通信，发送方和接收方都需要发送 FIN 和 ACK 报文才能断开\n为什么要等待 2MSL 后才能释放连接？1 等待 2MSL 可以保证连接的所有报文都会从网络上消失，防止新旧连接的混淆2 保证服务端能接收到客户端发送的确认报文（如果该报文丢失，服务端没收收到就会超时重传之前的终止连接报文，若客户端直接进入 closed 状态，则无法收到该报文，也不会发送确认报文，那么服务器就无法正常进入 closed 状态）\nUDPUDP 是面向非连接的，不维护连接状态，支持同时向多个客户端传输相同的信息，报文头只有 8 字节，尽最大努力交付，不保证数据可达\nTCP 和 UDP 的应用场景TCP：文件传输，这种数据要求可靠性高的场景；浏览器访问（HTTP）；发送电子邮件UDP：语音聊天；在线视频\n\n3.5.3 HTTP\nHTTP 请求类型1 GET 请求：请求获取数据，是幂等的，像数据库的查询请求，只是用来查询不对数据进行修改2 POST 请求：向服务端提交数据进行处理，数据包含在请求体中，可能导致新的资源建立或修改3 PUT 请求：向服务端发送数据进行修改4 DELETE 请求：是用来删除某一资源的5 HEAD 请求：当服务器收到 HEAD 请求时，将会一个 HTTP 报文进行响应，但并不返回请求对象，常用于方法调试跟踪（当我们发送一个 HEAD 请求到服务器时，会收到一个 HTTP 响应报文，但是其中并不包含我们请求的对象）\nHTTP 请求报文请求行：方法，URL 字段，HTTP 版本首部行：主机名；Connection（表示是否使用持续连接）；User-agent（显示浏览器类型）空行实体体：包含我们请求需要传递的数据\nHTTP 响应报文状态行：HTTP 版本，状态码，状态信息首部行：Connection；Date（时间）；Server（服务器）；Last-Modified（最后修改时间）；Content-length：对象字节数；Content-type（对象类型）实体体：包含我们请求的对象\nHTTP 状态码（列出的我记不太住的…)400 BadRequest 客户端请求语法错误401 Unauthorized 请求未经授权403 Forbidden 拒绝访问500 Internal Server Error 服务器内部错误503 Server Unavailable 服务器当前不能处理客户端的请求\nHTTP1.0 和 HTTP1.1HTTP1.0 使用的是非持续性连接，另外每次请求都会有 2 倍的 RTT 开销，另外客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量，非持续性连接对服务器压力较大HTTP1.1 使用的持续性连接，服务器会在发送响应后一段时间内继续保持这条连接，使同一个浏览器和服务器可以继续在这条连接上传输后续的 HTTP 请求和响应报文，支持请求流水线处理，在一个 TCP 连接上可以传送多个请求和响应\nHTTP 2.0使用多了复用技术，做到同一个连接并发处理多个请求，相比于 HTTP1.1 在同一时间同一域名的限制好了几个数量级HTTP2.0 支持使用 HPACK 算法对 HTTP 首部进行压缩，数据体积小，传输更快了服务器推送：服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次请求获取数据\nHTTPS 是以安全为目标的 HTTP 通道，通过 S.S.L，Secure Sockets Layer 安全套接字协议对称加密：使用相同的密钥进行加密，效率快，安全性好非对称加密：加密和解密的密钥不同，通过双方接收到对方的公钥进行加密，使用私钥进行解密，效率慢，但是安全HTTPS 采用混合加密机制，使用非对称加密用于传输对称加密使用的密钥，之后用对称加密进行通信，保证通信效率\nSSL 握手流程浏览器和服务器建立 TCP 连接后，会发送一个请求，包含了自己可实现的算法列表和必要信息服务器收到请求后，会选择加密算法，然后返回证书，包含非对称加密的公钥，加密算法，服务器信息，申请证书的公司，域名等浏览器收到之后，检查签发证书的机构是否正确，公钥签名是否有效，若有效则生成对称密钥，利用公钥进行加密，发送给服务器服务器收到密钥后，用私钥进行解密，之后浏览器和服务器就可以基于对称加密进行数据通信\n在浏览器输入 URL 对峙，回车后会发生什么？1 先查询 web 缓存器，如果有的话则直接显示2 通过 DNS 域名解析服务解析 IP 地址，先从浏览器缓存中查询，如果没有则查询本地 DNS 服务器的缓存3 通过 TCP 的三次握手建立连接，建立连接后，向服务器发送 HTTP 请求4 服务器收到浏览器的请求后，进行处理并发送响应报文5 浏览器收到服务器的响应报文后，如果可以，进行缓存6 浏览器渲染页面并呈现给用户7 四次挥手断开连接\n\n3.5.4 操作系统（我只赌的这两个问题）\n进程和线程的区别（谨慎参考）进程是资源分配的基本单位，线程是 CPU 调度的基本单位进程包含线程，一条线程只能在一个进程中进程与进程之间是独立的，而线程与线程之间资源可以是共享的\n死锁的条件互斥条件；不可剥夺条件；请求与保持条件；循环等待条件\n\n3.6 Linux 命令（仅仅被问过一次，简历上没写 Linux）\nls 列出目录；cd 切换目录；pwd 显示当前目录；mkdir 创建目录；rmdir 删除目录\ncp 复制目录或文件；rm 移除文件或目录；mv 移动文件或目录\ncat 从第一行正序显示内容；tac 从最后一行开始显示内容；head -n20 显示前 20 行；tail 看尾几行\ntop 常用的 Linux 性能分析命令，可以查看各个进程的资源占用状况\n开启端口 firewall-cmd –zone=public –add-port=80/tcp –permanent；firewall-cmd –state 查看状态；service firewall start/restar/stop 开启 / 重启 / 停止\nps -ef|grep redis 查看 redis 的进程信息 （被问过这个）\n\n3.7 MySQL（《MySQL 是怎样运行的》 这本书无敌！真的，大家有时间一定看看，掘金上也有电子版）\n三大范式（每一范式都在前一范式的基础上）第一范式：每一列都是不可分割的原子项第二范式：每一列都与主键列相关第三范式：每一列与主键列直接相关\nMySQL 聚合函数AVG(),SUM(),COUNT(),MAX(),MIN()…\n\n3.7.1 索引（第六章和第七章）\n为什么用的是 B + 树而不是 B 树？B + 树仅在叶子节点中存储全部的用户记录，而其他节点存储的只有主键和对应的页号，相比于 B 树在每个节点都存储完整的用户记录，B + 树的树高更低，查询效率更高\n区分一下聚簇索引和非聚簇索引（二级索引）聚簇索引：以主键值的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列非聚簇索引：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列 + 主键值，若要获取完整的用户记录需要进行回表查询\n哈希索引查询效率很高，但是只有精确匹配索引列的查询才有效，Memory 印象显示支持哈希索引，也是它的默认索引哈希索引不能进行排序；哈希索引不支持任何范围查询；哈希索引不能利用部分索引查询，对于联合索引，必须把所有的列全用上再进行计算 hash 值自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些值被使用的非常频繁时，会在内存中基于 B+Tree 索引上再建一个哈希索引（完全自动的内部行为）\n使用索引的时候我们有哪些需要注意的？1 只为用于搜索、排序或分组的列创建索引2 索引列的类型应尽量小3 可以只为索引列前缀创建索引，以减小索引占用的存储空间4 尽可能的让主键拥有 AUTO_INCREMENT 属性，避免发生页分裂的情况5 查询时尽量使用覆盖索引，避免回表操作带来的性能损耗\n查询时用不到索引的情况（索引失效的情况）1 使用索引比全表扫描慢，不用索引2 联合索引没使用到第一部分3 模糊查询以通配符 % 开头4 若为字符串索引，与数值进行匹配的时候，数值没用引号，不走索引5 在搜索条件中，索引列不以单独的列名存在，而使用表达式或函数进行操作的时候，不走索引\n\n3.7.2 explain SQL 对应的 type 列解析（第十章）\nconst：用主键或唯一二级索引的常数匹配（非常快！）\nref：二级索引进行常数匹配，形成单点扫描区间\nref_or_null：二级索引进行常数匹配（包含空值）\nrange：范围查询\nindex：扫描全部二级索引或 order by 主键\nall：全表扫描，扫描全部聚簇索引记录\n我为什么要说这个知识点儿？我面京东的时候被问过 explain 后我们怎么发现走没有索引或者优化，我是这么解释的，type 列如果对应的是 all 的话，我们就需要谨慎一些，因为它没有走索引，我们要看看是不是 SQL 语句使索引失效了还是我们没有为查询列创建索引，反过来如果是 const 这种类型的话，它的执行效率是非常高的\n索引合并Intersection 索引合并：是从二级索引回表查询时，获取的主键是有序的，主键取交集查询（where 中 and 条件）Union 索引合并：也是要求从二级索引回表查询获取的主键值有序，取主键值并集查询（or 条件）Sort-Union：对从二级索引回表中获取的主键值进行排序，排序完成后取并集查询\n\n3.7.3 事务（第十八、二十一、二十二章）\nACID 原则原子性：事务作为一个不可在分割的单位，其中的操作要么全部执行成功，要么全部执行失败回滚隔离性：多个事务间不相互干扰，在并发执行期间相互隔离一致性：事务执行前后，数据都保持一致性持久性：事务执行完成后，对数据的影响是永久性的（强调结果）\n隔离级别READ UNCOMMITTED：可能发生脏读、不可重复读和幻读READ COMMITTED：可能发生不可重复读和幻读REPEATABLE READ：可能发生幻读SERIALIZABLE：各种问题都不会发生实际上，MySQL 在 REPEATABLE READ 隔离级别下是可以很大程度上避免幻读出现的（很大程度上！不是完全）\n脏读：一个事务读到了另一个未提交事务修改过的数据\n不可重复读：同一条件下，两次读取的值不相同\n幻读：幻读强调的是一个事务在按照某个相同的搜索条件下多次读取纪录时，读到了之前没有读到的数据（出现了幻行）\n\n3.7.4 日志（第十九、二十章）\nredo log（重启恢复数据时才是爸爸）对数据库的修改并不会立即同步到磁盘中，而是会在 Buffer Pool（缓存池）中进行缓存，由 flush 链表（脏链表）来维护脏页，那么若在未同步时发生断电，需要 redo log 对这些修改数据的操作进行记录，以便重启后对数据进行恢复产生的 redo log 存放在 block 中，block 也相当于页，也会现在 log buffer 缓存区中缓存，它进行同步的时机有 事务提交时；log buffer 超过 50% 空间已用；后台线程以秒为单位刷新；正常关闭服务器；做 checkpoint 时\n对于已经刷新到磁盘的数据，那么对应的 redo 日志已经没用了，可以对这些空间进行覆盖重用\nundo log（主要用于回滚操作），每对记录进行一次增删改都会产生一条 undo log\n这个 redo log 和 undo log 在面试的时候从没被问过…，暂时列举这么多吧，估计用不太上\n\n3.7.5 MVCC（第二十一章）什么是 MVCC？多版本并发控制，在提交读和可重复读两个隔离级别下，执行 select 操作会产生 readview 快照，根据 readview 快照来进行数据读取的过程这两个隔离界别下，产生快照的时机是不同的，在提交读下，每进行一次一次 select 操作都会产生一个新的快照，快照就相当于给数据拍照片，在这个隔离级别下，每查一次就拍一次照，那么获取的数据都是新的，所以有不可重复读和幻读的情况发生；而在可重复读隔离级别下，只在第一次查询的时候拍一张照，每次再查询都要看最开始生成的这样照片，那么它就避免了不可重复读的情况，也在一定程度上避免了幻读为什么是一定程度上而不是完全避免？如果我们现在在 A 事务中执行了一次查询，那么它已经有了 readview 快照，那么事务 B 插入一条数据进来，事务 A 在进行查询的话，还是看不到这条数据的（在匹配条件符合的情况下），但是 A 事务是能够对这条数据进行修改的！重点在这里，对这条数据修改之后，该行数据的隐藏列的事务 id 就会变成 A 事务的事务 id，这时，A 事务在进行查询，就能看见这条新增的数据了，所以是不能完全避免幻读，避免幻读需要使用 gapLock 间隙锁，它能防止其他事务插入数据Readview 快照访问数据的原理，ReadView 中存储的是最小事务 id，最大事务 id，当前正在运行的事务 id，生成该 Readview 的事务 id，根据这些 id 号去访问数据，只有数据的事务 id 号小于最小事务 id 或者是事务 id 是生成该 Readview 的事务 id 才能被访问到\n3.7.6 锁（第二十二章）\n被问的比较少\nSELECT … LOCK IN SHARE MODE 语句为读取的记录加共享锁\nSELECT … FOR UPDATE 语句为读取的记录加排他锁\nRecord Lock：只会对记录本身加锁（提交读隔离级别下下采用的是这个锁）\nGap Lock：锁住的是记录前的间隙，防止别的事务向该间隙插入新记录，避免幻读\nNext-Key Lock：Record Lock 和 Gap Lock 的结合体，既保护记录本身，也防止别的事务向该间隙插入新纪录（可重复读下采用的是这个锁）\n死锁发生时，InnoDB 会选择一个较小的事务进行回滚，可以通过查看死锁日志来分析死锁的发生过程\n\n3.8 Redis（《Redis 设计与实现》这本书非常好，非常值得一读，行文很流畅！）\n关于读这本书的一个技巧，可以从第八章开始读，然后每一个对象类型都会对应不同的编码格式，每看到一个编码格式，就去翻前边的章节看它写的是怎么回事儿，这样我觉得更清晰一些，后边的章节顺序读就好\nRedis 缓存穿透、击穿、雪崩的解决方案缓存穿透：指查询一个不存在的数据（缓存中没有，数据库中也没有），如果从存储层查询不到，也不写入缓存，这将导致这个不存在的数据每次请求都会 DB 查询，可能导致 DB 挂掉；解决方案：1 查询的数据为空时，仍把这个空结果进行缓存，设定一个比较短的过期时间2 采用布隆过滤器，不存在的数据会被布隆过滤器拦截，从而避免了对 DB 的查询3 接口增加校验，对不合法的参数直接 return缓存穿透：指缓存中没有，但是数据库中有的数据，有大量的请求过来，引起数据库压力过大解决方案：设置热点数据永不过期缓存雪崩：大量的 key 设置了相同的过期时间，导致缓存在某一时刻的失败，使得请求全部到 DB 上，导致 DB 压力过大解决方案：将缓存失效时间分散开，为 key 的过期时间加上一个随机值\nRedis key 的删除策略和淘汰策略在 redis.conf 文件中设置了配置最大可用内存（maxmemory），在未达到最大使用内存时，键自身设置了过期时间的情况下，Redis 会删除过期键，采用定期删除或惰性删除，在达到最大内存使用限制时，会根据配置项 maxmemory-policy 来进行相应的淘汰策略删除策略：1 惰性删除，程序只会在使用键时对键进行过期检查，过期删除，比较浪费内存2 定期删除：每隔一段时间执行一次删除过期键的操作，必须在设置时间和删除频率来达到节省内存和合理使用 CPU 的目的3 定时删除（Redis 没采用这种，书中 p108），使用定时器来对 key 进行删除，对内存最友好淘汰策略：1 volatile-lru，从设置了过期时间的数据集中选出最近最少使用的数据淘汰2 volatile-ttl，从设置了过期时间的数据集中优先删除剩余时间短的 key3 volatile-random，从设置了过期时间的数据集中岁间选择数据进行删除4 allkeys-lru，从所有 key 中，挑选最近最少使用的数据淘汰5 allkeys-random，从所有 key 中，选择任意数据淘汰6 no-eviction，禁止淘汰数据\n\n3.8.1 五种对象类型（第八章）\nString 类型编码格式：int，embstr，rawint 保存的是可以用 long 类型保存的整数embstr 保存的是字符串长度小于等于 39 字节的短字符串raw 保存字符串大于 39 字节其中 embstr 和 raw 使用的都是 SDS（简单动态字符串类型），它的底层是一个字符数组，其中存有字符串长度和字符数组中未使用的长度long 和 double 类型也作为字符串类型保存，对其进行操作时会转换为浮点数，再转为字符串存起来\nList 类型编码格式 ziplist（压缩列表），linkedlist（双端链表）ziplist 是在节点数小于 512 个且每个字符长度小于 64 字节时使用，它是一种连续内存的顺序型数据结构linkedlist，具有双端列表的特性\nhash 类型编码格式：ziplist，hashtableziplist 要求数量小于 512 个，键和值长度小于 64 字节，键和值紧挨着连续存储，用两个节点hashtable，使用 map 作为底层实现\nset 类型编码格式：intset，hashtableintset 要求元素都是整数，且小于 512 个hashtable 只使用字典的 key，而 value 值为 null\nzset 类型（这个被问的几率大一些）编码格式：ziplist 和 skiplistziplist 要求数量小于 512，元素大小小于 64 字节，每个元素用两个紧挨着的压缩列表节点，第一个保存元素的成员，第二个保存分值，并会从小到大的顺序排序，分值较小的放置在靠近表头的位置skpilist 使用的是 map 和跳表两种数据结构，它们共享 zset 中的对象，不会复制元素而造成浪费map 的作用是能够以 O（1）的时间复杂度来获取对象的 score，键时元素成员，值是元素的分值（ZSCORE 命令）跳表是有序的数据结构，对象不可重，分值可重，分值重的按对象大小排序，每个节点都有一个随机的层高，每层保留前往下一个节点的指针和跨度，能够进行快速匹配，调用 zrank 和 zrange 进行范围操作\n\n3.8.2 RDB 持久化机制（第十章）\n对应的命令 SAVE 和 BGSAVE，BGSAVE 会 fork 出一条子进程，由子进程创建 RDB 文件，父进程继续处理命令请求\n若有 AOF 文件的时候，不会选择 RDB 文件进行数据恢复\n在配置文件中，我们可以配置执行 RDB 持久化的频率，在多少秒内进行了多少次修改就进行一次持久化save 900 1save 300 10save 60 10000\n原理：底层会用一个数组保存上边的信息，还会维护一个 dirty 计数器来保存修改次数和 lastsave 属性来存储上一次执行 BGSAVE 的时间，redis 调用周期函数检查是否符合 RDB 持久化的条件\n\n3.8.3 AOF 持久化机制（第十一章）\n通过保存 Redis 服务器的写命令来记录数据库的状态，载入时将命令全执行一遍，配置文件中有 3 种同步机制always，将 aof 缓冲区中的内容写入 aof 文件并立即同步到磁盘中everysecond，将 aof 缓冲区中的内容写入 aof 文件，并检查上次操作是否超过一秒，超过则进行同步no，不进行同步，具体时机由系统来决定\naof 重写，解决 aof 文件体积太大的问题，创建一个新的 aof 文件来替换原文件，对应的命令是 BGREWRITEAOF\n重写原理：先读出所有的键值，之后用一条命令去记录，代替之前的多条命令。子进程在进行 aof 文件重写时，服务器还会对数据进行修改，这就会产生数据不一致的问题，为了解决该问题，会使用 aof 重写缓冲区，执行的命令会在重写过程中向缓冲区中追加，当子进程完成重写操作时，它会向父进程发送信号，此时父进程会将 aof 重写缓冲区中的所有内容写入到 aof 文件中，并将原 aof 文件进行覆盖，完成重写操作\n\n3.8.4 主从复制（第十五章）\n主从复制的实现包括同步和命令传播两步，主从服务器都会维护一个复制偏移量，主服务器每执行一条命令都会使偏移量增加，从服务器也一样，数据相同时，偏移量也相同\n初次同步，从服务器向主服务器发送 PSYNC 命令，主服务器执行 BGSAVE，在后台生成一个 RDB 文件，并使用缓冲区记录从现在开始执行的所有写命令，之后会将 RDB 文件发送给从服务器，从服务器载入这个 RDB 文件，并执行从主服务器缓冲区中传过来的写命令，使主从服务器状态一致\n命令传播，主服务器会将之后执行的写操作命令发送给从服务器执行\n断线重连后，可能会执行部分重同步或者全同步，如果在复制积压缓冲区中，仍然记录有从服务器偏移量之后的数据，那么便可以执行部分重同步，将这些命令发送给从服务器，相反的话，就执行全同步；从服务器还会存有主服务的 ID，如果重连的一致，那么将进行重同步或部分重同步，如果不一致，直接全同步\n心跳检测：检测主从服务器的网络连接状态，如果超过一秒没有收到心跳检测命令，那主服务器就知道从服务器出了问题；检测命令丢失，如果主服务器向从服务器传播的命令由于网络原因丢失，那么会根据心跳检测的复制偏移量来进行检测，不同的话会采用命令传播进行部分重同步\n\n3.8.5 哨兵模式（第十六章）\nSentienl 实例可以监控一个或多个主服务器和从服务器，当有主服务器下线的时候，自动将下线主服务器属下的某个从服务器升级为新的主服务器\nSentinel 实例中会存有 master，slave 和其他 sentinel 的信息\n检测主观下线：sentinel 会以 1 秒 1 次的频率向其他服务器（主、从、sentinel）发送 PING 命令，若超过我们在配置文件中配置的超时时间，在该时间内是无效回复，那么该 sentinel 会认为它主观下线\n检测客观下线：sentinel 会询问其他监视该服务器的 sentinel，当认为该服务器主观下线的数量大于等于我们在配置文件中的客观下线票数时，会认为它客观下线，认为该主服务器客观下线后，监视这个主服务器的 sentinel 会挑选出一个零头 sentinel，并由该 sentinel 进行故障转移操作\n故障转移1 在已经下线的主服务器的从服务器里边，挑选一个作为主服务器2 让其他的从服务器复制新的主服务器3 将已下线的主服务器设置为新主服务器的从服务器，它上线后直接成从服务器\n重要的配置信息\n\nsentinel monitor master1 127.0.0.1 6379 2 &#x2F;&#x2F;2为所需支持的投票数量\nsentinel down-after-milliseconds master1 30000 &#x2F;&#x2F;30000毫秒实例未响应的时间，超时主观下线\n\n","slug":"面试题2","date":"2022-01-07T14:32:21.000Z","categories_index":"面试","tags_index":"java","author_index":"icarus"},{"id":"8f31d06ea2e56b4b6405cdb90df6568a","title":"hexo命令","content":"hexo官方文档https://hexo.io/zh-cn/docs/\n常用命令：\nhexo cl &amp; hexo g                                       ————–重建静态文件\nhexo n “文章标题”                                    —————建立新文章\nhexo clean &amp; hexo g &amp; hexo server        ————-一键清除并重新构建在本地测试\nhexo d                                                         ————-推送到github\nhexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署\nhexo server #Hexo 会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令\n","slug":"hexo命令","date":"2022-01-05T14:32:21.000Z","categories_index":"Hexo","tags_index":"hexo","author_index":"icarus"},{"id":"5f849d772fd372114a5b63b97d1479ef","title":"面试题","content":"object类中的方法：实现对象的浅拷贝的clone方法\n获得运行时类型的getclass方法\n释放资源的finalize方法\n用户哈希查找的hashcode方法\n使当前线程等待该对象的锁wait方法\n访问修饰符：​                本类中  同个包  子类  任何地方\npublic \nprotect \ndefault \nprivate\n在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n抽象类必须被继承才能使用\n  CREATE PROCEDURE myproc(OUT s int)\n    BEGIN\n      SELECT COUNT(*) INTO s FROM students;\n    END\n    &#x2F;&#x2F;\nDELIMITER ;\n\nObject 类方法Object 是所有类的父类，任何类都默认继承 Object。Object 类到底实现了哪些方法？\n（1）clone 方法\n保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。\n（2）getClass 方法\nfinal 方法，获得运行时类型。\n（3）toString 方法\n该方法用得比较多，一般子类都有覆盖。\n（4）finalize 方法\n该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。\n（5）equals 方法\n该方法是非常重要的一个方法。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。\n（6）hashCode 方法\n该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法。这个方法在一些具有哈希功能的 Collection 中用到。\n一般必须满足 obj1.equals (obj2)==true。可以推出 obj1.hash- Code ()==obj2.hashCode ()，但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\n（7）wait 方法\nwait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait () 方法一直等待，直到获得锁或者被中断。wait (long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。\n调用该方法后当前线程进入睡眠状态，直到以下事件发生。\n（1）其他线程调用了该对象的 notify 方法。\n（2）其他线程调用了该对象的 notifyAll 方法。\n（3）其他线程调用了 interrupt 中断该线程。\n（4）时间间隔到了。\n此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。\n（8）notify 方法\n该方法唤醒在该对象上等待的某个线程。\n（9）notifyAll 方法\n该方法唤醒在该对象上等待的所有线程。\n如何理解面向对象的三个特征的？面向对象的特性是封装、继承和多态，封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化，这样做使得代码的复用性更高；继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性，这样做扩展了已存在的代码块，进一步提高了代码的复用性；多态是为了实现接口重用，多态的一大作用就是为了解耦，允许父类引用 (或接口) 指向子类 (或实现类) 对象。多态的表现形式有重写和重载\n说说重写和重载重写发生在父类与子类之间，方法名相同，参数列表相同，返回值可以 “变小”，抛出的异常可以 “变小”，访问修饰符权限不能变小，发生在运行期重载实在一个类中，方法名相同，参数列表不同（参数顺序不同也行），返回值和访问修饰符可以不同，发生在编译期\nSpring IOC / DI 底层实现原理问题说明：Spring 是如何通过配置文件，就完成了对象的创建和属性的赋值？答案：\n使用工厂设计模式 + 配置文件 + 反射描述：使用工厂设计模式，在工厂中，根据配置文件中标签的 class 属性，反射创建出对象。再根据标签的子标签标签的 name 属性，反射找到对应的 set 方法，反射调用 set 方法将标签的 value 属性的值 赋给属性。\nSpring AOPSpring AOP 概念问：你对 Spring AOP 有什么理解？\n思想： 面向切面编程在不修改目标类代码的情况下，在运行时，动态的为目标对象的目标方法增加额外功能，实现解耦合，提高代码的可维护性。\n本质： 在不修改目标类代码的情况下，在运行时，动态的为目标对象生成代理对象，用代理对象取而代之，代替目标对象接受调用，变相的实现了功能增强的效果。\nSpring AOP 底层实现原理问题说明： Spring AOP 是如何生成代理类对象的？\n答案： 使用 JDK 的 Proxy 的静态方法 newProxyInstance，内部执行动态字节码技术，产生代理类对象，产生代理类的对象。基于接口生成的。\n堆和栈的区别有：1、空间分配区别；2、缓存方式区别；3、数据结构区别。堆空间一般由程序员分配释放，栈空间由操作系统（编译器）自动分配释放。栈使用一级缓存，堆使用二级缓存。\n堆和栈的区别是什么1、堆栈空间分配区别\n栈（操作系统）：由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。\n2、堆栈缓存方式区别\n栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。\n堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。\n3、堆栈数据结构区别\n堆（数据结构）：堆可以被看成是一棵树，如：堆排序。\n栈（数据结构）：一种先进后出的数据结构。\n对象进堆 方法进栈 \n流复习直接操作文件——&gt; FileOuputStream、FileInputStream\n语法是：FileOutputStream （可以是String或者是File ，true / false ） 是否拼接可写可不写，默认是false\n节点流：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如 FileInputStream 和 FileOutputStream，他们直接从文件中读取或往文件中写入字节流。\n在已存在的输入或输出流上操作——&gt; BufferedInputStream 和 BufferedOutputStream\n语法是：BufferedOutputStream（new  FileOutputStream）\n处理流：“连接” 在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如 BufferedInputStream 和 BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率\n DataInputStream 和 DataOutputStream，使用已经存在的节点流来构造，提供了读写 Java 中的基本数据类型的功能。他们都属于过滤流。用了之后就可以使用writeInt、writeBoolean方法等等来书。\nlen = fis.read (bys)   \n包含两个动作：1. 代表每次最多从目标文件中读取 1024 个字节. 2. 返回每次读取多少个字节长度 (由于 read (bys) 向 bys 写入的数据是覆盖的，并不是替换 , 所以必须要返回字节长度，避免输出以外的字节)fis.read (bys) !=-1  表示当读取的目标文件到末尾了，没有剩余的字节了，就会返回 - 1, 通过是否等于 - 1 的判断，继续是否读取.new String (bys,0,len) 表示每次把 bys 里面的数据，从 0 到 len 的长度读取出去，len 控制了每次 bys 能读取到的字节长度，避免 bys 覆盖造成的错误. 通过构造方法转换成字符串输出\n BufferedOutputStream 输出数据时需要关闭流，否则数据不会输出到文件当中\n字节流和字符流的区别字节流操作的基本单元为字节；字符流操作的基本单元为 Unicode 码元。字节流默认不使用缓冲区；字符流使用缓冲区。字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用 close 或 flush 方法，则不会输出任何内容。字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取 Unicode 码元；字符流通常处理文本数据，它支持写入及读取 Unicode 码元。字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理 Unicode 字符，而字符流就可以。\n字节流和字符流的转换字节流是最基本的，所有的 InputStream 和 OutputStream 的子类都是，主要用在处理二进制数据，它是按字节来处理的，但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的 encode 来处理，也就是要进行字符集的转化，这两个之间通过 InputStreamReader,OutputStreamWriter 来关联，实际上是通过 byte [] 和 String 来关联。在从字节流转化为字符流时，实际上就是 byte [] 转化为 String 时，而在字符流转化为字节流时，实际上是 String 转化为 byte [] 时。\n字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。所以字符流是由 Java 虚拟机将字节转化为 2 个字节的 Unicode 字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。\n字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理 Unicode 字符，而字符流就可以。\n字节流与字符流主要的区别是他们的的处理方式。\n解决乱码问题\n File f &#x3D; new File(&quot;a.txt&quot;);\nFileOutputStream fop &#x3D; new FileOutputStream(f);\n&#x2F;&#x2F; 构建 FileOutputStream 对象，文件不存在会自动新建\n \nOutputStreamWriter writer &#x3D; new OutputStreamWriter(fop, &quot;UTF-8&quot;);\n&#x2F;&#x2F; 构建 OutputStreamWriter 对象，参数可以指定编码，默认为操作系统默认编码，windows 上是 gbk\n\n writer.append(&quot; 中文输入 &quot;);\n        &#x2F;&#x2F; 写入到缓冲区\n         writer.append(&quot;\\r\\n&quot;);\n        &#x2F;&#x2F; 换行\n         writer.append(&quot;English&quot;);\n        &#x2F;&#x2F; 刷新缓存冲，写入到文件，如果下面已经没有写入的内容了，直接 close 也会写入\n         writer.close();\n        &#x2F;&#x2F; 关闭写入流，同时会把缓冲区内容写入文件，所以上面的注释掉\n         fop.close();\n        &#x2F;&#x2F; 关闭输出流，释放系统资源\n         FileInputStream fip &#x3D; new FileInputStream(f);\n        &#x2F;&#x2F; 构建 FileInputStream 对象\n         InputStreamReader reader &#x3D; new InputStreamReader(fip, &quot;UTF-8&quot;);\n        &#x2F;&#x2F; 构建 InputStreamReader 对象，编码与写入相同\n         StringBuffer sb &#x3D; new StringBuffer();\n        while (reader.ready()) &#123;\n            sb.append((char) reader.read());\n            &#x2F;&#x2F; 转成 char 加到 StringBuffer 对象中\n        &#125;\n        System.out.println(sb.toString());\n        reader.close();\n        &#x2F;&#x2F; 关闭读取流\n         fip.close();\n        &#x2F;&#x2F; 关闭输入流，释放系统资源\n    &#125;\n&#125;\n\n递归删除\npublic class DeleteFileDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 这里修改为自己的测试目录\n         File folder &#x3D; new File(&quot;&#x2F;tmp&#x2F;java&#x2F;&quot;);\n        deleteFolder(folder);\n    &#125;\n \n    &#x2F;&#x2F; 删除文件及目录\n     public static void deleteFolder(File folder) &#123;\n        File[] files &#x3D; folder.listFiles();\n        if (files !&#x3D; null) &#123;\n            for (File f : files) &#123;\n                if (f.isDirectory()) &#123;\n                    deleteFolder(f);\n                &#125; else &#123;\n                    f.delete();\n                &#125;\n            &#125;\n        &#125;\n        folder.delete();\n    &#125;\n&#125;\n\n\n\n事务的四种特性：原子性、一致性、隔离性、持久性\nlinux常用命令：cd chgrp cat \nredis五种数据结构：string hash set zset list\ngit常用命令：\n新增文件的命令：git add file 或者 git add .提交文件的命令：git commit –m 或者 git commit –a查看工作区状况：git status –s拉取合并远程分支的操作：git fetch/git merge 或者 git pull查看提交记录命令：git reflog\nGit 代码合并有两种：Git Merge 和 Git ReBase\n","slug":"面试题","date":"2022-01-01T15:32:53.000Z","categories_index":"面试题","tags_index":"面试","author_index":"icarus"},{"id":"dae83d1c88f5937753ca40f0c60cab64","title":"RequestMapping注解","content":"@RequestMapping注解一个用来处理请求地址映射的注解，可用于类或方法上。\n用于类上，表示类中的所有请求的方法都是以该地址作为父路径@RestController\n@RequestMapping(&quot;&#x2F;test&quot;)\npublic class TestController &#123;\n    @Autowired\n    private MerchantConfigRepository merchantConfigService;\n    @Autowired\n    DealerService dealerService;\n\n用在类开头，为整个类规定它的父路径在方法前使用@RequestMapping ，相当于规定该调用方法的路径\n@RequestMapping(value &#x3D; &quot;&#x2F;addDealer&quot;,method &#x3D; RequestMethod.POST)\n    public String addDealer(@Valid @RequestBody DealerModel dealerModel, BindingResult bindingResult) &#123;\n        return dealerService.addDealer(dealerModel);\n    &#125;\n\n","slug":"@RequestMapping注解","date":"2021-11-07T14:32:21.000Z","categories_index":"java","tags_index":"spring","author_index":"icarus"},{"id":"20496ea705d490e685d32b89838c0b41","title":"MVVM模式","content":"MVVM 模式理解（转）　　MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对 View 和 ViewModel 的双向数据绑定，这使得 ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。\n　　Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于 View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel 负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。\n　　为什么会出现 MVVM 呢？\n　　MVC 即 Model-View-Controller 的缩写，就是 模型 — 视图 — 控制器，也就是说一个标准的 Web 应用程式是由这三部分组成的：\n　　View ：用来把数据以某种方式呈现给用户\n　　Model ：其实就是数据\n　　Controller ：接收并处理来自用户的请求，并将 Model 返回给用户\n　　在 HTML5 还未火起来的那些年，MVC 作为 Web 应用的最佳实践是 OK 的，这是因为 Web 应用的 View 层相对来说比较简单，前端所需要的数据在后端基本上都可以处理好，View 层主要是做一下展示，那时候提倡的是 Controller 来处理复杂的业务逻辑，所以 View 层相对来说比较轻量，就是所谓的瘦客户端思想。\n　　为什么前端要工程化，要是使用 MVC？ \n　　相对 HTML4，HTML5 最大的亮点是它为移动设备提供了一些非常有用的功能，使得 HTML5 具备了开发 App 的能力， HTML5 开发 App 最大的好处就是跨平台、快速迭代和上线，节省人力成本和提高效率，因此很多企业开始对传统的 App 进行改造，逐渐用 H5 代替 Native，到 2015 年的时候，市面上大多数 App 或多或少嵌入都了 H5 的页面。既然要用 H5 来构建 App， 那 View 层所做的事，就不仅仅是简单的数据展示了，它不仅要管理复杂的数据状态，还要处理移动设备上各种操作行为等等。因此，前端也需要工程化，也需要一个类似于 MVC 的框架来管理这些复杂的逻辑，使开发更加高效。 但这里的 MVC 又稍微发了点变化：\n　　View ：UI 布局，展示数据\n　　Model ：管理数据\n　　Controller ：响应用户操作，并将 Model 更新到 View 上\n　　这种 MVC 架构模式对于简单的应用来看是 OK 的，也符合软件架构的分层思想。 但实际上，随着 H5 的不断发展，人们更希望使用 H5 开发的应用能和 Native 媲美，或者接近于原生 App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\n　　1、 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。\n　　2、大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n　　3、 当 Model 频繁发生变化，开发者需要主动更新到 View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到 Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。\n　　其实，早期 jquery 的出现就是为了前端能更简洁的操作 DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。\n　　MVVM 的出现，完美解决了以上三个问题。\n　　MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n　　在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n　　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n　　Vue.js 的细节\n　　Vue.js 可以说是 MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的 JS 库，API 简洁，很容易上手。Vue 的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：\n　　Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。\n****\n　　Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用 Object.defineProperty 的 getter 和 setter 来实现\n　　Compile ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n　　Watcher ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数\n　　Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发 notify 函数，再调用订阅者的 update 方法\n　　从图中可以看出，当执行 new Vue () 时，Vue 就进入了初始化阶段，一方面 Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器 Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时 Wather 会将自己添加到消息订阅器中 (Dep)，初始化完毕。\n　　当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用 Dep.notify ()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。\n","slug":"MVVM 模式理解","date":"2021-10-07T14:32:21.000Z","categories_index":"前端","tags_index":"vue","author_index":"icarus"},{"id":"3a37cd072b4ce26a3caecc3401259a9a","title":"Spring基础","content":"Spring\n\n导入Spring开发的基本包坐标\n\n编写Dao接口和实现类\n\n创建Spring核心配置文件\n\n在Spring配置文件中配置UserDaoImpl\n\n使用Spring的API获得Bean实例\n\n\n\n\nSpring的重点配置\n\nSpring原始注解\n\n\nspring集成web环境步骤\n\n\n\n\n视图解析器\n\n\n\n在@RequestMapping下加@ResponseBody 告知框架不进行视图跳转（跳转静态资源），而是直接进行数据响应返回的是字符串\n\nnew BeanPropertyRowMapper         \n\n&#x2F;&#x2F; javabean 需要满足标准  必须有空参数构造  数据库字段必须和属性名一致(数据封装失败)\n\n\n\n缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；\n\n排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；\n\n计算器&#x2F;限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；\n\n好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；\n\n简单消息队列，除了Redis自身的发布&#x2F;订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；\n\nSession共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。\n\n一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问\n\n简述 Redis 的数据\n\n如果有多个intercecptor配置，按照编写的顺序，如：\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n        &lt;bean class&#x3D;&quot;com.icarust.interceptor.MyInterceptor1&quot;&#x2F;&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n        &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n        &lt;bean class&#x3D;&quot;com.icarust.interceptor.MyInterceptor2&quot;&#x2F;&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n\n前置1执行\n前置2执行\n目标资源执行\npostHandle2执行\npostHandle1执行\nafterCompletion2执行\nafterCompletion1执行\n（有种后进先出的意味）\n\n\n\n前端控制器DispatcherServlet的核心配置文件：使用 springMVC 必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n处理器映射器：RequestMappingHandleMapping\n处理器适配器：RequestMappingHandleAdapter\n视图解析器：InternalResourceViewResolver\n通常，我们只需要手动配置视图解析器，而**处理器映射器*和处理器适配器*只需要开启**注解驱动****即可，而省去了大段的 xml 配置。这就是配置spring-mvc第一步注解驱动的作用。\nspring环境搭建步骤:\n\n搭建spring项目：web.xml：\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n\n\n\n&lt;listener&gt;\n   &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;\n\n\n\n &lt;servlet&gt;\n     &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;\n     &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n     &lt;init-param&gt;\n         &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n         &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;\n     &lt;&#x2F;init-param&gt;\n     &lt;load-on-startup&gt;2&lt;&#x2F;load-on-startup&gt;&#x2F;&#x2F;在服务器启动时加载 1或2都行\n &lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n     &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;\n     &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n &lt;&#x2F;servlet-mapping&gt;\n\nspring-mvc.xml\n\n&lt;mvc:annotation-driven&#x2F;&gt;\n\n\n\n&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;pages&#x2F;&quot;&#x2F;&gt;  &#x2F;&#x2F;前缀，value是位置\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;     &#x2F;&#x2F;后缀，value是文件的后缀\n&lt;&#x2F;bean&gt;\n\n\n\n&lt;mvc:default-servlet-handler&#x2F;&gt;\n\napplicationContext.xml\n\n&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;\n\n\n\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n&lt;!--配置RoleDao--&gt;\n&lt;bean id&#x3D;&quot;roleDao&quot; class&#x3D;&quot;com.itheima.dao.impl.RoleDaoImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;jdbcTemplate&quot; ref&#x3D;&quot;jdbcTemplate&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n   \n&lt;!--配置UserDao--&gt;\n&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;jdbcTemplate&quot; ref&#x3D;&quot;jdbcTemplate&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n    \n&lt;!--配置RoleService--&gt;\n&lt;bean id&#x3D;&quot;roleService&quot; class&#x3D;&quot;com.itheima.service.impl.RoleServiceImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;roleDao&quot; ref&#x3D;&quot;roleDao&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;!--配置UserService--&gt;\n&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;roleDao&quot; ref&#x3D;&quot;roleDao&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n页面form表单内的元素name必须和对象的属性名一致，springmvc才能自动封装\n提交方式post有乱码问题，需要设置编码，filter，在web.xml设置过滤器\n\n\n&lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\nspring重定向的方式：return “redirect: 地址 “;\n@PathVariable 是 spring3.0 的一个新功能：接收请求路径中占位符的值\nmybatis\n核心配置文件（sqlMapperConfig.xml）的约束\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n\n映射配置文件（xxx.xml）的约束\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\napplication context\n应用上下文 项目的访问路径 虚拟目录\nindex.jsp 访问时可以不写\ntomcat启动后在浏览器不仅可以访问网页还可以访问目录下的资源（image等）\n\n\n\n\nmybatis分页插件依赖（用以下版本，其他版本可能会报错）\n&lt;dependency&gt;\n    &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.7.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.github.jsqlparser&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jsqlparser&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\ntypeHandler 类型处理器 \n\n&lt;mapper namespace&#x3D;&quot;com.icarus.dao.FavoriteMapper&quot;&gt;\n    &lt;resultMap id&#x3D;&quot;favoriteMap&quot; type&#x3D;&quot;favorite&quot;&gt;\n&lt;!--        手动指定字段和实体属性映射关系--&gt;\n&lt;!--        column：数据表的字段名称--&gt;\n&lt;!--        property：实体属性名称--&gt;\n        &lt;id  column&#x3D;&quot;rid&quot; property&#x3D;&quot;rid&quot;&gt;&lt;&#x2F;id&gt;\n        &lt;result column&#x3D;&quot;DATE&quot; property&#x3D;&quot;date&quot;&gt;&lt;&#x2F;result&gt;\n&lt;!--        &lt;result column&#x3D;&quot;uid&quot; property&#x3D;&quot;uid&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n\n&lt;!--        &lt;result column&#x3D;&quot;username&quot;  property&#x3D;&quot;user.username&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;password&quot; property&#x3D;&quot;user.password&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;name&quot; property&#x3D;&quot;user.name&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;birthday&quot; property&#x3D;&quot;user.birthday&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;user.sex&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;telephone&quot; property&#x3D;&quot;user.telephone&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;email&quot; property&#x3D;&quot;user.email&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n\n&lt;!--        property:当前实体order中的属性名称--&gt;\n&lt;!--        javatype：当前实体中的属性名称--&gt;\n        &lt;association property&#x3D;&quot;user&quot; javaType&#x3D;&quot;user&quot;&gt;\n            &lt;id column&#x3D;&quot;username&quot; property&#x3D;&quot;username&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;password&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;birthday&quot; property&#x3D;&quot;birthday&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;sex&quot; property&#x3D;&quot;sex&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;telephone&quot; property&#x3D;&quot;telephone&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;email&quot; property&#x3D;&quot;email&quot;&#x2F;&gt;\n        &lt;&#x2F;association&gt;\n    &lt;&#x2F;resultMap&gt;\n    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;favoriteMap&quot;&gt;\n        SELECT o.rid,o.DATE,u.username,u.&#96;PASSWORD&#96;,u.&#96;NAME&#96;,u.birthday,u.sex,u.telephone,u.email FROM tab_favorite o, tab_user u where o.uid&#x3D;u.uid\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n&lt;!--    通过properties标签加载外部properties文件--&gt;\n    &lt;properties resource&#x3D;&quot;jdbc.properties&quot;&gt;&lt;&#x2F;properties&gt;\n    &lt;!--    自定义别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.Domain&quot; alias&#x3D;&quot;Domain&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.domain.Favorite&quot; alias&#x3D;&quot;favorite&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.domain.User&quot; alias&#x3D;&quot;user&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.dao.FavoriteMapper&quot; alias&#x3D;&quot;favoriteMapper&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.dao.UserMapper&quot; alias&#x3D;&quot;userMapper&quot;&#x2F;&gt;\n\n    &lt;&#x2F;typeAliases&gt;\n&lt;!--    注册数据类型转换器--&gt;\n&lt;!--    &lt;typeHandlers&gt;--&gt;\n&lt;!--        &lt;typeHandler handler&#x3D;&quot;com.icarus.utils.DateTypeHandler&quot;&gt;&lt;&#x2F;typeHandler&gt;--&gt;\n&lt;!--    &lt;&#x2F;typeHandlers&gt;--&gt;\n&lt;!--    数据源环境--&gt;\n    &lt;plugins&gt;\n        &lt;plugin interceptor&#x3D;&quot;com.github.pagehelper.PageHelper&quot;&gt;\n            &lt;property name&#x3D;&quot;dialect&quot; value&#x3D;&quot;mysql&quot;&#x2F;&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n&lt;!--    加载映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource&#x3D;&quot;com&#x2F;icarus.mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;\n        &lt;mapper resource&#x3D;&quot;com&#x2F;icarus.mapper&#x2F;FavariteMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt; \n\n\n&lt;&#x2F;configuration&gt;\n\n配置文件中 xmlns：context 是注解约束，使用注解开发配置文件要加入该约束。\n使用事务注解时如果代码内有trycatch会使事务失效\nMapper代理开发：\n1.接口所在位置必须和映射文件位置一致（如果xml文件放在resource，必须在resource创建跟接口一样的全限定名文件夹）\n2.接口名称必须和映射文件名称一致\n3.接口的全限定名必须和namespace 一致\n接口中的方法名 需要和对应的标签一致 id 一样\n多个实现类如何注入？\n如果一个接口有两个实现类 ，在autowied注入时，在@Autowied下面加个@Qualifier （”要使用的实现类”）\n@Repository（value&#x3D;“daoRedis”）\npublic class IUserDaoImpl2 implements IUserDao&#123;\n代码~\n&#125;\n\n\n\n@Autowired\n\n@Qualifier（value&#x3D;“daoRedis”）\n\nprivate IUserDao userDao；\n\n也可以用jdk自带的注解@Resource 替代@Qualifier，使用方法：@Resource (name=“daoMyBatis” )\n如果jdk版本过高（14 15） @Resource 可能有版本冲突问题 \n要把除了三层架构外的类放到spring容器中，使用@Component注解\n@Component(“pb”)  //给这个bean设置一个key名字，spring容器都是map key-value\npublic class Product( ){\n}\n点进注解，如果里面有value属性，value就可以省略，如 @Component(value=”pb”)——&gt; @Component(“pb”) \n@Value 注解内部：\npublic @interface Value&#123;\n\n​\t\tString value()；\n\n&#125;\n\n纯注解开发：\n&#x2F;&#x2F;配置类 代替配置文件 beans 后面的约束\n@Configuration\n@ComponentScan(value &#x3D; &quot;com.icis&quot;)&#x2F;&#x2F;代替包扫描\n@Import(value &#x3D; &#123;SpringJdbcConfiguration.class,\n        SpringMapperConfigurarion.class&#125;)\npublic class SpringConfiguration &#123;\n\n@Bean 把方法的返回值放到spring容器中\n该注解只能写在方法上，表明使用此方法创建一个对象，并且交给spring管理\n举例:  将jdbcTemplate放到容器中\n@Bean\npublic JdbcTemplate getJdbcTemplate(){\nJdbcTemplate jdbcTemplate = new JdbcTemplate();\nreturn jdbcTemplate;\n}\n如果有多个数据源，在配置类参数使用@Qualifier(“ “)来指定\n&#x2F;&#x2F;配置类 代替配置文件 beans 后面的约束\n@Configuration\n@ComponentScan(value &#x3D; &quot;com.icis&quot;)\n@Import(value &#x3D; &#123;SpringJdbcConfiguration.class,\n        SpringMapperConfigurarion.class&#125;)\npublic class SpringConfiguration &#123;\n    &#x2F;&#x2F; 创建一个jdbdTemplate 放入到spring 容器\n    @Bean(name &#x3D; &quot;temp1&quot;)\n    public JdbcTemplate getTemplate(@Qualifier(&quot;druidDs1&quot;) DataSource ds)&#123;&#x2F;&#x2F; 方法形参  会去容器中找\n        JdbcTemplate jdbcTemplate&#x3D;new JdbcTemplate(ds);\n        return  jdbcTemplate;\n    &#125;\n\n&#125;\n    &#x2F;&#x2F; 定义方法 创建数据源\n    @Bean(name &#x3D; &quot;druidDs1&quot;)\n    public DataSource getDruidDs2()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\t\n    @Bean(name &#x3D; &quot;druidDs2&quot;)\n    public DataSource getDruidDs1()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\n\n&#x2F;&#x2F; 如果需要加载类路径下文件 需要在文件名前加  classpath:\n@PropertySource(value &#x3D; &quot;classpath:db.properties&quot;)\npublic class SpringJdbcConfiguration &#123;\n    &#x2F;&#x2F; 配置数据库相关操作\n    &#x2F;&#x2F; 注入配置文件中数据 需要使用springEl $&#123;key&#125;\n    @Value(&quot;$&#123;db.driverClassName&#125;&quot;)\n    private String driverClassName;\n    @Value(&quot;$&#123;db.url&#125;&quot;)\n    private String url;\n    @Value(&quot;$&#123;db.username&#125;&quot;)\n    private String username;\n    @Value(&quot;$&#123;db.password&#125;&quot;)\n    private String password;\n\nxml配置mysql\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd\n&quot;&gt;\n    &lt;!--包扫描--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.icis&quot;&#x2F;&gt;\n    &lt;!--加载属性文件--&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:db.properties&quot;&#x2F;&gt;\n &lt;!--配置两个bean DataSource JdbcTemplate--&gt;\n    &lt;bean id&#x3D;&quot;druidDs&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;db.driverClassName&#125;&quot;&#x2F;&gt;\n        &lt;!--@Value(&quot;$&#123;&#125;&quot;)--&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;db.url&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;db.username&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;db.password&#125;&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;bean id&#x3D;&quot;temp2&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;druidDs&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n纯注解配置mysql：\n\n&#x2F;&#x2F;主配置类 代替配置文件 beans 后面的约束\n@Configuration\n@ComponentScan(value &#x3D; &quot;com.icis&quot;)\n@Import(value &#x3D; &#123;SpringJdbcConfiguration.class,\n        SpringMapperConfigurarion.class&#125;)\npublic class SpringConfiguration &#123;\n    &#x2F;&#x2F; 创建一个jdbdTemplate 放入到spring 容器\n    @Bean(name &#x3D; &quot;temp1&quot;)\n    public JdbcTemplate getTemplate(@Qualifier(&quot;druidDs1&quot;) DataSource ds)&#123;&#x2F;&#x2F; 方法形参  会去容器中找\n        JdbcTemplate jdbcTemplate&#x3D;new JdbcTemplate(ds);\n        return  jdbcTemplate;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;副配置类\n&#x2F;&#x2F; 如果需要加载类路径下文件 需要在文件名前加  classpath:\n@PropertySource(value &#x3D; &quot;classpath:db.properties&quot;)\npublic class SpringJdbcConfiguration &#123;\n    &#x2F;&#x2F; 配置数据库相关操作\n    &#x2F;&#x2F; 注入配置文件中数据 需要使用springEl $&#123;key&#125;\n    @Value(&quot;$&#123;db.driverClassName&#125;&quot;)\n    private String driverClassName;\n    @Value(&quot;$&#123;db.url&#125;&quot;)\n    private String url;\n    @Value(&quot;$&#123;db.username&#125;&quot;)\n    private String username;\n    @Value(&quot;$&#123;db.password&#125;&quot;)\n    private String password;\n\n\n\n    &#x2F;&#x2F; 定义方法 创建数据源\n    @Bean(name &#x3D; &quot;druidDs1&quot;)\n    public DataSource getDruidDs2()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\n\n    @Bean(name &#x3D; &quot;druidDs2&quot;)\n    public DataSource getDruidDs1()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\n&#125;\n&#x2F;&#x2F;副配置类\n&#x2F;&#x2F; 映射器  bean-json 配置类\npublic class SpringMapperConfigurarion &#123;\n\n    @Bean\n    public ObjectMapper objectMapper()&#123;\n        return  new ObjectMapper();\n    &#125;\n&#125;\n\n\n将ObjectMapper注册（放）到spring，\n注解方式:\n&#x2F;&#x2F; 映射器  bean-json 配置类\npublic class SpringMapperConfigurarion &#123;\n\n    @Bean\n    public ObjectMapper objectMapper()&#123;\n        return  new ObjectMapper();\n    &#125;\n&#125;\n\nspring整合junit 为什么要整合？\n因为spring和junit是两个环境或者说是两个容器，一个容器去另一个容器取东西必须做整合\n所以maven要引入 spring-test这个包\nspring整合junit 整合步骤：\n\nmaven引入spring-test这个包\n\n在测试类上添加两个注解\n\n```java@RunWith(SpringJUnit4ClassRunner.class)//spring-test带的@ContextConfiguration(classes = SpringConfiguration.class)//主配置类public class EmployeeTest1 {\n@Autowired\nprivate EmployeeController employeeController;\n@Test\npublic void getEmpListTest1()&#123;\n    String empJson = this.employeeController.getEmpJson();\n    System.out.println(&quot;获得数据是：&quot;+empJson);\n&#125;\n\n}\n\n转换json的两个实体注解：\n\n&#96;&#96;&#96;java\n&#x2F;&#x2F;  @JsonIgnore 忽略该字段转换json\n  private Double salary;\n  &#x2F;&#x2F; 默认  显示的毫秒值\n  @JsonFormat(pattern &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;,timezone &#x3D; &quot;GMT+8&quot;)\n  private Date joinDate;\n\nObjectMapper   xml的配置方法：\n\n&#x2F;&#x2F;执行分页操作\nPage&lt;s&gt; pageBean &#x3D; PageHelper.startPage(currentPage, pageSize);","slug":"Spring","date":"2021-10-07T14:32:21.000Z","categories_index":"java","tags_index":"Spring","author_index":"icarus"},{"id":"cf3ece25eb219b32904f64404ccf8150","title":"Jquery和原生js的区别","content":"Jquery 和 原生js（1）选中dom对象\ndocument.getElementsByClassName(“one”)[0] =$(“.one”)\ndocument.getElementsByTagName(“div”)[0] =$(“.div”)\ndocument.getElementId(“two”) =$(“#two”)\n（2）初始化方式（入口函数）\nwindow.onload = function(ev){ } = \n​        $(document).ready(function( ) { undefined } );\n​        $(function( ) { undefined } );\n（3）DOM 对象转 jQuery 对象\nvar dom = document.getElementById(“IMOK”);\nvar $dom = $(dom)\n","slug":"Jquery 和 原生js","date":"2021-09-07T14:32:21.000Z","categories_index":"javascript","tags_index":"JavaScript","author_index":"icarus"},{"id":"bb75e9d1c3429d83254e84314ef5ffe1","title":"java基础","content":"继承方法的覆盖重写1.必须保证父子类之间方法的名称相同，参数列表也相同；\n@Override，写在方法签名，用来检测是不是有效的正确覆盖重写。\n写不写都行，写了可以验证一下方法名是否与父类方法对应。\n2.子类方法的返回值必须小于等于父类方法的返回值范围\npublic class Zi extends Fu&#123;\n    @Override\n    public String method()&#123;\n        return null;\n    &#125;\n&#125;\n\npublic class Fu &#123;\n    public Object method()&#123;\n        return null;\n    &#125;\n&#125;\n\n返回值范围：Object&gt;String\n注：所有的引用类型（Object、String等）都可以用null作返回值。\n3.子类方法的权限必须大于等于父类方法的权限修饰符。\npublic &gt; protected &gt; (default) &gt; private\n（default ）不是关键字default，而是不写修饰符，留空。\n4.子类必须调用父类构造方法\n5.super的子类调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。\n6.子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定super调用，super只能有一个，还必须是第一个。\n7.this(…)调用也必须是构造方法的第一个语句，唯一一个。\nsuper和this两种构造调用，不能同时使用。\n继承的三个特点java语言是单继承的，一个类的直接父类只能有唯一一个\njava语言可以多级继承，一个父类可以拥有很多个子类\nclass A&#123;&#125;\nclass B extends A&#123;&#125;&#x2F;&#x2F;正确\nclass C extends B&#123;&#125;&#x2F;&#x2F;正确\n\n抽象方法如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法\n抽象方法：加上abstract 关键字，然后去掉大括号，直接分号结束。\n抽象类：抽象方法所在的类，必须是抽象类，在class前加上abstract。\n如何使用抽象类和抽象方法：\n1.必须用一个子类来继承抽象父类\n2.子类必须覆盖重写抽象父类当中的所有抽象方法。子类去掉抽象方法的abstract关键字，然后补上方法体大括号。\n面试题：\n抽象类可以被实例化吗？\n抽象类其实是可以被实例化的，但是它的实例化方式并不是通过普通的 new 方式来创建对象，而是通过父类的应用来指向子类的实例间接地实现父类的实例化，因为子类在实例化之前，一定会先实例化它的父类。 … 注意：接口与抽象类非常类似，但是它不可以被实例化，因为接口压根没有构造函数\n注意事项1.不能直接创建抽象类对象，之恶能创建非抽象子类的对象\nps：加入创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\n2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\n3.抽象类不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n4.抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类。\n接口接口就是一种公共的规范标准。\n接口是一种引用数据类型，最重要的内容是其中的抽象方法\n接口中可以包含的内容有：\n\n常量 （java7）\n\n抽象方法（java7）\n\n默认方法（java8）\n\n静态方法（java8）\n\n私有方法（java9）\n1.普通私有方法，解决多个默认方法之间重复代码问题\n格式：private 返回值类型 方法名称（参数列表）{方法体}\n2.静态私有方法：解决多个静态方法之间重复代码问题\n格式：private static 返回值类型 方法名称（参数列表）{方法体}\n\n\n接口当中的抽象方法，修饰符必须是两个固定的关键字：\npublic abstract，所以写不写修饰符都一样\n接口的使用步骤：\n\n接口必须有一个实现类来实现该接口\n\n接口的实现类必须覆盖重写接口中的所有抽象方法\n去掉方法的abstract关键字，然后补上方法体大括号。\n\n创建实现类的对象进行使用。\n不能通过接口实现类的对象来调用接口当中的静态方法，可以通过接口名称直接调用其中的静态方法。\n多接口的注意事项\n一个类的直接父类是唯一的，但一个类可以实现多个接口\n如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。\n如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。\n如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。\n一个类如果实现父类当中的方法，和接口当中的默认方法产生了冲突，则优先用父类当中的方法。\n接口是没有静态代码块或者构造方法的。\n多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，而且带着default关键字。\n\n\n\n多态父类引用指向子类对象。\n格式：父类名称 对象名 = new 子类名称（）；\n或者 接口名称 对象名 = new 实现类名称（）；\n访问成员变量的两种方式：\n\n直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找\n\npublic class Fu &#123;\n    int num &#x3D; 10;\n&#125;\npublic class Zi extends Fu&#123;\n    int num &#x3D; 20;\n&#125;\nFu obj &#x3D; new Zi(); &#x2F;&#x2F;输出10\n\n\n间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找\n\n在多态的代码中，成员方法的访问规则是：\n看new的是谁，就优先用谁，没有则向上找\n口诀：编译看左边，运行看右边\n成员变量：编译看左边，运行还看左边\n成员方法：编译看左边，运行看右边\n向上转型对象的向上转型，就是多态的写法：父类引用指向子类对象。\n向上转型一定是安全的。\n向下转型其实是一个还原动作\n格式：子类名称 对象名 = （子类名称）父类对象；\n即将父类对象还原为本来的子类对象。\n向下转型要先进行判断，使用instanceof 关键字进行类型判断  返回boolean\nfinal当final关键字用来修饰一个方法的时候，该方法不能被覆盖重写。\n对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。\n内部类类似于身体于心脏的关系\n格式： \n修饰符 class 外部类名称{\n​    修饰符 class 内部类名称{\n​         }\n}\n内用外，随意访问；外用内，需要内部类对象。\n使用成员内部类的方法：\n\n间接方式，在外部类的方法当中，使用内部类，main只是调用外部类的方法。\n直接方式，公式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称\n\n在内部类方法访问外部类的成员变量\npublic class Body &#123;\n    public class Heart&#123;\n        int num &#x3D; 20;&#x2F;&#x2F;内部类的成员变量\n        public void methodHeart()&#123;\n            int num &#x3D; 40;\n            System.out.println(Body.this.num); &#x2F;&#x2F;在内部类访问外部类的成员变量\n            System.out.println(name+&quot;内部类的方法&quot;);\n        &#125;\n\n\n    &#125;\n    private String name;\n    int num &#x3D; 10;&#x2F;&#x2F;外部类的成员变量\n    public  void methodBody()&#123;\n        int num &#x3D; 30;&#x2F;&#x2F;外部类的方法的局部变量\n        Heart heart &#x3D; new Heart();\n        System.out.println(&quot;外部类的方法&quot;);\n        heart.methodHeart();\n\n    &#125;\n&#125;\n\n\n\n在外部类方法里定义的类叫做局部内部类\n定义一个类的时候，权限修饰符规则：\n\n外部类：public / （default）\n\n成员内部类：public / protected / (default) / private\n\n局部内部类，什么都不能写。\n匿名内部类如果接口的实现类或者是父类的子类只需要使用一次，这种情况可以省略掉该类的定义，而改为使用匿名内部类。\n\n\nObject看一个类是否重写了toString方法，直接打印这个类对应对象名字即可\n如果没有重写toString方法，那么打印的就是对象的地址值（默认）\n如果重写toString方法，那么就按照重写的方式打印。\nequals方法，默认比较两个对象的地址值。\n\nObject类介绍：是所有类的父类，一个类都会直接或者间接地继承自该类，该类中提供了一些非常常用的方法\n\ntoString()方法\n作用：打印对象信息\n重写前：打印的是包名类名@地址值\n重写后：打印的是对象中的属性值\n\nequals()方法\n作用：比较两个对象\n重写前：比较的是对象的地址值\n重写后：比较的是对象中的属性值\n\n\nObjectsequals()方法：\n比较两个对象是否相同，但是增加了一些健壮性的判断！\nObject.equals（a,b）\nDate类long getTime()\n返回自1970年1月1日 00:00:00 GMT以来此Date对象表示的毫秒数\nDate类的带参构造方法：\n​    Date(long date) ：传递毫秒值，把毫秒转换为Date日期\nDate类的空参构造方法：\n​    Date()获取的是当前系统的日期和时间\nStringBuilder成员方法：\npublic StringBuilder append（…）：添加任意类型的字符串形式，并返回当前对象自身。\n参数：可以是任意数据类型。\n装箱和拆箱拆箱：在包装类中取出基本数据类型的数据（包装类-&gt;基本类型的数据）\n成员方法：int intValue() 以int 类型返回该Integer的值\n装箱：把基本类型的数据，包装到包装类中（基本类型的数据-&gt;包装类）\n如果方法上有横线，说明方法过时了\n静态方法：\nstatic Integer valueOf(int i) 返回一个表示指定的int值的Integer实例\nstatic Integer valueOf（String s）返回保存指定的String的值的Integer对象。\n集合框架学习目标：\n\n会使用集合存储数据\n会遍历集合，把数据取出来\n掌握每种集合的特性\n\n学习方式：\n\n学习顶层：学习顶层接口/抽象类中共性的方法，所有的子类都可以使用\n使用底层：底层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用\n\nCollection 接口：\n定义的是所有单列集合中共性的方法\n所有的单列集合都可以使用共性的方法\n没有带索引的方法\nList接口：\n\n有序的集合（存储和取出元素顺序相同）\n允许存储重复的元素\n有索引，可以使用普通的for循环遍历\n\nSet接口：\n\n不允许存储重复元素\n\n没有索引（不能使用普通的for循环遍历）\nTreeSet集合和HashSet集合：\n无序的集合（存储和取出元素的顺序有可能不一致）\n\n\nLinkedHashSet集合：有序的集合\n\n共性的方法：\npublic boolean add(E e)：把给定的对象添加到当前集合中\npublic void clear()：清空集合中所有的元素\npublic boolean remove(E e)：把给定的对象在当前集合中删除\npublic boolean contains(E e)：判断当前集合中是否包含给定的对象\npublic boolean isEmpty()：判断当前集合是否为空\npublic int size()：返回集合中元素的个数\npublic Object[] toArray() 把集合中的元素存储到数组中\n迭代器：通用的取出集合的方法。主要针对没有索引的集合。\n方法：\n使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）\n注意：Iterator接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型。\nhasNext() 如果仍有元素可以迭代，则返回true\nnext() 返回迭代的下一个元素，一旦执行就会取出一个元素\nremove() 从迭代器指向的collection中移除迭代器返回的最后一个元素\nforeach增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，是JDK1.5之后出现的新特性，用来遍历集合或数组\nCollection extends Iterable ：所有的单列集合都可以使用增强for\npublic interface Iterable 实现这个接口允许对象成为”foreach”语句的目标\n格式：\nfor(集合/数组的数据类型 变量名 ： 集合名/数组名){\nsout(变量名);\n}\npublic class Demo02Foreach{\n}\n泛型创建集合对象，使用泛型的好处：\n\n避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型\n\n把运行期异常（代码运行后会抛出的异常），提升到了编译器（写代码的时候会报错）\n不确定用什么数据类型的时候，可以使用泛型  E\n\n\n定义含有泛型的方法：泛型定义在方法的修饰符和返回值类型之间\n格式：\n​    修饰符&lt;泛型&gt;返回值类型  方法名 ( 参数列表(使用泛型) ){\n​    方法体；\n}\n含有泛型的方法，在调用方法的时候确定泛型的数据类型\n传递什么类型的参数，泛型就是什么类型\n泛型的通配符？：代表任意的数据类型\n使用方式：\n​        不能创建对象使用\n​        只能作为方法的参数使用\nListArrayList查询快增删慢\nLinkedListLinkedList 集合的特点：\n\n底层是一个链表结构：查询慢，增删快\n\n里边包含了大量操作首尾元素的方法\n注意：使用LinkedList集合特有的方法，不能使用多态\n\n\npublic void addFirst(E e) ：将指定元素插入到列表的开头\npublic void addList(E e)：将指定元素添加到此列表的结尾\npublic void push(E e)：将元素插入此列表所表示的堆栈\npublic E getFirst()：返回此列表的第一个元素\npublic E getLast()：返回此列表的最后一个元素\npublic E removeFirst()：移除并返回此列表的第一个元素\npublic E removeLast()：移除并返回此列表的最后一个元素\npublic E pop()：从此列表所表示的堆栈处弹出一个元素\nHashSet特点：\n\n不允许存储重复的元素\n\n没有索引，没有带索引的方法，也不能使用普通的for循环遍历\n\n是一个无序的集合，存储元素和取出元素的顺序有可能不一致\n\n底层是一个哈希表结构（查询的速度非常的快）\nHashSet是implement Set接口，Set接口只有以上1、2特点。\n\n\n存储数据的结构（哈希表）\njdk 1.8 版本之前： 哈希表=数组+链表\njdb 1.8版本之后 ：\n​                                哈希表=数组+链表；\n​                                哈希表=数组+红黑树（提高查询的速度）\n哈希表的特点：速度快\nSet集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否被重复\n可变参数是jdk 1.5之后出现的新特性\n使用前提：\n​        当方法的参数列表数据类型已经确定，但参数的个数不确定，就可以使用可变参数\n使用格式：方法定义时使用\n​    修饰符 返回值类型 方法名 （ 数据类型…变量名）{}\n可变参数的原理：\n​        可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数可以是0或多个。\n一个方法的参数列表，只能有一个可变参数。\n如果方法的参数有多个，可变参数必须写在末尾。\npublic static void method(String a,double b,int...c)\n\npublic class Demo4VarArgs &#123;\n    public static void main(String[] args) &#123;\n        int i &#x3D; add(55,44,55,66,55,7);\n        System.out.println(i);\n    &#125;\n    public static int add(int... arr) &#123; &#x2F;&#x2F;[I@1b6d3586底层是数组\n\n        int sum &#x3D; 0;\n        for (int i : arr) &#123;\n            sum +&#x3D; i;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n\n对象排序java.utils.Collections 是集合工具类，用来对集合进行操作，部分方法如下：\npublic static  void sort(List list)：将集合中元素按照默认规则排序\n注意：sort(List list)使用前提\n被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法comparaTo定义的排序规则\nComparable 接口的排序规则：\n自己(this)-参数：升序\n实体类：   \n@Override\npublic int compareTo(Employee o) &#123;\n        return this.getSalary()-o.getSalary();\n    &#125;\n主方法：\nCollections.sort(list);\n\nMap集合特点：\n\nMap集合是一个双列集合，一个元素包含两个值（一个key，一个value）\nMap集合中的元素，key和value的数据类型可以相同，也可以不同\nMap集合中的元素，key是不允许重复的，value是可以重复的\nMap集合中的元素，key和value是一一对应的。\n\njava.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口\nHashMap集合的特点：\n\nHashMap集合底层是哈希表：查询的速度特别快\n​        jdk1.8之前：数组+单向链表\n​       jdk1.8之后：数组+单向链表/红黑树（链表的长度超过8）：提高查询的速度\n\nhashMap是一个无序的集合，存储元素和取出元素的顺序可能不一致\n\n\njava.util.LinkedHashMap&lt;k,v&gt;集合，extends HashMap&lt;k,v&gt;集合\nLinkedHashMap的特点：\n\nLinkedHashMap集合底层是哈希表+链表（保证迭代的顺序）\nLinkedHashMap集合是一个有序的集合，存储元素和取出元素的顺序有可能不一致\n\n\npublic class Demo5Map &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;盲僧&quot;,1);\n        map.put(&quot;盖伦&quot;,2);\n        map.put(&quot;亚索&quot;,3);\n        &#x2F;&#x2F;使用map集合中的方法keySet()，把map集合中所有的key取出来存到Set集合中\n        Set&lt;String&gt; set &#x3D; map.keySet();\n        Iterator&lt;String&gt; it &#x3D; set.iterator();\n        while(it.hasNext())&#123;\n            String key &#x3D; it.next();\n            &#x2F;&#x2F;通过Map集合中的方法get(key),通过key找到value\n            Integer value &#x3D; map.get(key);\n            System.out.println(key+value);\n\n        &#125;\n    &#125;\n&#125;\n\n第二种遍历方式\nmap集合中的方法：\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图\n实现步骤：\n1.使用map集合中的方法entrySet()，把Map集合中的多个Entry对象取出来，存储到一个Set集合中\n\n2.历Set集合，获取每一个Entry对象\n\n3.使用entry对象中的方法getKey()和getValue()获取键和值\n\nMap&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(&quot;盲僧&quot;,1);\n    map.put(&quot;盖伦&quot;,2);\n    map.put(&quot;亚索&quot;,3);\n    &#x2F;&#x2F;1.使用map集合中的方法entrySet()，把Map集合中的多个Entry对象取出来，存储到一个Set集合中\n    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set &#x3D; map.entrySet();\n    &#x2F;&#x2F;2.历Set集合，获取每一个Entry对象\n    &#x2F;&#x2F;使用迭代器遍历Set集合\n    Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it  &#x3D; set.iterator();\n    while(it.hasNext()) &#123;\n        Map.Entry&lt;String, Integer&gt; entry &#x3D; it.next();\n        &#x2F;&#x2F;3.使用entry对象中的方法getKey()和getValue()获取键和值\n        String key &#x3D; entry.getKey();\n        Integer value &#x3D; entry.getValue();\n        System.out.println(key + &quot;-&quot; + value);\n        System.out.println(&quot;-------------------&quot;);\n    &#125;\n\nhashTable\n\njdk9新特性：\nList接口，Set接i口，Map接口：里边增加了一个静态的方法of，可以给集合一次行添加多个元素\nstatic  List of ( E…element)\n使用前提：\n​        当集合中存储的元素的个数已经确定了，不再改变时使用。\n注意：\n\nof方法只适用于List接口，Set接i口，Map接口，不适用于接口的实现类\nof方法的返回值是一个不能改变的结合，集合不能再使用add，put方法添加元素，会抛出异常\nSet接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常。\n\nMap.get () 方法：返回指定键所映射的值\nss\nServlet\n\n\n\nrequest对象和response对象的原理：\n\nrequest和response对象是由服务器创建的，我们来使用他们\n\nrequest对象是来获取请求消息的，response对象是设置响应消息的\n\n\nrequest功能\n\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    &#x2F;&#x2F;1.获取请求方式：GET\n    String method &#x3D; request.getMethod();\n    System.out.println(method);\n    &#x2F;&#x2F;2.（*重点）获取虚拟目录：&#x2F;day14\n    String contextPath &#x3D; request.getContextPath();\n    System.out.println(contextPath);\n    &#x2F;&#x2F;3.获取Servlet路径 ：&#x2F;demo1\n    String servletPath &#x3D;request.getServletPath();\n    System.out.println(servletPath);\n    &#x2F;&#x2F;4.获取get方法请求参数：name &#x3D; zhangsan\n    String queryString &#x3D; request.getQueryString();\n    System.out.println(queryString);\n    &#x2F;&#x2F;5.(*重点)获取请求URI：&#x2F;day14&#x2F;demo1\n    String requestURI &#x3D; request.getRequestURI();\n    StringBuffer requestURL&#x3D; request.getRequestURL();\n    System.out.println(requestURI);\n    System.out.println(requestURL);\n    &#x2F;&#x2F;6.获取协议及版本：HTTP&#x2F;1.1\n    String protocol &#x3D; request.getProtocol();\n    System.out.println(protocol);\n    &#x2F;&#x2F;7.获取客户机的IP地址\n    String remoteAddr &#x3D; request.getRemoteAddr();\n    System.out.println(remoteAddr);\n&#125;\n\n获取请求头数据：\n方法：\n​    String getHeader(String name):通过请求头的名称获取请求头的值\n   Enumeration getHeaderNames( );获取所有的请求头名称\n\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n&#x2F;&#x2F;获取请求消息体--请求参数\n    &#x2F;&#x2F;1.获取字符流\n    BufferedReader br &#x3D; request.getReader();\n    &#x2F;&#x2F;2.读取数据\n    String line &#x3D; null;\n    while((line&#x3D; br.readLine())!&#x3D;null)&#123;\n        System.out.println(line);\n    &#125;\n&#125;\n\n&lt;form action&#x3D;&quot;&#x2F;requestDemo5&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type &#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入用户名&quot; name &#x3D; &quot;username&quot;&gt; &lt;br&gt;\n    &lt;input type &#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入密码&quot; name&#x3D;&quot;password&quot;&gt; &lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt;\n&lt;&#x2F;form&gt;\n\n 其他功能：\n\n获取请求参数通用方式\n\nString getParameter(String name)：根据参数名称获取参数值 username=zs&amp;password=123\nString username &#x3D; request.getParameter(&quot;username&quot;);\nString[] getParameterValues(String name)：根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game\nString[] choose &#x3D; request.getParameterValues(&quot;hobby&quot;);\n\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;game&quot;&gt;游戏\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;study&quot;&gt;学习\nEnumeration getParameterNames()：获取所有请求的参数名称\n\nMap&lt;String，String[]&gt; getParameterMap()：获取所有参数的map集合\n    Map&lt;String,String[]&gt; parameterMap &#x3D; request.getParameterMap();\n    Set&lt;String&gt; keyset &#x3D; parameterMap.keySet();\n    for (String s : keyset) &#123;\n        String[] value &#x3D; parameterMap.get(s);\n        System.out.println(s);\n        for (String value2 : value) &#123;\n            System.out.println(value2);\n        &#125;\n        System.out.println(&quot;----------------------&quot;);\n\n    &#125;\n&#125;\n\n\n请求转发\nRequestDispatcher requestDispatcher &#x3D; request.getRequestDispatcher(&quot;&#x2F;requestDemo9&quot;);\nrequestDispatcher.forward(request,response);\n   \n\n\n\n共享数据\n\n\n获取ServletContext\nServletContext getServletContext()\n\n\n。。\n中文乱码问题：\nrequest.setCharacterEncoding(&quot;utf-8&quot;);\n\n\nresponse\n\n响应体：传输的数据\n\n重定向\n\n\n转发不需要写虚拟目录\n重定向需要写虚拟目录\n路径写法：\n\n\n字节流一般输出图片。\n3.服务器输出字节数据到浏览器\n4.验证码：\n​            1.本质：图片\n​            2.防止恶意表单注册\nServletContext对象1.概念：代表整个web应用，可以和程序的容器（服务器）来通信\n2.功能：\n​        1.获取MIME类型\n​        2.域对象：共享数据\n​        3.获取文件的真实（服务器）路径\nServletContext对象获取：\n​        1.通过request对象获取\n​                request.getServletContext();\n​        2.通过HttpServlet获取\n​                this.getServletContext()；\n​        3.功能：\n​            1.获取MIME类型\n​                *MIME类型：在互联网通信过程中定义的一种文件数据类型\n​                    *格式：大类型/小类型  text/html   image/jpeg\n​                *获取：String getMimeType（String file）\n​            2.域对象：共享数据\n​                1.setAttribute（String name，Object value）\n​                2.getAttribute（String name）\n​                3.removeAttribute（String name）\n​                *ServletContext对象范围：所有用户所有请求的数据 \n​            3.获取文件的真实（服务器）路径\n\n反射框架设计的灵魂\n框架：半成品软件。可以在框架的基础上进行软件开发，简化编码\n反射：将类的各个组成部分封装成其他对象，这就是反射机制。\n好处：1.可以在程序运行过程中，操作这些对象\n​            2.可以解耦，提高程序的可扩展性\n获取Class对象的方式：\n\nClass.forName(“全类名”)；将字节码文件加载进内存，返回Class对象\n类名.class，通过类名的属性class获取\n对象.getClass().getClass()方法在Object类中定义着\n\n反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。\n流try()中定义流对象，会自动关流\n字符流 FileReader FileWriter 操作单位时字符，一个一个读和写 一组一组读和写\n字节流 FileInputStream FileOutputStream 数据底层皆为字节\n序列化流 前置条件：实现接口 Serialiable ObjectOutputStream ObjectInputStream 方便网络或文件中传递\n转换流：OutputStreamWriter InputStreamReader 指定编码读写\n字符缓冲流：BufferedReader .readline() BufferedWriter  writeline()\n注解Deprecated 表示已过时\nSuppresWarnings 压制警告\n​    一般传递参数all @SuppresWarnings(“all”)\n自定义注解\n\n多线程Thread和Runnable的区别\n实现Runnable接口创建多线程程序的好处：\n\n适合多个相同的程序代码的线程去共享同一个资源\n\n可以避免java中的单继承的局限性。\n\n增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立\n\n线程池只能放入实现Runabl或Callable类线程，不能直接放入继承Thread的类。​    增强了程序的扩展性，降低了程序的耦合性（解耦）\n​    实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）\n​    实现类中，重写了run方法：用来设置线程任务\n​    创建Thread类对象，调用start方法，用来开启新线程\n\n\n线程安全问题public class Ticket &#123;\n    public static void main(String[] args) &#123;\n        RunnableImpl run &#x3D; new RunnableImpl();\n        Thread t0 &#x3D; new Thread(run);\n        Thread t1 &#x3D; new Thread(run);\n        Thread t2 &#x3D; new Thread(run);\n        t0.start();\n        t1.start();\n        t2.start();\n\n    &#125;\n&#125;\n\npublic class RunnableImpl implements Runnable&#123;\n    private int ticket &#x3D; 100;\n    @Override\n    public void run() &#123;\n        while(true)&#123;\n            if(ticket&gt;0)&#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);\n                   ticket--;\n            &#125;\n&#125;\n    &#125;\n&#125;\n\nThread-0–&gt;正在卖第100张票Thread-2–&gt;正在卖第100张票Thread-1–&gt;正在卖第100张票Thread-0–&gt;正在卖第97张票\n…\nThread-2–&gt;正在卖第2张票Thread-1–&gt;正在卖第1张票Thread-0–&gt;正在卖第1张票Thread-2–&gt;正在卖第-1张票\n三个线程抢cpu执行，导致负票和打印同一张票。\n线程是处理机调度的单位，进程是资源分配的单位\n线程同步synchronized\n在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决线程不安全问题。\n同步操作：\n\n同步代码块\n\n&#x2F;&#x2F;创建一个锁对象\nObject obj &#x3D; new Object();\n\n@Override\npublic void run() &#123;\n    while (true) &#123;\n        synchronized (obj) &#123;\n            if (ticket &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                ticket--;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n同步方法\n使用步骤：\n1.把访问了共享数据的代码抽取出来，放到一个方法中\n2.在方法上添加synchronized修饰符\n格式：  修饰符 synchronized 返回值类型 方法名(参数列表){\n可能会出现线程安全问题的代码}\n同步方法的锁对象是谁？\n就是实现类对象 new RunnableImpl()\n也就是this\n静态方法private static int ticket &#x3D; 100;\n    &#x2F;&#x2F;创建一个锁对象\n    Object obj &#x3D; new Object();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            payTicket();\n\n        &#125;\n    &#125;\n\npublic static synchronized void payTicket() &#123;\n            if (ticket &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                ticket--;\n            &#125;\n    &#125;\n\n静态的同步方法\n不能是this ， this是创建对象后产生的\n锁对象是本来的class属性–&gt;class文件对象（反射）\n\n锁机制\nLock实现提供了 比使用synchronized方法和语句可获得的更广泛的锁定操作\nLock接口中的方法：\nvoid lock()获取锁。\nvoid unlock()释放锁\njava.util.concurrent.locks.ReentrantLock implements Lock接口\n\n\n\npublic class RunnableImpl implements Runnable &#123;\n    private int ticket &#x3D; 100;\n    Lock l &#x3D; new ReentrantLock();\n    &#x2F;&#x2F;创建一个锁对象\n    Object obj &#x3D; new Object();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            l.lock();\n\n                if (ticket &gt; 0) &#123;\n                    try &#123;\n                        Thread.sleep(10);\n                        System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                        ticket--;\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;finally &#123;\n                        l.unlock();\n                    &#125;\n\n                &#125;\n\n        &#125;\n    &#125;\n&#125;\n\n线程状态new ：new Thread() new Thread子类()\nrunnable\nwait\nnotify\n线程池使用步骤：\n\n使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池\n创建一个类，实现Runnable接口，重写run方法，设置线程任务\n调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法\n调用ExecutorService中的方法shutdown销毁线程池（不建议执行）\n\npublic class ThreadPool &#123;\n    public static void main(String[] args) &#123;\n        ExecutorService es &#x3D; Executors.newFixedThreadPool(2);\n        es.submit(new RunnableImpl());\n        es.submit(new RunnableImpl());\n        es.shutdown();\n    &#125;\n&#125;\n\nll\nCookie\n\n@WebServlet(&quot;&#x2F;cookieDemo2&quot;)\npublic class CookieDemo2 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request, response);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        Cookie[] cs &#x3D; request.getCookies();\n        if(cs!&#x3D;null)&#123;\n            for (Cookie c : cs) &#123;\n                String name &#x3D; c.getName();\n                String value &#x3D; c.getValue();\n                System.out.println(name+&quot;:&quot;+value);\n            &#125;\n        &#125;\n        \n    &#125;\n&#125;\n\n@WebServlet(&quot;&#x2F;cookieDemo1&quot;)\npublic class CookieDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request, response);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        Cookie c &#x3D; new Cookie(&quot;msg&quot;,&quot;hello&quot;);\n        response.addCookie(c);\n    &#125;\n&#125;\n\n3.实现原理\n基于响应头set-cookie和请求头cookie实现 \n\nJSP原理本质是一个Servlet\n\njsp的脚本：jsp定义java代码的方式\n\n&lt;% 代码 %&gt;\n\n&lt;%! 代码 %&gt;\n\n&lt;%= 代码 %&gt;\n\n\n\njsp的内置对象\n\nSession\n3.原理：Session的实现是依赖于Cookie的\n\n\n\n\njsp\n\n\nEL表达式\n\n\n获取对象、List集合、Map集合的值\n\n隐式对象：\nel表达式有11个隐式对象\npageContext：\n获取jsp其他八个内置对象\n${pageContext.request.contextPath}：动态获取虚拟目录\nJSTL\n\n&lt;%\n    request.setAttribute(&quot;number&quot;,3);\n%&gt;\n&lt;c:choose&gt;\n    &lt;c:when test&#x3D;&quot;$&#123;number&#x3D;&#x3D;3&#125;&quot;&gt;星期三&lt;&#x2F;c:when&gt;\n    &lt;c:otherwise&gt;数字有误&lt;&#x2F;c:otherwise&gt;\n&lt;&#x2F;c:choose&gt;\n\n\nforeach\n数据库连接池\npublic class JDBCUtils &#123;\n    private static DataSource ds;\n\n    static&#123;\n        try &#123;\n&#x2F;&#x2F;            导入jar包\n            Properties pro &#x3D; new Properties();\n&#x2F;&#x2F;            定义配置文件\n            InputStream is &#x3D; JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n&#x2F;&#x2F;            加载配置文件\n            pro.load(is);\n&#x2F;&#x2F;            获取连接池对象\n            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static DataSource getDataSource()&#123;\n        return ds;\n    &#125;\n&#x2F;&#x2F;    获取连接\n    public static Connection getConnection() throws SQLException&#123;\n        return  ds.getConnection();\n    &#125;\n&#125;\n\ndruid.properties\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test\nusername&#x3D;root\npassword&#x3D;123456\n    &#x2F;&#x2F;初始化连接对象数目\ninitialSize&#x3D;5\n    &#x2F;&#x2F; 最大连接数 10\nmaxActive&#x3D;10\n    &#x2F;&#x2F;最大等待时间 3s\nmaxWait&#x3D;3000\n\ntemplate\n数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB\n2. 什么数据库？\n    * 用于存储和管理数据的仓库。\n\n3. 数据库的特点：\n    1. 持久化存储数据的。其实数据库就是一个文件系统\n    2. 方便存储和管理数据\n    3. 使用了统一的方式操作数据库 -- SQL\n\n​    \n4. 常见的数据库软件\n    * 参见《MySQL基础.pdf》\n\nMySQL数据库软件1. 安装\n    * 参见《MySQL基础.pdf》\n2. 卸载\n    1. 去mysql的安装目录找到my.ini文件\n        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n    2. 卸载MySQL\n    3. 删除C:/ProgramData目录下的MySQL文件夹。\n    \n3. 配置\n    * MySQL服务启动\n        1. 手动。\n        2. cmd--&gt; services.msc 打开服务的窗口\n        3. 使用管理员打开cmd\n            * net start mysql : 启动mysql的服务\n            * net stop mysql:关闭mysql服务\n    * MySQL登录\n        1. mysql -uroot -p密码\n        2. mysql -hip -uroot -p连接目标的密码\n        3. mysql --host=ip --user=root --password=连接目标的密码\n    * MySQL退出\n        1. exit\n        2. quit\n\n    * MySQL目录结构\n        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;\n            * 配置文件 my.ini\n        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n            * 几个概念\n                * 数据库：文件夹\n                * 表：文件\n                * 数据：数据\n\n查询时去重：select distinct\n查询某两列的和： row1+row2，如果某列有null值 select row1+ifnull(row2,0) from table\n起别名：select row1+ifnull(row2,0) as add from table\n不等于： ！=  也可以用**&lt;&gt;**\n        -- 查询年龄22岁，18岁，25岁的信息\n        SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\n        SELECT * FROM student WHERE age IN (22,18,25);\n\n        -- 查询英语成绩为null\n        SELECT * FROM student WHERE english = NULL; -- 不对的！  null值不能使用 = （!=） 判断\n        SELECT * FROM student WHERE english IS NULL;\n        -- 查询英语成绩不为null\n        SELECT * FROM student WHERE english  IS NOT NULL;\n\n        -- 查询姓马的有哪些？ like\n            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n        -- 查询姓名第二个字是化的人\n            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n        -- 查询姓名是3个字的人\n            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n        -- 查询姓名中包含德的人\n            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n\n\n排序查询\n\n语法：order by 子句\n\norder by 排序字段1 排序方式1 ，  排序字段2 排序方式2…\n\n\n排序方式：\n\nASC：升序，默认的。\nDESC：降序。\n\n\n注意：\n\n如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。\n\n  – 按照性别分组。分别查询男、女同学的平均分,人数\n  SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\n\nwhere 和 having 的区别？\nwhere 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来\nwhere 后不可以跟聚合函数，having可以进行聚合函数的判断。\n\n\n\n\n\n\n分页查询\n语法：limit 开始的索引,每页查询的条数;\n\n公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数\n – 每页显示3条记录 \n SELECT * FROM student LIMIT 0,3; – 第1页\n SELECT * FROM student LIMIT 3,3; – 第2页\n SELECT * FROM student LIMIT 6,3; – 第3页\n\nlimit 是一个MySQL”方言”\n\n\n  外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。\n\n1. 在创建表时，可以添加外键\n   * 语法：\n     create table 表名(\n     \t....\n     \t外键列\n     \tconstraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n     );\n 举例：constraint emp_dept_fk foreign key (dep_id) references department(id)\n \n\n2. 删除外键\n   ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n3. 创建表之后，添加外键\n   ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\n\n\n```\n 级联操作\n 1. 添加级联操作\n     语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \n             FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;\n 2. 分类：\n     1. 级联更新：ON UPDATE CASCADE \n     2. 级联删除：ON DELETE CASCADE \n\n   \t\n  \t 多对多：\n  \t\t\t\t* 如：学生和课程\n  \t\t\t\t* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 \n\n# SQL\n\n\t1.什么是SQL？\n\t\tStructured Query Language：结构化查询语言\n\t\t其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\n\t\t\n\t2.SQL通用语法\n\t\t1. SQL 语句可以单行或多行书写，以分号结尾。\n\t\t2. 可使用空格和缩进来增强语句的可读性。\n\t\t3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n\t\t4. 3 种注释\n\t\t\t* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \n\t\t\t* 多行注释: &#x2F;* 注释 *&#x2F;\n\t\t\n\t3. SQL分类\n\t\t1) DDL(Data Definition Language)数据定义语言\n\t\t\t用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\n\t\t2) DML(Data Manipulation Language)数据操作语言\n\t\t\t用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\n\t\t3) DQL(Data Query Language)数据查询语言\n\t\t\t用来查询数据库中表的记录(数据)。关键字：select, where 等\n\t\t4) DCL(Data Control Language)数据控制语言(了解)\n\t\t\t用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\n\n## DDL:操作数据库、表\n\n\t1. 操作数据库：CRUD\n\t\t1. C(Create):创建\n\t\t\t* 创建数据库：\n\t\t\t\t* create database 数据库名称;\n\t\t\t* 创建数据库，判断不存在，再创建：\n\t\t\t\t* create database if not exists 数据库名称;\n\t\t\t* 创建数据库，并指定字符集\n\t\t\t\t* create database 数据库名称 character set 字符集名;\n\t\n\t\t\t* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\n\t\t\t\t* create database if not exists db4 character set gbk;\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询所有数据库的名称:\n\t\t\t\t* show databases;\n\t\t\t* 查询某个数据库的字符集:查询某个数据库的创建语句\n\t\t\t\t* show create database 数据库名称;\n\t\t3. U(Update):修改\n\t\t\t* 修改数据库的字符集\n\t\t\t\t* alter database 数据库名称 character set 字符集名称;\n\t\t4. D(Delete):删除\n\t\t\t* 删除数据库\n\t\t\t\t* drop database 数据库名称;\n\t\t\t* 判断数据库存在，存在再删除\n\t\t\t\t* drop database if exists 数据库名称;\n\t\t5. 使用数据库\n\t\t\t* 查询当前正在使用的数据库名称\n\t\t\t\t* select database();\n\t\t\t* 使用数据库\n\t\t\t\t* use 数据库名称;\n\n\n\t2. 操作表\n\t\t1. C(Create):创建\n\t\t\t1. 语法：\n\t\t\t\tcreate table 表名(\n\t\t\t\t\t列名1 数据类型1,\n\t\t\t\t\t列名2 数据类型2,\n\t\t\t\t\t....\n\t\t\t\t\t列名n 数据类型n\n\t\t\t\t);\n\t\t\t\t* 注意：最后一列，不需要加逗号（,）\n\t\t\t\t* 数据库类型：\n\t\t\t\t\t1. int：整数类型\n\t\t\t\t\t\t* age int,\n\t\t\t\t\t2. double:小数类型\n\t\t\t\t\t\t* score double(5,2)\n\t\t\t\t\t3. date:日期，只包含年月日，yyyy-MM-dd\n\t\t\t\t\t4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\n\t\t\t\t\t5. timestamp:时间错类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\n\t\t\t\t\t\t* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\n\t\n\t\t\t\t\t6. varchar：字符串\n\t\t\t\t\t\t* name varchar(20):姓名最大20个字符\n\t\t\t\t\t\t* zhangsan 8个字符  张三 2个字符\n\n\n\t\t\t* 创建表\n\t\t\t\tcreate table student(\n\t\t\t\t\tid int,\n\t\t\t\t\tname varchar(32),\n\t\t\t\t\tage int ,\n\t\t\t\t\tscore double(4,1),\n\t\t\t\t\tbirthday date,\n\t\t\t\t\tinsert_time timestamp\n\t\t\t\t);\n\t\t\t* 复制表：\n\t\t\t\t* create table 表名 like 被复制的表名;\t  \t\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询某个数据库中所有的表名称\n\t\t\t\t* show tables;\n\t\t\t* 查询表结构\n\t\t\t\t* desc 表名;\n\t\t3. U(Update):修改\n\t\t\t1. 修改表名\n\t\t\t\talter table 表名 rename to 新的表名;\n\t\t\t2. 修改表的字符集\n\t\t\t\talter table 表名 character set 字符集名称;\n\t\t\t3. 添加一列\n\t\t\t\talter table 表名 add 列名 数据类型;\n\t\t\t4. 修改列名称 类型\n\t\t\t\talter table 表名 change 列名 新列别 新数据类型;\n\t\t\t\talter table 表名 modify 列名 新数据类型;\n\t\t\t5. 删除列\n\t\t\t\talter table 表名 drop 列名;\n\t\t4. D(Delete):删除\n\t\t\t* drop table 表名;\n\t\t\t* drop table  if exists 表名 ;\n\n* 客户端图形化工具：SQLYog\n\n## DML：增删改表中数据\n\n\t1. 添加数据：\n\t\t* 语法：\n\t\t\t* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\n\t\t* 注意：\n\t\t\t1. 列名和值要一一对应。\n\t\t\t2. 如果表名后，不定义列名，则默认给所有列添加值\n\t\t\t\tinsert into 表名 values(值1,值2,...值n);\n\t\t\t3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\n\t2. 删除数据：\n\t\t* 语法：\n\t\t\t* delete from 表名 [where 条件]\n\t\t* 注意：\n\t\t\t1. 如果不加条件，则删除表中所有记录。\n\t\t\t2. 如果要删除所有记录\n\t\t\t\t1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\n\t\t\t\t2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\n\t3. 修改数据：\n\t\t* 语法：\n\t\t\t* update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,... [where 条件];\n\t\n\t\t* 注意：\n\t\t\t1. 如果不加任何条件，则会将表中所有记录全部修改。\n\n\n\n## DQL：查询表中的记录\n\n\t* select * from 表名;\n\t\n\t1. 语法：\n\t\tselect\n\t\t\t字段列表\n\t\tfrom\n\t\t\t表名列表\n\t\twhere\n\t\t\t条件列表\n\t\tgroup by\n\t\t\t分组字段\n\t\thaving\n\t\t\t分组之后的条件\n\t\torder by\n\t\t\t排序\n\t\tlimit\n\t\t\t分页限定\n\n\n\t2. 基础查询\n\t\t1. 多个字段的查询\n\t\t\tselect 字段名1，字段名2... from 表名；\n\t\t\t* 注意：\n\t\t\t\t* 如果查询所有字段，则可以使用*来替代字段列表。\n\t\t2. 去除重复：\n\t\t\t* distinct\n\t\t3. 计算列\n\t\t\t* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n\t\t\t* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\n\t\t\t\t* 表达式1：哪个字段需要判断是否为null\n\t\t\t\t* 如果该字段为null后的替换值。\n\t\t4. 起别名：\n\t\t\t* as：as也可以省略\n\n\n\t3. 条件查询\n\t\t1. where子句后跟条件\n\t\t2. 运算符\n\t\t\t* &gt; 、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt;\n\t\t\t* BETWEEN...AND  \n\t\t\t* IN( 集合) \n\t\t\t* LIKE：模糊查询\n\t\t\t\t* 占位符：\n\t\t\t\t\t* _:单个任意字符\n\t\t\t\t\t* %：多个任意字符\n\t\t\t* IS NULL  \n\t\t\t* and  或 &amp;&amp;\n\t\t\t* or  或 || \n\t\t\t* not  或 !\n\t\t\t\n\t\t\t\t-- 查询年龄大于20岁\n\t\n\t\t\t\tSELECT * FROM student WHERE age &gt; 20;\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄等于20岁\n\t\t\t\tSELECT * FROM student WHERE age &#x3D; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄不等于20岁\n\t\t\t\tSELECT * FROM student WHERE age !&#x3D; 20;\n\t\t\t\tSELECT * FROM student WHERE age &lt;&gt; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄大于等于20 小于等于30\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp;  age &lt;&#x3D;30;\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20 AND  age &lt;&#x3D;30;\n\t\t\t\tSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n\t\t\t\t\n\t\t\t\t-- 查询年龄22岁，18岁，25岁的信息\n\t\t\t\tSELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25\n\t\t\t\tSELECT * FROM student WHERE age IN (22,18,25);\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩为null\n\t\t\t\tSELECT * FROM student WHERE english &#x3D; NULL; -- 不对的。null值不能使用 &#x3D; （!&#x3D;） 判断\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE english IS NULL;\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩不为null\n\t\t\t\tSELECT * FROM student WHERE english  IS NOT NULL;\n\n\n\n\t\t\t\t-- 查询姓马的有哪些？ like\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n\t\t\t\t-- 查询姓名第二个字是化的人\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n\t\t\t\t\n\t\t\t\t-- 查询姓名是3个字的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n\n\n​\t\t\t\t\n\n\t\t\t\t-- 查询姓名中包含德的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n\n## 数据库备份\n\nmysqldump -uroot -p (数据库名) &gt; d:&#x2F;&#x2F;a.sql\n\n\t# 网络编程\n\nudp：\n\n&#96;&#96;&#96;java\n&#x2F;**\n * UDP发送端\n *&#x2F;\npublic class SendDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        DatagramSocket ds &#x3D; new DatagramSocket();\n        byte[] bys &#x3D; &quot;shit!+\\n&quot;.getBytes();\n        DatagramPacket dp &#x3D; new DatagramPacket(bys,bys.length, InetAddress.getByName(&quot;localhost&quot;),65530);\n        ds.send(dp);\n        ds.close();\n    &#125;\n&#125;\n\n&#x2F;**\n * UDP接收端\n *&#x2F;\npublic class AcceptDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        DatagramSocket ds &#x3D; new DatagramSocket(65530);\n        byte[] by &#x3D; new byte[1024];\n        DatagramPacket dp &#x3D; new DatagramPacket(by,by.length);\n        ds.receive(dp);\n        int len &#x3D; dp.getLength();\n        String dataString &#x3D; new String(by,0,len);\n        System.out.println(&quot;数据是&quot;+dataString);\n        ds.close();\n    &#125;\n&#125;\n\ntcp断开流程：\n假设 Client 端发起中断连接请求，也就是发送 FIN 报文。Server 端接到 FIN 报文后，意思是说 &quot; 我 Client 端没有数据要发给你了 &quot;，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，&quot; 告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息 &quot;。这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，&quot; 告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了 &quot;。Client 端收到 FIN 报文后，&quot; 就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。“，Server 端收到 ACK 后，&quot; 就知道可以断开连接了 &quot;。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！\n\ntcp发送数据的步骤：\n\n创建客户端的Socket对象\nSocket(String host,int port)\n\n获取输出流，写数据\nOutputStream getOutputStream()\n\n释放资源\nvoid close()\n\n\ntcp接收数据的步骤：\n\n创建服务端的Socket对象（ServerSocket）\nServerSocket(int port)\n\n监听客户端连接，返回一个Socket对象\nSocket accept()\n\n获取输入流、读数据，并把数据显示在控制台\nInputStream getInputStream()\n\n释放资源\nvoid close()\n\n\npublic class Send &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;创建客户端的Socket对象\n        Socket sc &#x3D; new Socket(&quot;192.168.1.51&quot;,65530);\n        &#x2F;&#x2F;获取输出流，写数据\n        OutputStream os &#x3D; sc.getOutputStream();\n        os.write(&quot;hello,tcp&quot;.getBytes());\n        &#x2F;&#x2F;释放资源\n        sc.close();\n    &#125;\n&#125;\n\npublic class Accept &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;创建服务端的Socket对象（ServerSocket）\n        ServerSocket sc &#x3D; new ServerSocket(65530);\n        &#x2F;&#x2F;监听客户端连接，返回一个Socket对象\n        Socket s &#x3D; sc.accept();\n        &#x2F;&#x2F;获取输入流、读数据，并把数据显示在控制台\n        InputStream is &#x3D; s.getInputStream();\n        byte[] bys &#x3D; new byte[1024];\n        int len &#x3D; is.read(bys);\n        String data &#x3D; new String(bys,0,len);\n        System.out.println(&quot;数据是：&quot;+data);\n        &#x2F;&#x2F;释放资源\n        sc.close();\n    &#125;\n&#125;\n\nhtmlinput 对应checked 默认\noption 对应 selected \n\n./ 代表当前目录\n../代表上一级目录\n换行\n 标签的 alt 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。\n如何实现全选功能：\n将全选按钮和列表按钮绑定，用循环遍历来逐个绑定。\n&#x2F;&#x2F;1.获取第一个cb\ndocument.getElementById(&quot;firstCb&quot;).onclick &#x3D; function ()&#123;\n    &#x2F;&#x2F; 2.获取下边列表中所有的cb\nvar cbs &#x3D; document.getElementsByName(&quot;uid&quot;);\nfor(var i &#x3D; 0;i&lt;cbs.length;i++)&#123;\n    &#x2F;&#x2F;4.设置这些cbp[i]的checked状态&#x3D;firstCb.checked\n    cbs[i].checked &#x3D; this.checked; \n\n 空格占位符\nhtml建立表单快捷代码  table&gt;tr2&gt;td3 再按Tab  两行三列\nstyle（css样式） 一般在head中，script 一般在body中\n\n类加载器如果写一个类需要动态的获取某个文件的位置，从而能够获取此文件的资源。那么，使用 Class.getResourceAsStream () 方法便可以。\n这样就不用每次去修改代码中文件的绝对地址或详细地址了。\njedisjedis.setex(&quot;activecode&quot;,10,&quot;hehe&quot;);&#x2F;&#x2F;将activecode，hehe键值对存入redis，10秒后删除\n\n\nlist转json\nObjectMapper mapper &#x3D; new ObjectMapper();\nString s &#x3D; mapper.writeValueAsString(list);\n\nJavaScript通过内容来确定类型 var 变量 = 初始化值\ntypeof 来确定类型\njs中== 先做类型转换，再进行比较 3==“3“  true\n=== 先做类型比较，如果类型不同， false\n    5. 逻辑运算符\n        &amp;&amp; || !    （短路效果\n        * 其他类型转boolean：\n           1. number：0或NaN为假，其他为真\n           2. string：除了空字符串(&quot;&quot;)，其他都是true\n           3. null&amp;undefined:都是false\n           4. 对象：所有对象都为true\n\n引号的时候，内双外单或者外双内单    ‘     “   “    ‘   \nplaceholder 虚化的value\n&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入性别&quot; id&#x3D;&quot;c3&quot;&gt;\n\nservlet以 .do结尾的路径不能以/开头\ntomcat8 和以后版本已经解决get请求中文乱码\npost中文乱码需要手动解决  \n\n解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”);\n\n也可以用过滤器等等\nEnumeration&lt;String&gt; parameterNames &#x3D; request.getParameterNames();\n\nwhile(parameterNames.hasMoreElements)&#123;&#125;\n\n&#x2F;&#x2F;遍历枚举\n\n内部资源转发必须用请求转发\n\n&#x2F;&#x2F; $.get(url,[data],[callback],[type]);  路径，数据，回调函数，接收到的响应数据的格式\n\npost语法一样\njson的三个包\n\n    public void Test02() throws JsonProcessingException &#123;\n&#x2F;&#x2F;        将json转为java对象\n        String json &#x3D; &quot;&#123;\\&quot;gender\\&quot;:\\&quot;男\\&quot;,\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;age\\&quot;:23&#125;&quot;;\n        ObjectMapper map &#x3D; new ObjectMapper();\n        Person person &#x3D; map.readValue(json, Person.class);\n        System.out.println(person);\n    &#125;\n\n\n修改tomcat启动默认页面。web.xml\n四大域对象 \npageContext、request、session、ServletContext(全局域对象 随着tomcat启动创建 tomcat消亡而消亡)\nApplicationContext与ServletContext是一个东西\n\nsession工作原理\n枚举\nvalue () 方法可以将枚举类转变为一个枚举类型的数组，因为枚举中没有下标，我们没有办法通过下标来快速找到需要的枚举类，这时候，转变为数组之后，我们就可以通过数组的下标，来找到我们需要的枚举类。接下来就展示代码了。\npublic enum SearchCategory &#123;\n    ALL(&quot;综合查询&quot;),\n    NEWS(&quot;新闻&quot;),\n    TAXPAYER(&quot;纳税人&quot;),\n    QUIZ(&quot;知识问答&quot;),\n    POLICY_LAW(&quot;政策法规&quot;),\n    DOC(&quot;涉税文档&quot;),\n    PIC(&quot;图片&quot;),\n    BAIKE(&quot;税务百科&quot;);\n\n    private String value;\n\n    SearchCategory(String value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public String getValue()&#123;\n        return value;\n    &#125;\n    \n    public static void main(String[] args)&#123;\n        for(SearchCategory s : SearchCategory.values())&#123;\n            System.out.println(s + &quot;---&quot; + s.getValue());\n        &#125;\n    &#125;\n&#125;\n\n转换json并设置格式\n@JsonFormat(pattern &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;,timezone &#x3D; &quot;GMT+8&quot;)\nprivate Date joinDate;\n\n","slug":"java基础","date":"2021-08-07T14:32:21.000Z","categories_index":"java","tags_index":"java","author_index":"icarus"}]