[{"id":"5f849d772fd372114a5b63b97d1479ef","title":"面试题","content":"object类中的方法：实现对象的浅拷贝的clone方法\n获得运行时类型的getclass方法\n释放资源的finalize方法\n用户哈希查找的hashcode方法\n使当前线程等待该对象的锁wait方法\n访问修饰符：​                本类中  同个包  子类  任何地方\npublic \nprotect \ndefault \nprivate\n在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n抽象类必须被继承才能使用\n  CREATE PROCEDURE myproc(OUT s int)\n    BEGIN\n      SELECT COUNT(*) INTO s FROM students;\n    END\n    &#x2F;&#x2F;\nDELIMITER ;\n\nObject 类方法Object 是所有类的父类，任何类都默认继承 Object。Object 类到底实现了哪些方法？\n（1）clone 方法\n保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。\n（2）getClass 方法\nfinal 方法，获得运行时类型。\n（3）toString 方法\n该方法用得比较多，一般子类都有覆盖。\n（4）finalize 方法\n该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。\n（5）equals 方法\n该方法是非常重要的一个方法。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。\n（6）hashCode 方法\n该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法。这个方法在一些具有哈希功能的 Collection 中用到。\n一般必须满足 obj1.equals (obj2)==true。可以推出 obj1.hash- Code ()==obj2.hashCode ()，但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\n（7）wait 方法\nwait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait () 方法一直等待，直到获得锁或者被中断。wait (long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。\n调用该方法后当前线程进入睡眠状态，直到以下事件发生。\n（1）其他线程调用了该对象的 notify 方法。\n（2）其他线程调用了该对象的 notifyAll 方法。\n（3）其他线程调用了 interrupt 中断该线程。\n（4）时间间隔到了。\n此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。\n（8）notify 方法\n该方法唤醒在该对象上等待的某个线程。\n（9）notifyAll 方法\n该方法唤醒在该对象上等待的所有线程。\n如何理解面向对象的三个特征的？面向对象的特性是封装、继承和多态，封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化，这样做使得代码的复用性更高；继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性，这样做扩展了已存在的代码块，进一步提高了代码的复用性；多态是为了实现接口重用，多态的一大作用就是为了解耦，允许父类引用 (或接口) 指向子类 (或实现类) 对象。多态的表现形式有重写和重载\n说说重写和重载重写发生在父类与子类之间，方法名相同，参数列表相同，返回值可以 “变小”，抛出的异常可以 “变小”，访问修饰符权限不能变小，发生在运行期重载实在一个类中，方法名相同，参数列表不同（参数顺序不同也行），返回值和访问修饰符可以不同，发生在编译期\nSpring IOC / DI 底层实现原理问题说明：Spring 是如何通过配置文件，就完成了对象的创建和属性的赋值？答案：\n使用工厂设计模式 + 配置文件 + 反射描述：使用工厂设计模式，在工厂中，根据配置文件中标签的 class 属性，反射创建出对象。再根据标签的子标签标签的 name 属性，反射找到对应的 set 方法，反射调用 set 方法将标签的 value 属性的值 赋给属性。\nSpring AOPSpring AOP 概念问：你对 Spring AOP 有什么理解？\n思想： 面向切面编程在不修改目标类代码的情况下，在运行时，动态的为目标对象的目标方法增加额外功能，实现解耦合，提高代码的可维护性。\n本质： 在不修改目标类代码的情况下，在运行时，动态的为目标对象生成代理对象，用代理对象取而代之，代替目标对象接受调用，变相的实现了功能增强的效果。\nSpring AOP 底层实现原理问题说明： Spring AOP 是如何生成代理类对象的？\n答案： 使用 JDK 的 Proxy 的静态方法 newProxyInstance，内部执行动态字节码技术，产生代理类对象，产生代理类的对象。基于接口生成的。\n堆和栈的区别有：1、空间分配区别；2、缓存方式区别；3、数据结构区别。堆空间一般由程序员分配释放，栈空间由操作系统（编译器）自动分配释放。栈使用一级缓存，堆使用二级缓存。\n堆和栈的区别是什么1、堆栈空间分配区别\n栈（操作系统）：由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。\n2、堆栈缓存方式区别\n栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。\n堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。\n3、堆栈数据结构区别\n堆（数据结构）：堆可以被看成是一棵树，如：堆排序。\n栈（数据结构）：一种先进后出的数据结构。\n对象进堆 方法进栈 \n流复习直接操作文件——&gt; FileOuputStream、FileInputStream\n语法是：FileOutputStream （可以是String或者是File ，true / false ） 是否拼接可写可不写，默认是false\n节点流：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如 FileInputStream 和 FileOutputStream，他们直接从文件中读取或往文件中写入字节流。\n在已存在的输入或输出流上操作——&gt; BufferedInputStream 和 BufferedOutputStream\n语法是：BufferedOutputStream（new  FileOutputStream）\n处理流：“连接” 在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如 BufferedInputStream 和 BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率\n DataInputStream 和 DataOutputStream，使用已经存在的节点流来构造，提供了读写 Java 中的基本数据类型的功能。他们都属于过滤流。用了之后就可以使用writeInt、writeBoolean方法等等来书。\nlen = fis.read (bys)   \n包含两个动作：1. 代表每次最多从目标文件中读取 1024 个字节. 2. 返回每次读取多少个字节长度 (由于 read (bys) 向 bys 写入的数据是覆盖的，并不是替换 , 所以必须要返回字节长度，避免输出以外的字节)fis.read (bys) !=-1  表示当读取的目标文件到末尾了，没有剩余的字节了，就会返回 - 1, 通过是否等于 - 1 的判断，继续是否读取.new String (bys,0,len) 表示每次把 bys 里面的数据，从 0 到 len 的长度读取出去，len 控制了每次 bys 能读取到的字节长度，避免 bys 覆盖造成的错误. 通过构造方法转换成字符串输出\n BufferedOutputStream 输出数据时需要关闭流，否则数据不会输出到文件当中\n字节流和字符流的区别字节流操作的基本单元为字节；字符流操作的基本单元为 Unicode 码元。字节流默认不使用缓冲区；字符流使用缓冲区。字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用 close 或 flush 方法，则不会输出任何内容。字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取 Unicode 码元；字符流通常处理文本数据，它支持写入及读取 Unicode 码元。字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理 Unicode 字符，而字符流就可以。\n字节流和字符流的转换字节流是最基本的，所有的 InputStream 和 OutputStream 的子类都是，主要用在处理二进制数据，它是按字节来处理的，但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的 encode 来处理，也就是要进行字符集的转化，这两个之间通过 InputStreamReader,OutputStreamWriter 来关联，实际上是通过 byte [] 和 String 来关联。在从字节流转化为字符流时，实际上就是 byte [] 转化为 String 时，而在字符流转化为字节流时，实际上是 String 转化为 byte [] 时。\n字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。所以字符流是由 Java 虚拟机将字节转化为 2 个字节的 Unicode 字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。\n字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理 Unicode 字符，而字符流就可以。\n字节流与字符流主要的区别是他们的的处理方式。\n解决乱码问题\n File f &#x3D; new File(&quot;a.txt&quot;);\nFileOutputStream fop &#x3D; new FileOutputStream(f);\n&#x2F;&#x2F; 构建 FileOutputStream 对象，文件不存在会自动新建\n \nOutputStreamWriter writer &#x3D; new OutputStreamWriter(fop, &quot;UTF-8&quot;);\n&#x2F;&#x2F; 构建 OutputStreamWriter 对象，参数可以指定编码，默认为操作系统默认编码，windows 上是 gbk\n\n writer.append(&quot; 中文输入 &quot;);\n        &#x2F;&#x2F; 写入到缓冲区\n         writer.append(&quot;\\r\\n&quot;);\n        &#x2F;&#x2F; 换行\n         writer.append(&quot;English&quot;);\n        &#x2F;&#x2F; 刷新缓存冲，写入到文件，如果下面已经没有写入的内容了，直接 close 也会写入\n         writer.close();\n        &#x2F;&#x2F; 关闭写入流，同时会把缓冲区内容写入文件，所以上面的注释掉\n         fop.close();\n        &#x2F;&#x2F; 关闭输出流，释放系统资源\n         FileInputStream fip &#x3D; new FileInputStream(f);\n        &#x2F;&#x2F; 构建 FileInputStream 对象\n         InputStreamReader reader &#x3D; new InputStreamReader(fip, &quot;UTF-8&quot;);\n        &#x2F;&#x2F; 构建 InputStreamReader 对象，编码与写入相同\n         StringBuffer sb &#x3D; new StringBuffer();\n        while (reader.ready()) &#123;\n            sb.append((char) reader.read());\n            &#x2F;&#x2F; 转成 char 加到 StringBuffer 对象中\n        &#125;\n        System.out.println(sb.toString());\n        reader.close();\n        &#x2F;&#x2F; 关闭读取流\n         fip.close();\n        &#x2F;&#x2F; 关闭输入流，释放系统资源\n    &#125;\n&#125;\n\n递归删除\npublic class DeleteFileDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 这里修改为自己的测试目录\n         File folder &#x3D; new File(&quot;&#x2F;tmp&#x2F;java&#x2F;&quot;);\n        deleteFolder(folder);\n    &#125;\n \n    &#x2F;&#x2F; 删除文件及目录\n     public static void deleteFolder(File folder) &#123;\n        File[] files &#x3D; folder.listFiles();\n        if (files !&#x3D; null) &#123;\n            for (File f : files) &#123;\n                if (f.isDirectory()) &#123;\n                    deleteFolder(f);\n                &#125; else &#123;\n                    f.delete();\n                &#125;\n            &#125;\n        &#125;\n        folder.delete();\n    &#125;\n&#125;\n\n\n\n事务的四种特性：原子性、一致性、隔离性、持久性\nlinux常用命令：cd chgrp cat \nredis五种数据结构：string hash set zset list\ngit常用命令：\n新增文件的命令：git add file 或者 git add .提交文件的命令：git commit –m 或者 git commit –a查看工作区状况：git status –s拉取合并远程分支的操作：git fetch/git merge 或者 git pull查看提交记录命令：git reflog\nGit 代码合并有两种：Git Merge 和 Git ReBase\n","slug":"面试题","date":"2022-01-07T15:32:53.000Z","categories_index":"面试题","tags_index":"面试","author_index":"icarus"},{"id":"8f31d06ea2e56b4b6405cdb90df6568a","title":"hexo命令","content":"hexo官方文档https://hexo.io/zh-cn/docs/\n常用命令：\nhexo cl &amp; hexo g                                       ————–重建静态文件\nhexo n “文章标题”                                    —————建立新文章\nhexo clean &amp; hexo g &amp; hexo server        ————-一键清除并重新构建在本地测试\nhexo d                                                         ————-推送到github\nhexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署\nhexo server #Hexo 会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令\n","slug":"hexo命令","date":"2022-01-07T14:32:21.000Z","categories_index":"Hexo","tags_index":"hexo","author_index":"icarus"},{"id":"d072989fb1060a7ab47385f712edd6a0","title":"能遇见你，甚是开心","content":"欢迎来到我的世界，这是我的个人博客。基于 Hexo 框架搭建，采用 hexo-theme-aurora 主题。 \n后期也会不定时增加新的功能，敬请期待！！！\n","slug":"引言","date":"2022-01-07T14:32:21.000Z","categories_index":"引言","tags_index":"入站须知","author_index":"icarus"},{"id":"dae83d1c88f5937753ca40f0c60cab64","title":"RequestMapping注解","content":"@RequestMapping注解一个用来处理请求地址映射的注解，可用于类或方法上。\n用于类上，表示类中的所有请求的方法都是以该地址作为父路径@RestController\n@RequestMapping(&quot;&#x2F;test&quot;)\npublic class TestController &#123;\n    @Autowired\n    private MerchantConfigRepository merchantConfigService;\n    @Autowired\n    DealerService dealerService;\n\n用在类开头，为整个类规定它的父路径在方法前使用@RequestMapping ，相当于规定该调用方法的路径\n@RequestMapping(value &#x3D; &quot;&#x2F;addDealer&quot;,method &#x3D; RequestMethod.POST)\n    public String addDealer(@Valid @RequestBody DealerModel dealerModel, BindingResult bindingResult) &#123;\n        return dealerService.addDealer(dealerModel);\n    &#125;\n\n","slug":"@RequestMapping注解","date":"2021-11-07T14:32:21.000Z","categories_index":"java","tags_index":"spring","author_index":"icarus"},{"id":"3a37cd072b4ce26a3caecc3401259a9a","title":"Spring基础","content":"Spring\n\n导入Spring开发的基本包坐标\n\n编写Dao接口和实现类\n\n创建Spring核心配置文件\n\n在Spring配置文件中配置UserDaoImpl\n\n使用Spring的API获得Bean实例\n\n\n\n\nSpring的重点配置\n\nSpring原始注解\n\n\nspring集成web环境步骤\n\n\n\n\n视图解析器\n\n\n\n在@RequestMapping下加@ResponseBody 告知框架不进行视图跳转（跳转静态资源），而是直接进行数据响应返回的是字符串\n\nnew BeanPropertyRowMapper         \n\n&#x2F;&#x2F; javabean 需要满足标准  必须有空参数构造  数据库字段必须和属性名一致(数据封装失败)\n\n\n\n缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；\n\n排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；\n\n计算器&#x2F;限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；\n\n好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；\n\n简单消息队列，除了Redis自身的发布&#x2F;订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；\n\nSession共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。\n\n一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问\n\n简述 Redis 的数据\n\n如果有多个intercecptor配置，按照编写的顺序，如：\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n        &lt;bean class&#x3D;&quot;com.icarust.interceptor.MyInterceptor1&quot;&#x2F;&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n        &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n        &lt;bean class&#x3D;&quot;com.icarust.interceptor.MyInterceptor2&quot;&#x2F;&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n\n前置1执行\n前置2执行\n目标资源执行\npostHandle2执行\npostHandle1执行\nafterCompletion2执行\nafterCompletion1执行\n（有种后进先出的意味）\n\n\n\n前端控制器DispatcherServlet的核心配置文件：使用 springMVC 必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n处理器映射器：RequestMappingHandleMapping\n处理器适配器：RequestMappingHandleAdapter\n视图解析器：InternalResourceViewResolver\n通常，我们只需要手动配置视图解析器，而**处理器映射器*和处理器适配器*只需要开启**注解驱动****即可，而省去了大段的 xml 配置。这就是配置spring-mvc第一步注解驱动的作用。\nspring环境搭建步骤:\n\n搭建spring项目：web.xml：\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;\n&lt;&#x2F;context-param&gt;\n\n\n\n&lt;listener&gt;\n   &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n&lt;&#x2F;listener&gt;\n\n\n\n &lt;servlet&gt;\n     &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;\n     &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n     &lt;init-param&gt;\n         &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n         &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;\n     &lt;&#x2F;init-param&gt;\n     &lt;load-on-startup&gt;2&lt;&#x2F;load-on-startup&gt;&#x2F;&#x2F;在服务器启动时加载 1或2都行\n &lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n     &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;\n     &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n &lt;&#x2F;servlet-mapping&gt;\n\nspring-mvc.xml\n\n&lt;mvc:annotation-driven&#x2F;&gt;\n\n\n\n&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;pages&#x2F;&quot;&#x2F;&gt;  &#x2F;&#x2F;前缀，value是位置\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;     &#x2F;&#x2F;后缀，value是文件的后缀\n&lt;&#x2F;bean&gt;\n\n\n\n&lt;mvc:default-servlet-handler&#x2F;&gt;\n\napplicationContext.xml\n\n&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;\n\n\n\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n&lt;!--配置RoleDao--&gt;\n&lt;bean id&#x3D;&quot;roleDao&quot; class&#x3D;&quot;com.itheima.dao.impl.RoleDaoImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;jdbcTemplate&quot; ref&#x3D;&quot;jdbcTemplate&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n   \n&lt;!--配置UserDao--&gt;\n&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;jdbcTemplate&quot; ref&#x3D;&quot;jdbcTemplate&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n    \n&lt;!--配置RoleService--&gt;\n&lt;bean id&#x3D;&quot;roleService&quot; class&#x3D;&quot;com.itheima.service.impl.RoleServiceImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;roleDao&quot; ref&#x3D;&quot;roleDao&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;!--配置UserService--&gt;\n&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;\n    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;roleDao&quot; ref&#x3D;&quot;roleDao&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n页面form表单内的元素name必须和对象的属性名一致，springmvc才能自动封装\n提交方式post有乱码问题，需要设置编码，filter，在web.xml设置过滤器\n\n\n&lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\nspring重定向的方式：return “redirect: 地址 “;\n@PathVariable 是 spring3.0 的一个新功能：接收请求路径中占位符的值\nmybatis\n核心配置文件（sqlMapperConfig.xml）的约束\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n\n映射配置文件（xxx.xml）的约束\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\napplication context\n应用上下文 项目的访问路径 虚拟目录\nindex.jsp 访问时可以不写\ntomcat启动后在浏览器不仅可以访问网页还可以访问目录下的资源（image等）\n\n\n\n\nmybatis分页插件依赖（用以下版本，其他版本可能会报错）\n&lt;dependency&gt;\n    &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.7.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.github.jsqlparser&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jsqlparser&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\ntypeHandler 类型处理器 \n\n&lt;mapper namespace&#x3D;&quot;com.icarus.dao.FavoriteMapper&quot;&gt;\n    &lt;resultMap id&#x3D;&quot;favoriteMap&quot; type&#x3D;&quot;favorite&quot;&gt;\n&lt;!--        手动指定字段和实体属性映射关系--&gt;\n&lt;!--        column：数据表的字段名称--&gt;\n&lt;!--        property：实体属性名称--&gt;\n        &lt;id  column&#x3D;&quot;rid&quot; property&#x3D;&quot;rid&quot;&gt;&lt;&#x2F;id&gt;\n        &lt;result column&#x3D;&quot;DATE&quot; property&#x3D;&quot;date&quot;&gt;&lt;&#x2F;result&gt;\n&lt;!--        &lt;result column&#x3D;&quot;uid&quot; property&#x3D;&quot;uid&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n\n&lt;!--        &lt;result column&#x3D;&quot;username&quot;  property&#x3D;&quot;user.username&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;password&quot; property&#x3D;&quot;user.password&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;name&quot; property&#x3D;&quot;user.name&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;birthday&quot; property&#x3D;&quot;user.birthday&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;user.sex&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;telephone&quot; property&#x3D;&quot;user.telephone&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n&lt;!--        &lt;result column&#x3D;&quot;email&quot; property&#x3D;&quot;user.email&quot;&gt;&lt;&#x2F;result&gt;--&gt;\n\n&lt;!--        property:当前实体order中的属性名称--&gt;\n&lt;!--        javatype：当前实体中的属性名称--&gt;\n        &lt;association property&#x3D;&quot;user&quot; javaType&#x3D;&quot;user&quot;&gt;\n            &lt;id column&#x3D;&quot;username&quot; property&#x3D;&quot;username&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;password&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;birthday&quot; property&#x3D;&quot;birthday&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;sex&quot; property&#x3D;&quot;sex&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;telephone&quot; property&#x3D;&quot;telephone&quot;&#x2F;&gt;\n            &lt;id column&#x3D;&quot;email&quot; property&#x3D;&quot;email&quot;&#x2F;&gt;\n        &lt;&#x2F;association&gt;\n    &lt;&#x2F;resultMap&gt;\n    &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;favoriteMap&quot;&gt;\n        SELECT o.rid,o.DATE,u.username,u.&#96;PASSWORD&#96;,u.&#96;NAME&#96;,u.birthday,u.sex,u.telephone,u.email FROM tab_favorite o, tab_user u where o.uid&#x3D;u.uid\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n&lt;!--    通过properties标签加载外部properties文件--&gt;\n    &lt;properties resource&#x3D;&quot;jdbc.properties&quot;&gt;&lt;&#x2F;properties&gt;\n    &lt;!--    自定义别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.Domain&quot; alias&#x3D;&quot;Domain&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.domain.Favorite&quot; alias&#x3D;&quot;favorite&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.domain.User&quot; alias&#x3D;&quot;user&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.dao.FavoriteMapper&quot; alias&#x3D;&quot;favoriteMapper&quot;&#x2F;&gt;\n        &lt;typeAlias type&#x3D;&quot;com.icarus.dao.UserMapper&quot; alias&#x3D;&quot;userMapper&quot;&#x2F;&gt;\n\n    &lt;&#x2F;typeAliases&gt;\n&lt;!--    注册数据类型转换器--&gt;\n&lt;!--    &lt;typeHandlers&gt;--&gt;\n&lt;!--        &lt;typeHandler handler&#x3D;&quot;com.icarus.utils.DateTypeHandler&quot;&gt;&lt;&#x2F;typeHandler&gt;--&gt;\n&lt;!--    &lt;&#x2F;typeHandlers&gt;--&gt;\n&lt;!--    数据源环境--&gt;\n    &lt;plugins&gt;\n        &lt;plugin interceptor&#x3D;&quot;com.github.pagehelper.PageHelper&quot;&gt;\n            &lt;property name&#x3D;&quot;dialect&quot; value&#x3D;&quot;mysql&quot;&#x2F;&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n&lt;!--    加载映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource&#x3D;&quot;com&#x2F;icarus.mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;\n        &lt;mapper resource&#x3D;&quot;com&#x2F;icarus.mapper&#x2F;FavariteMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt; \n\n\n&lt;&#x2F;configuration&gt;\n\n配置文件中 xmlns：context 是注解约束，使用注解开发配置文件要加入该约束。\n使用事务注解时如果代码内有trycatch会使事务失效\nMapper代理开发：\n1.接口所在位置必须和映射文件位置一致（如果xml文件放在resource，必须在resource创建跟接口一样的全限定名文件夹）\n2.接口名称必须和映射文件名称一致\n3.接口的全限定名必须和namespace 一致\n接口中的方法名 需要和对应的标签一致 id 一样\n多个实现类如何注入？\n如果一个接口有两个实现类 ，在autowied注入时，在@Autowied下面加个@Qualifier （”要使用的实现类”）\n@Repository（value&#x3D;“daoRedis”）\npublic class IUserDaoImpl2 implements IUserDao&#123;\n代码~\n&#125;\n\n\n\n@Autowired\n\n@Qualifier（value&#x3D;“daoRedis”）\n\nprivate IUserDao userDao；\n\n也可以用jdk自带的注解@Resource 替代@Qualifier，使用方法：@Resource (name=“daoMyBatis” )\n如果jdk版本过高（14 15） @Resource 可能有版本冲突问题 \n要把除了三层架构外的类放到spring容器中，使用@Component注解\n@Component(“pb”)  //给这个bean设置一个key名字，spring容器都是map key-value\npublic class Product( ){\n}\n点进注解，如果里面有value属性，value就可以省略，如 @Component(value=”pb”)——&gt; @Component(“pb”) \n@Value 注解内部：\npublic @interface Value&#123;\n\n​\t\tString value()；\n\n&#125;\n\n纯注解开发：\n&#x2F;&#x2F;配置类 代替配置文件 beans 后面的约束\n@Configuration\n@ComponentScan(value &#x3D; &quot;com.icis&quot;)&#x2F;&#x2F;代替包扫描\n@Import(value &#x3D; &#123;SpringJdbcConfiguration.class,\n        SpringMapperConfigurarion.class&#125;)\npublic class SpringConfiguration &#123;\n\n@Bean 把方法的返回值放到spring容器中\n该注解只能写在方法上，表明使用此方法创建一个对象，并且交给spring管理\n举例:  将jdbcTemplate放到容器中\n@Bean\npublic JdbcTemplate getJdbcTemplate(){\nJdbcTemplate jdbcTemplate = new JdbcTemplate();\nreturn jdbcTemplate;\n}\n如果有多个数据源，在配置类参数使用@Qualifier(“ “)来指定\n&#x2F;&#x2F;配置类 代替配置文件 beans 后面的约束\n@Configuration\n@ComponentScan(value &#x3D; &quot;com.icis&quot;)\n@Import(value &#x3D; &#123;SpringJdbcConfiguration.class,\n        SpringMapperConfigurarion.class&#125;)\npublic class SpringConfiguration &#123;\n    &#x2F;&#x2F; 创建一个jdbdTemplate 放入到spring 容器\n    @Bean(name &#x3D; &quot;temp1&quot;)\n    public JdbcTemplate getTemplate(@Qualifier(&quot;druidDs1&quot;) DataSource ds)&#123;&#x2F;&#x2F; 方法形参  会去容器中找\n        JdbcTemplate jdbcTemplate&#x3D;new JdbcTemplate(ds);\n        return  jdbcTemplate;\n    &#125;\n\n&#125;\n    &#x2F;&#x2F; 定义方法 创建数据源\n    @Bean(name &#x3D; &quot;druidDs1&quot;)\n    public DataSource getDruidDs2()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\t\n    @Bean(name &#x3D; &quot;druidDs2&quot;)\n    public DataSource getDruidDs1()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\n\n&#x2F;&#x2F; 如果需要加载类路径下文件 需要在文件名前加  classpath:\n@PropertySource(value &#x3D; &quot;classpath:db.properties&quot;)\npublic class SpringJdbcConfiguration &#123;\n    &#x2F;&#x2F; 配置数据库相关操作\n    &#x2F;&#x2F; 注入配置文件中数据 需要使用springEl $&#123;key&#125;\n    @Value(&quot;$&#123;db.driverClassName&#125;&quot;)\n    private String driverClassName;\n    @Value(&quot;$&#123;db.url&#125;&quot;)\n    private String url;\n    @Value(&quot;$&#123;db.username&#125;&quot;)\n    private String username;\n    @Value(&quot;$&#123;db.password&#125;&quot;)\n    private String password;\n\nxml配置mysql\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop\nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd\n&quot;&gt;\n    &lt;!--包扫描--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.icis&quot;&#x2F;&gt;\n    &lt;!--加载属性文件--&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:db.properties&quot;&#x2F;&gt;\n &lt;!--配置两个bean DataSource JdbcTemplate--&gt;\n    &lt;bean id&#x3D;&quot;druidDs&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;db.driverClassName&#125;&quot;&#x2F;&gt;\n        &lt;!--@Value(&quot;$&#123;&#125;&quot;)--&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;db.url&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;db.username&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;db.password&#125;&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;bean id&#x3D;&quot;temp2&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;druidDs&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n纯注解配置mysql：\n\n&#x2F;&#x2F;主配置类 代替配置文件 beans 后面的约束\n@Configuration\n@ComponentScan(value &#x3D; &quot;com.icis&quot;)\n@Import(value &#x3D; &#123;SpringJdbcConfiguration.class,\n        SpringMapperConfigurarion.class&#125;)\npublic class SpringConfiguration &#123;\n    &#x2F;&#x2F; 创建一个jdbdTemplate 放入到spring 容器\n    @Bean(name &#x3D; &quot;temp1&quot;)\n    public JdbcTemplate getTemplate(@Qualifier(&quot;druidDs1&quot;) DataSource ds)&#123;&#x2F;&#x2F; 方法形参  会去容器中找\n        JdbcTemplate jdbcTemplate&#x3D;new JdbcTemplate(ds);\n        return  jdbcTemplate;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;副配置类\n&#x2F;&#x2F; 如果需要加载类路径下文件 需要在文件名前加  classpath:\n@PropertySource(value &#x3D; &quot;classpath:db.properties&quot;)\npublic class SpringJdbcConfiguration &#123;\n    &#x2F;&#x2F; 配置数据库相关操作\n    &#x2F;&#x2F; 注入配置文件中数据 需要使用springEl $&#123;key&#125;\n    @Value(&quot;$&#123;db.driverClassName&#125;&quot;)\n    private String driverClassName;\n    @Value(&quot;$&#123;db.url&#125;&quot;)\n    private String url;\n    @Value(&quot;$&#123;db.username&#125;&quot;)\n    private String username;\n    @Value(&quot;$&#123;db.password&#125;&quot;)\n    private String password;\n\n\n\n    &#x2F;&#x2F; 定义方法 创建数据源\n    @Bean(name &#x3D; &quot;druidDs1&quot;)\n    public DataSource getDruidDs2()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\n\n    @Bean(name &#x3D; &quot;druidDs2&quot;)\n    public DataSource getDruidDs1()&#123;\n        DruidDataSource ds&#x3D;new DruidDataSource();\n        &#x2F;&#x2F; 设置数据库连接属性\n        ds.setDriverClassName(driverClassName);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n\n        return  ds;\n    &#125;\n&#125;\n&#x2F;&#x2F;副配置类\n&#x2F;&#x2F; 映射器  bean-json 配置类\npublic class SpringMapperConfigurarion &#123;\n\n    @Bean\n    public ObjectMapper objectMapper()&#123;\n        return  new ObjectMapper();\n    &#125;\n&#125;\n\n\n将ObjectMapper注册（放）到spring，\n注解方式:\n&#x2F;&#x2F; 映射器  bean-json 配置类\npublic class SpringMapperConfigurarion &#123;\n\n    @Bean\n    public ObjectMapper objectMapper()&#123;\n        return  new ObjectMapper();\n    &#125;\n&#125;\n\nspring整合junit 为什么要整合？\n因为spring和junit是两个环境或者说是两个容器，一个容器去另一个容器取东西必须做整合\n所以maven要引入 spring-test这个包\nspring整合junit 整合步骤：\n\nmaven引入spring-test这个包\n\n在测试类上添加两个注解\n\n```java@RunWith(SpringJUnit4ClassRunner.class)//spring-test带的@ContextConfiguration(classes = SpringConfiguration.class)//主配置类public class EmployeeTest1 {\n@Autowired\nprivate EmployeeController employeeController;\n@Test\npublic void getEmpListTest1()&#123;\n    String empJson = this.employeeController.getEmpJson();\n    System.out.println(&quot;获得数据是：&quot;+empJson);\n&#125;\n\n}\n\n转换json的两个实体注解：\n\n&#96;&#96;&#96;java\n&#x2F;&#x2F;  @JsonIgnore 忽略该字段转换json\n  private Double salary;\n  &#x2F;&#x2F; 默认  显示的毫秒值\n  @JsonFormat(pattern &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;,timezone &#x3D; &quot;GMT+8&quot;)\n  private Date joinDate;\n\nObjectMapper   xml的配置方法：\n\n&#x2F;&#x2F;执行分页操作\nPage&lt;s&gt; pageBean &#x3D; PageHelper.startPage(currentPage, pageSize);","slug":"Spring","date":"2021-10-07T14:32:21.000Z","categories_index":"java","tags_index":"Spring","author_index":"icarus"},{"id":"cf3ece25eb219b32904f64404ccf8150","title":"Jquery和原生js的区别","content":"Jquery 和 原生js（1）选中dom对象\ndocument.getElementsByClassName(“one”)[0] =$(“.one”)\ndocument.getElementsByTagName(“div”)[0] =$(“.div”)\ndocument.getElementId(“two”) =$(“#two”)\n（2）初始化方式（入口函数）\nwindow.onload = function(ev){ } = \n​        $(document).ready(function( ) { undefined } );\n​        $(function( ) { undefined } );\n（3）DOM 对象转 jQuery 对象\nvar dom = document.getElementById(“IMOK”);\nvar $dom = $(dom)\n","slug":"Jquery 和 原生js","date":"2021-09-07T14:32:21.000Z","categories_index":"javascript","tags_index":"JavaScript","author_index":"icarus"},{"id":"bb75e9d1c3429d83254e84314ef5ffe1","title":"java基础","content":"继承方法的覆盖重写1.必须保证父子类之间方法的名称相同，参数列表也相同；\n@Override，写在方法签名，用来检测是不是有效的正确覆盖重写。\n写不写都行，写了可以验证一下方法名是否与父类方法对应。\n2.子类方法的返回值必须小于等于父类方法的返回值范围\npublic class Zi extends Fu&#123;\n    @Override\n    public String method()&#123;\n        return null;\n    &#125;\n&#125;\n\npublic class Fu &#123;\n    public Object method()&#123;\n        return null;\n    &#125;\n&#125;\n\n返回值范围：Object&gt;String\n注：所有的引用类型（Object、String等）都可以用null作返回值。\n3.子类方法的权限必须大于等于父类方法的权限修饰符。\npublic &gt; protected &gt; (default) &gt; private\n（default ）不是关键字default，而是不写修饰符，留空。\n4.子类必须调用父类构造方法\n5.super的子类调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。\n6.子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定super调用，super只能有一个，还必须是第一个。\n7.this(…)调用也必须是构造方法的第一个语句，唯一一个。\nsuper和this两种构造调用，不能同时使用。\n继承的三个特点java语言是单继承的，一个类的直接父类只能有唯一一个\njava语言可以多级继承，一个父类可以拥有很多个子类\nclass A&#123;&#125;\nclass B extends A&#123;&#125;&#x2F;&#x2F;正确\nclass C extends B&#123;&#125;&#x2F;&#x2F;正确\n\n抽象方法如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法\n抽象方法：加上abstract 关键字，然后去掉大括号，直接分号结束。\n抽象类：抽象方法所在的类，必须是抽象类，在class前加上abstract。\n如何使用抽象类和抽象方法：\n1.必须用一个子类来继承抽象父类\n2.子类必须覆盖重写抽象父类当中的所有抽象方法。子类去掉抽象方法的abstract关键字，然后补上方法体大括号。\n面试题：\n抽象类可以被实例化吗？\n抽象类其实是可以被实例化的，但是它的实例化方式并不是通过普通的 new 方式来创建对象，而是通过父类的应用来指向子类的实例间接地实现父类的实例化，因为子类在实例化之前，一定会先实例化它的父类。 … 注意：接口与抽象类非常类似，但是它不可以被实例化，因为接口压根没有构造函数\n注意事项1.不能直接创建抽象类对象，之恶能创建非抽象子类的对象\nps：加入创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\n2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\n3.抽象类不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n4.抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类。\n接口接口就是一种公共的规范标准。\n接口是一种引用数据类型，最重要的内容是其中的抽象方法\n接口中可以包含的内容有：\n\n常量 （java7）\n\n抽象方法（java7）\n\n默认方法（java8）\n\n静态方法（java8）\n\n私有方法（java9）\n1.普通私有方法，解决多个默认方法之间重复代码问题\n格式：private 返回值类型 方法名称（参数列表）{方法体}\n2.静态私有方法：解决多个静态方法之间重复代码问题\n格式：private static 返回值类型 方法名称（参数列表）{方法体}\n\n\n接口当中的抽象方法，修饰符必须是两个固定的关键字：\npublic abstract，所以写不写修饰符都一样\n接口的使用步骤：\n\n接口必须有一个实现类来实现该接口\n\n接口的实现类必须覆盖重写接口中的所有抽象方法\n去掉方法的abstract关键字，然后补上方法体大括号。\n\n创建实现类的对象进行使用。\n不能通过接口实现类的对象来调用接口当中的静态方法，可以通过接口名称直接调用其中的静态方法。\n多接口的注意事项\n一个类的直接父类是唯一的，但一个类可以实现多个接口\n如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。\n如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。\n如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。\n一个类如果实现父类当中的方法，和接口当中的默认方法产生了冲突，则优先用父类当中的方法。\n接口是没有静态代码块或者构造方法的。\n多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，而且带着default关键字。\n\n\n\n多态父类引用指向子类对象。\n格式：父类名称 对象名 = new 子类名称（）；\n或者 接口名称 对象名 = new 实现类名称（）；\n访问成员变量的两种方式：\n\n直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找\n\npublic class Fu &#123;\n    int num &#x3D; 10;\n&#125;\npublic class Zi extends Fu&#123;\n    int num &#x3D; 20;\n&#125;\nFu obj &#x3D; new Zi(); &#x2F;&#x2F;输出10\n\n\n间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找\n\n在多态的代码中，成员方法的访问规则是：\n看new的是谁，就优先用谁，没有则向上找\n口诀：编译看左边，运行看右边\n成员变量：编译看左边，运行还看左边\n成员方法：编译看左边，运行看右边\n向上转型对象的向上转型，就是多态的写法：父类引用指向子类对象。\n向上转型一定是安全的。\n向下转型其实是一个还原动作\n格式：子类名称 对象名 = （子类名称）父类对象；\n即将父类对象还原为本来的子类对象。\n向下转型要先进行判断，使用instanceof 关键字进行类型判断  返回boolean\nfinal当final关键字用来修饰一个方法的时候，该方法不能被覆盖重写。\n对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。\n内部类类似于身体于心脏的关系\n格式： \n修饰符 class 外部类名称{\n​    修饰符 class 内部类名称{\n​         }\n}\n内用外，随意访问；外用内，需要内部类对象。\n使用成员内部类的方法：\n\n间接方式，在外部类的方法当中，使用内部类，main只是调用外部类的方法。\n直接方式，公式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称\n\n在内部类方法访问外部类的成员变量\npublic class Body &#123;\n    public class Heart&#123;\n        int num &#x3D; 20;&#x2F;&#x2F;内部类的成员变量\n        public void methodHeart()&#123;\n            int num &#x3D; 40;\n            System.out.println(Body.this.num); &#x2F;&#x2F;在内部类访问外部类的成员变量\n            System.out.println(name+&quot;内部类的方法&quot;);\n        &#125;\n\n\n    &#125;\n    private String name;\n    int num &#x3D; 10;&#x2F;&#x2F;外部类的成员变量\n    public  void methodBody()&#123;\n        int num &#x3D; 30;&#x2F;&#x2F;外部类的方法的局部变量\n        Heart heart &#x3D; new Heart();\n        System.out.println(&quot;外部类的方法&quot;);\n        heart.methodHeart();\n\n    &#125;\n&#125;\n\n\n\n在外部类方法里定义的类叫做局部内部类\n定义一个类的时候，权限修饰符规则：\n\n外部类：public / （default）\n\n成员内部类：public / protected / (default) / private\n\n局部内部类，什么都不能写。\n匿名内部类如果接口的实现类或者是父类的子类只需要使用一次，这种情况可以省略掉该类的定义，而改为使用匿名内部类。\n\n\nObject看一个类是否重写了toString方法，直接打印这个类对应对象名字即可\n如果没有重写toString方法，那么打印的就是对象的地址值（默认）\n如果重写toString方法，那么就按照重写的方式打印。\nequals方法，默认比较两个对象的地址值。\n\nObject类介绍：是所有类的父类，一个类都会直接或者间接地继承自该类，该类中提供了一些非常常用的方法\n\ntoString()方法\n作用：打印对象信息\n重写前：打印的是包名类名@地址值\n重写后：打印的是对象中的属性值\n\nequals()方法\n作用：比较两个对象\n重写前：比较的是对象的地址值\n重写后：比较的是对象中的属性值\n\n\nObjectsequals()方法：\n比较两个对象是否相同，但是增加了一些健壮性的判断！\nObject.equals（a,b）\nDate类long getTime()\n返回自1970年1月1日 00:00:00 GMT以来此Date对象表示的毫秒数\nDate类的带参构造方法：\n​    Date(long date) ：传递毫秒值，把毫秒转换为Date日期\nDate类的空参构造方法：\n​    Date()获取的是当前系统的日期和时间\nStringBuilder成员方法：\npublic StringBuilder append（…）：添加任意类型的字符串形式，并返回当前对象自身。\n参数：可以是任意数据类型。\n装箱和拆箱拆箱：在包装类中取出基本数据类型的数据（包装类-&gt;基本类型的数据）\n成员方法：int intValue() 以int 类型返回该Integer的值\n装箱：把基本类型的数据，包装到包装类中（基本类型的数据-&gt;包装类）\n如果方法上有横线，说明方法过时了\n静态方法：\nstatic Integer valueOf(int i) 返回一个表示指定的int值的Integer实例\nstatic Integer valueOf（String s）返回保存指定的String的值的Integer对象。\n集合框架学习目标：\n\n会使用集合存储数据\n会遍历集合，把数据取出来\n掌握每种集合的特性\n\n学习方式：\n\n学习顶层：学习顶层接口/抽象类中共性的方法，所有的子类都可以使用\n使用底层：底层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用\n\nCollection 接口：\n定义的是所有单列集合中共性的方法\n所有的单列集合都可以使用共性的方法\n没有带索引的方法\nList接口：\n\n有序的集合（存储和取出元素顺序相同）\n允许存储重复的元素\n有索引，可以使用普通的for循环遍历\n\nSet接口：\n\n不允许存储重复元素\n\n没有索引（不能使用普通的for循环遍历）\nTreeSet集合和HashSet集合：\n无序的集合（存储和取出元素的顺序有可能不一致）\n\n\nLinkedHashSet集合：有序的集合\n\n共性的方法：\npublic boolean add(E e)：把给定的对象添加到当前集合中\npublic void clear()：清空集合中所有的元素\npublic boolean remove(E e)：把给定的对象在当前集合中删除\npublic boolean contains(E e)：判断当前集合中是否包含给定的对象\npublic boolean isEmpty()：判断当前集合是否为空\npublic int size()：返回集合中元素的个数\npublic Object[] toArray() 把集合中的元素存储到数组中\n迭代器：通用的取出集合的方法。主要针对没有索引的集合。\n方法：\n使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）\n注意：Iterator接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型。\nhasNext() 如果仍有元素可以迭代，则返回true\nnext() 返回迭代的下一个元素，一旦执行就会取出一个元素\nremove() 从迭代器指向的collection中移除迭代器返回的最后一个元素\nforeach增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，是JDK1.5之后出现的新特性，用来遍历集合或数组\nCollection extends Iterable ：所有的单列集合都可以使用增强for\npublic interface Iterable 实现这个接口允许对象成为”foreach”语句的目标\n格式：\nfor(集合/数组的数据类型 变量名 ： 集合名/数组名){\nsout(变量名);\n}\npublic class Demo02Foreach{\n}\n泛型创建集合对象，使用泛型的好处：\n\n避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型\n\n把运行期异常（代码运行后会抛出的异常），提升到了编译器（写代码的时候会报错）\n不确定用什么数据类型的时候，可以使用泛型  E\n\n\n定义含有泛型的方法：泛型定义在方法的修饰符和返回值类型之间\n格式：\n​    修饰符&lt;泛型&gt;返回值类型  方法名 ( 参数列表(使用泛型) ){\n​    方法体；\n}\n含有泛型的方法，在调用方法的时候确定泛型的数据类型\n传递什么类型的参数，泛型就是什么类型\n泛型的通配符？：代表任意的数据类型\n使用方式：\n​        不能创建对象使用\n​        只能作为方法的参数使用\nListArrayList查询快增删慢\nLinkedListLinkedList 集合的特点：\n\n底层是一个链表结构：查询慢，增删快\n\n里边包含了大量操作首尾元素的方法\n注意：使用LinkedList集合特有的方法，不能使用多态\n\n\npublic void addFirst(E e) ：将指定元素插入到列表的开头\npublic void addList(E e)：将指定元素添加到此列表的结尾\npublic void push(E e)：将元素插入此列表所表示的堆栈\npublic E getFirst()：返回此列表的第一个元素\npublic E getLast()：返回此列表的最后一个元素\npublic E removeFirst()：移除并返回此列表的第一个元素\npublic E removeLast()：移除并返回此列表的最后一个元素\npublic E pop()：从此列表所表示的堆栈处弹出一个元素\nHashSet特点：\n\n不允许存储重复的元素\n\n没有索引，没有带索引的方法，也不能使用普通的for循环遍历\n\n是一个无序的集合，存储元素和取出元素的顺序有可能不一致\n\n底层是一个哈希表结构（查询的速度非常的快）\nHashSet是implement Set接口，Set接口只有以上1、2特点。\n\n\n存储数据的结构（哈希表）\njdk 1.8 版本之前： 哈希表=数组+链表\njdb 1.8版本之后 ：\n​                                哈希表=数组+链表；\n​                                哈希表=数组+红黑树（提高查询的速度）\n哈希表的特点：速度快\nSet集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否被重复\n可变参数是jdk 1.5之后出现的新特性\n使用前提：\n​        当方法的参数列表数据类型已经确定，但参数的个数不确定，就可以使用可变参数\n使用格式：方法定义时使用\n​    修饰符 返回值类型 方法名 （ 数据类型…变量名）{}\n可变参数的原理：\n​        可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数可以是0或多个。\n一个方法的参数列表，只能有一个可变参数。\n如果方法的参数有多个，可变参数必须写在末尾。\npublic static void method(String a,double b,int...c)\n\npublic class Demo4VarArgs &#123;\n    public static void main(String[] args) &#123;\n        int i &#x3D; add(55,44,55,66,55,7);\n        System.out.println(i);\n    &#125;\n    public static int add(int... arr) &#123; &#x2F;&#x2F;[I@1b6d3586底层是数组\n\n        int sum &#x3D; 0;\n        for (int i : arr) &#123;\n            sum +&#x3D; i;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n\n对象排序java.utils.Collections 是集合工具类，用来对集合进行操作，部分方法如下：\npublic static  void sort(List list)：将集合中元素按照默认规则排序\n注意：sort(List list)使用前提\n被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法comparaTo定义的排序规则\nComparable 接口的排序规则：\n自己(this)-参数：升序\n实体类：   \n@Override\npublic int compareTo(Employee o) &#123;\n        return this.getSalary()-o.getSalary();\n    &#125;\n主方法：\nCollections.sort(list);\n\nMap集合特点：\n\nMap集合是一个双列集合，一个元素包含两个值（一个key，一个value）\nMap集合中的元素，key和value的数据类型可以相同，也可以不同\nMap集合中的元素，key是不允许重复的，value是可以重复的\nMap集合中的元素，key和value是一一对应的。\n\njava.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口\nHashMap集合的特点：\n\nHashMap集合底层是哈希表：查询的速度特别快\n​        jdk1.8之前：数组+单向链表\n​       jdk1.8之后：数组+单向链表/红黑树（链表的长度超过8）：提高查询的速度\n\nhashMap是一个无序的集合，存储元素和取出元素的顺序可能不一致\n\n\njava.util.LinkedHashMap&lt;k,v&gt;集合，extends HashMap&lt;k,v&gt;集合\nLinkedHashMap的特点：\n\nLinkedHashMap集合底层是哈希表+链表（保证迭代的顺序）\nLinkedHashMap集合是一个有序的集合，存储元素和取出元素的顺序有可能不一致\n\n\npublic class Demo5Map &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;盲僧&quot;,1);\n        map.put(&quot;盖伦&quot;,2);\n        map.put(&quot;亚索&quot;,3);\n        &#x2F;&#x2F;使用map集合中的方法keySet()，把map集合中所有的key取出来存到Set集合中\n        Set&lt;String&gt; set &#x3D; map.keySet();\n        Iterator&lt;String&gt; it &#x3D; set.iterator();\n        while(it.hasNext())&#123;\n            String key &#x3D; it.next();\n            &#x2F;&#x2F;通过Map集合中的方法get(key),通过key找到value\n            Integer value &#x3D; map.get(key);\n            System.out.println(key+value);\n\n        &#125;\n    &#125;\n&#125;\n\n第二种遍历方式\nmap集合中的方法：\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图\n实现步骤：\n1.使用map集合中的方法entrySet()，把Map集合中的多个Entry对象取出来，存储到一个Set集合中\n\n2.历Set集合，获取每一个Entry对象\n\n3.使用entry对象中的方法getKey()和getValue()获取键和值\n\nMap&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(&quot;盲僧&quot;,1);\n    map.put(&quot;盖伦&quot;,2);\n    map.put(&quot;亚索&quot;,3);\n    &#x2F;&#x2F;1.使用map集合中的方法entrySet()，把Map集合中的多个Entry对象取出来，存储到一个Set集合中\n    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set &#x3D; map.entrySet();\n    &#x2F;&#x2F;2.历Set集合，获取每一个Entry对象\n    &#x2F;&#x2F;使用迭代器遍历Set集合\n    Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it  &#x3D; set.iterator();\n    while(it.hasNext()) &#123;\n        Map.Entry&lt;String, Integer&gt; entry &#x3D; it.next();\n        &#x2F;&#x2F;3.使用entry对象中的方法getKey()和getValue()获取键和值\n        String key &#x3D; entry.getKey();\n        Integer value &#x3D; entry.getValue();\n        System.out.println(key + &quot;-&quot; + value);\n        System.out.println(&quot;-------------------&quot;);\n    &#125;\n\nhashTable\n\njdk9新特性：\nList接口，Set接i口，Map接口：里边增加了一个静态的方法of，可以给集合一次行添加多个元素\nstatic  List of ( E…element)\n使用前提：\n​        当集合中存储的元素的个数已经确定了，不再改变时使用。\n注意：\n\nof方法只适用于List接口，Set接i口，Map接口，不适用于接口的实现类\nof方法的返回值是一个不能改变的结合，集合不能再使用add，put方法添加元素，会抛出异常\nSet接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常。\n\nMap.get () 方法：返回指定键所映射的值\nss\nServlet\n\n\n\nrequest对象和response对象的原理：\n\nrequest和response对象是由服务器创建的，我们来使用他们\n\nrequest对象是来获取请求消息的，response对象是设置响应消息的\n\n\nrequest功能\n\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    &#x2F;&#x2F;1.获取请求方式：GET\n    String method &#x3D; request.getMethod();\n    System.out.println(method);\n    &#x2F;&#x2F;2.（*重点）获取虚拟目录：&#x2F;day14\n    String contextPath &#x3D; request.getContextPath();\n    System.out.println(contextPath);\n    &#x2F;&#x2F;3.获取Servlet路径 ：&#x2F;demo1\n    String servletPath &#x3D;request.getServletPath();\n    System.out.println(servletPath);\n    &#x2F;&#x2F;4.获取get方法请求参数：name &#x3D; zhangsan\n    String queryString &#x3D; request.getQueryString();\n    System.out.println(queryString);\n    &#x2F;&#x2F;5.(*重点)获取请求URI：&#x2F;day14&#x2F;demo1\n    String requestURI &#x3D; request.getRequestURI();\n    StringBuffer requestURL&#x3D; request.getRequestURL();\n    System.out.println(requestURI);\n    System.out.println(requestURL);\n    &#x2F;&#x2F;6.获取协议及版本：HTTP&#x2F;1.1\n    String protocol &#x3D; request.getProtocol();\n    System.out.println(protocol);\n    &#x2F;&#x2F;7.获取客户机的IP地址\n    String remoteAddr &#x3D; request.getRemoteAddr();\n    System.out.println(remoteAddr);\n&#125;\n\n获取请求头数据：\n方法：\n​    String getHeader(String name):通过请求头的名称获取请求头的值\n   Enumeration getHeaderNames( );获取所有的请求头名称\n\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n&#x2F;&#x2F;获取请求消息体--请求参数\n    &#x2F;&#x2F;1.获取字符流\n    BufferedReader br &#x3D; request.getReader();\n    &#x2F;&#x2F;2.读取数据\n    String line &#x3D; null;\n    while((line&#x3D; br.readLine())!&#x3D;null)&#123;\n        System.out.println(line);\n    &#125;\n&#125;\n\n&lt;form action&#x3D;&quot;&#x2F;requestDemo5&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type &#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入用户名&quot; name &#x3D; &quot;username&quot;&gt; &lt;br&gt;\n    &lt;input type &#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入密码&quot; name&#x3D;&quot;password&quot;&gt; &lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt;\n&lt;&#x2F;form&gt;\n\n 其他功能：\n\n获取请求参数通用方式\n\nString getParameter(String name)：根据参数名称获取参数值 username=zs&amp;password=123\nString username &#x3D; request.getParameter(&quot;username&quot;);\nString[] getParameterValues(String name)：根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game\nString[] choose &#x3D; request.getParameterValues(&quot;hobby&quot;);\n\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;game&quot;&gt;游戏\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;study&quot;&gt;学习\nEnumeration getParameterNames()：获取所有请求的参数名称\n\nMap&lt;String，String[]&gt; getParameterMap()：获取所有参数的map集合\n    Map&lt;String,String[]&gt; parameterMap &#x3D; request.getParameterMap();\n    Set&lt;String&gt; keyset &#x3D; parameterMap.keySet();\n    for (String s : keyset) &#123;\n        String[] value &#x3D; parameterMap.get(s);\n        System.out.println(s);\n        for (String value2 : value) &#123;\n            System.out.println(value2);\n        &#125;\n        System.out.println(&quot;----------------------&quot;);\n\n    &#125;\n&#125;\n\n\n请求转发\nRequestDispatcher requestDispatcher &#x3D; request.getRequestDispatcher(&quot;&#x2F;requestDemo9&quot;);\nrequestDispatcher.forward(request,response);\n   \n\n\n\n共享数据\n\n\n获取ServletContext\nServletContext getServletContext()\n\n\n。。\n中文乱码问题：\nrequest.setCharacterEncoding(&quot;utf-8&quot;);\n\n\nresponse\n\n响应体：传输的数据\n\n重定向\n\n\n转发不需要写虚拟目录\n重定向需要写虚拟目录\n路径写法：\n\n\n字节流一般输出图片。\n3.服务器输出字节数据到浏览器\n4.验证码：\n​            1.本质：图片\n​            2.防止恶意表单注册\nServletContext对象1.概念：代表整个web应用，可以和程序的容器（服务器）来通信\n2.功能：\n​        1.获取MIME类型\n​        2.域对象：共享数据\n​        3.获取文件的真实（服务器）路径\nServletContext对象获取：\n​        1.通过request对象获取\n​                request.getServletContext();\n​        2.通过HttpServlet获取\n​                this.getServletContext()；\n​        3.功能：\n​            1.获取MIME类型\n​                *MIME类型：在互联网通信过程中定义的一种文件数据类型\n​                    *格式：大类型/小类型  text/html   image/jpeg\n​                *获取：String getMimeType（String file）\n​            2.域对象：共享数据\n​                1.setAttribute（String name，Object value）\n​                2.getAttribute（String name）\n​                3.removeAttribute（String name）\n​                *ServletContext对象范围：所有用户所有请求的数据 \n​            3.获取文件的真实（服务器）路径\n\n反射框架设计的灵魂\n框架：半成品软件。可以在框架的基础上进行软件开发，简化编码\n反射：将类的各个组成部分封装成其他对象，这就是反射机制。\n好处：1.可以在程序运行过程中，操作这些对象\n​            2.可以解耦，提高程序的可扩展性\n获取Class对象的方式：\n\nClass.forName(“全类名”)；将字节码文件加载进内存，返回Class对象\n类名.class，通过类名的属性class获取\n对象.getClass().getClass()方法在Object类中定义着\n\n反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。\n流try()中定义流对象，会自动关流\n字符流 FileReader FileWriter 操作单位时字符，一个一个读和写 一组一组读和写\n字节流 FileInputStream FileOutputStream 数据底层皆为字节\n序列化流 前置条件：实现接口 Serialiable ObjectOutputStream ObjectInputStream 方便网络或文件中传递\n转换流：OutputStreamWriter InputStreamReader 指定编码读写\n字符缓冲流：BufferedReader .readline() BufferedWriter  writeline()\n注解Deprecated 表示已过时\nSuppresWarnings 压制警告\n​    一般传递参数all @SuppresWarnings(“all”)\n自定义注解\n\n多线程Thread和Runnable的区别\n实现Runnable接口创建多线程程序的好处：\n\n适合多个相同的程序代码的线程去共享同一个资源\n\n可以避免java中的单继承的局限性。\n\n增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立\n\n线程池只能放入实现Runabl或Callable类线程，不能直接放入继承Thread的类。​    增强了程序的扩展性，降低了程序的耦合性（解耦）\n​    实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）\n​    实现类中，重写了run方法：用来设置线程任务\n​    创建Thread类对象，调用start方法，用来开启新线程\n\n\n线程安全问题public class Ticket &#123;\n    public static void main(String[] args) &#123;\n        RunnableImpl run &#x3D; new RunnableImpl();\n        Thread t0 &#x3D; new Thread(run);\n        Thread t1 &#x3D; new Thread(run);\n        Thread t2 &#x3D; new Thread(run);\n        t0.start();\n        t1.start();\n        t2.start();\n\n    &#125;\n&#125;\n\npublic class RunnableImpl implements Runnable&#123;\n    private int ticket &#x3D; 100;\n    @Override\n    public void run() &#123;\n        while(true)&#123;\n            if(ticket&gt;0)&#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);\n                   ticket--;\n            &#125;\n&#125;\n    &#125;\n&#125;\n\nThread-0–&gt;正在卖第100张票Thread-2–&gt;正在卖第100张票Thread-1–&gt;正在卖第100张票Thread-0–&gt;正在卖第97张票\n…\nThread-2–&gt;正在卖第2张票Thread-1–&gt;正在卖第1张票Thread-0–&gt;正在卖第1张票Thread-2–&gt;正在卖第-1张票\n三个线程抢cpu执行，导致负票和打印同一张票。\n线程是处理机调度的单位，进程是资源分配的单位\n线程同步synchronized\n在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决线程不安全问题。\n同步操作：\n\n同步代码块\n\n&#x2F;&#x2F;创建一个锁对象\nObject obj &#x3D; new Object();\n\n@Override\npublic void run() &#123;\n    while (true) &#123;\n        synchronized (obj) &#123;\n            if (ticket &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                ticket--;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n同步方法\n使用步骤：\n1.把访问了共享数据的代码抽取出来，放到一个方法中\n2.在方法上添加synchronized修饰符\n格式：  修饰符 synchronized 返回值类型 方法名(参数列表){\n可能会出现线程安全问题的代码}\n同步方法的锁对象是谁？\n就是实现类对象 new RunnableImpl()\n也就是this\n静态方法private static int ticket &#x3D; 100;\n    &#x2F;&#x2F;创建一个锁对象\n    Object obj &#x3D; new Object();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            payTicket();\n\n        &#125;\n    &#125;\n\npublic static synchronized void payTicket() &#123;\n            if (ticket &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                ticket--;\n            &#125;\n    &#125;\n\n静态的同步方法\n不能是this ， this是创建对象后产生的\n锁对象是本来的class属性–&gt;class文件对象（反射）\n\n锁机制\nLock实现提供了 比使用synchronized方法和语句可获得的更广泛的锁定操作\nLock接口中的方法：\nvoid lock()获取锁。\nvoid unlock()释放锁\njava.util.concurrent.locks.ReentrantLock implements Lock接口\n\n\n\npublic class RunnableImpl implements Runnable &#123;\n    private int ticket &#x3D; 100;\n    Lock l &#x3D; new ReentrantLock();\n    &#x2F;&#x2F;创建一个锁对象\n    Object obj &#x3D; new Object();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            l.lock();\n\n                if (ticket &gt; 0) &#123;\n                    try &#123;\n                        Thread.sleep(10);\n                        System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                        ticket--;\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;finally &#123;\n                        l.unlock();\n                    &#125;\n\n                &#125;\n\n        &#125;\n    &#125;\n&#125;\n\n线程状态new ：new Thread() new Thread子类()\nrunnable\nwait\nnotify\n线程池使用步骤：\n\n使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池\n创建一个类，实现Runnable接口，重写run方法，设置线程任务\n调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法\n调用ExecutorService中的方法shutdown销毁线程池（不建议执行）\n\npublic class ThreadPool &#123;\n    public static void main(String[] args) &#123;\n        ExecutorService es &#x3D; Executors.newFixedThreadPool(2);\n        es.submit(new RunnableImpl());\n        es.submit(new RunnableImpl());\n        es.shutdown();\n    &#125;\n&#125;\n\nll\nCookie\n\n@WebServlet(&quot;&#x2F;cookieDemo2&quot;)\npublic class CookieDemo2 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request, response);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        Cookie[] cs &#x3D; request.getCookies();\n        if(cs!&#x3D;null)&#123;\n            for (Cookie c : cs) &#123;\n                String name &#x3D; c.getName();\n                String value &#x3D; c.getValue();\n                System.out.println(name+&quot;:&quot;+value);\n            &#125;\n        &#125;\n        \n    &#125;\n&#125;\n\n@WebServlet(&quot;&#x2F;cookieDemo1&quot;)\npublic class CookieDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request, response);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        Cookie c &#x3D; new Cookie(&quot;msg&quot;,&quot;hello&quot;);\n        response.addCookie(c);\n    &#125;\n&#125;\n\n3.实现原理\n基于响应头set-cookie和请求头cookie实现 \n\nJSP原理本质是一个Servlet\n\njsp的脚本：jsp定义java代码的方式\n\n&lt;% 代码 %&gt;\n\n&lt;%! 代码 %&gt;\n\n&lt;%= 代码 %&gt;\n\n\n\njsp的内置对象\n\nSession\n3.原理：Session的实现是依赖于Cookie的\n\n\n\n\njsp\n\n\nEL表达式\n\n\n获取对象、List集合、Map集合的值\n\n隐式对象：\nel表达式有11个隐式对象\npageContext：\n获取jsp其他八个内置对象\n${pageContext.request.contextPath}：动态获取虚拟目录\nJSTL\n\n&lt;%\n    request.setAttribute(&quot;number&quot;,3);\n%&gt;\n&lt;c:choose&gt;\n    &lt;c:when test&#x3D;&quot;$&#123;number&#x3D;&#x3D;3&#125;&quot;&gt;星期三&lt;&#x2F;c:when&gt;\n    &lt;c:otherwise&gt;数字有误&lt;&#x2F;c:otherwise&gt;\n&lt;&#x2F;c:choose&gt;\n\n\nforeach\n数据库连接池\npublic class JDBCUtils &#123;\n    private static DataSource ds;\n\n    static&#123;\n        try &#123;\n&#x2F;&#x2F;            导入jar包\n            Properties pro &#x3D; new Properties();\n&#x2F;&#x2F;            定义配置文件\n            InputStream is &#x3D; JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n&#x2F;&#x2F;            加载配置文件\n            pro.load(is);\n&#x2F;&#x2F;            获取连接池对象\n            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static DataSource getDataSource()&#123;\n        return ds;\n    &#125;\n&#x2F;&#x2F;    获取连接\n    public static Connection getConnection() throws SQLException&#123;\n        return  ds.getConnection();\n    &#125;\n&#125;\n\ndruid.properties\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test\nusername&#x3D;root\npassword&#x3D;123456\n    &#x2F;&#x2F;初始化连接对象数目\ninitialSize&#x3D;5\n    &#x2F;&#x2F; 最大连接数 10\nmaxActive&#x3D;10\n    &#x2F;&#x2F;最大等待时间 3s\nmaxWait&#x3D;3000\n\ntemplate\n数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB\n2. 什么数据库？\n    * 用于存储和管理数据的仓库。\n\n3. 数据库的特点：\n    1. 持久化存储数据的。其实数据库就是一个文件系统\n    2. 方便存储和管理数据\n    3. 使用了统一的方式操作数据库 -- SQL\n\n​    \n4. 常见的数据库软件\n    * 参见《MySQL基础.pdf》\n\nMySQL数据库软件1. 安装\n    * 参见《MySQL基础.pdf》\n2. 卸载\n    1. 去mysql的安装目录找到my.ini文件\n        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n    2. 卸载MySQL\n    3. 删除C:/ProgramData目录下的MySQL文件夹。\n    \n3. 配置\n    * MySQL服务启动\n        1. 手动。\n        2. cmd--&gt; services.msc 打开服务的窗口\n        3. 使用管理员打开cmd\n            * net start mysql : 启动mysql的服务\n            * net stop mysql:关闭mysql服务\n    * MySQL登录\n        1. mysql -uroot -p密码\n        2. mysql -hip -uroot -p连接目标的密码\n        3. mysql --host=ip --user=root --password=连接目标的密码\n    * MySQL退出\n        1. exit\n        2. quit\n\n    * MySQL目录结构\n        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;\n            * 配置文件 my.ini\n        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n            * 几个概念\n                * 数据库：文件夹\n                * 表：文件\n                * 数据：数据\n\n查询时去重：select distinct\n查询某两列的和： row1+row2，如果某列有null值 select row1+ifnull(row2,0) from table\n起别名：select row1+ifnull(row2,0) as add from table\n不等于： ！=  也可以用**&lt;&gt;**\n        -- 查询年龄22岁，18岁，25岁的信息\n        SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\n        SELECT * FROM student WHERE age IN (22,18,25);\n\n        -- 查询英语成绩为null\n        SELECT * FROM student WHERE english = NULL; -- 不对的！  null值不能使用 = （!=） 判断\n        SELECT * FROM student WHERE english IS NULL;\n        -- 查询英语成绩不为null\n        SELECT * FROM student WHERE english  IS NOT NULL;\n\n        -- 查询姓马的有哪些？ like\n            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n        -- 查询姓名第二个字是化的人\n            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n        -- 查询姓名是3个字的人\n            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n        -- 查询姓名中包含德的人\n            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n\n\n排序查询\n\n语法：order by 子句\n\norder by 排序字段1 排序方式1 ，  排序字段2 排序方式2…\n\n\n排序方式：\n\nASC：升序，默认的。\nDESC：降序。\n\n\n注意：\n\n如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。\n\n  – 按照性别分组。分别查询男、女同学的平均分,人数\n  SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\n\nwhere 和 having 的区别？\nwhere 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来\nwhere 后不可以跟聚合函数，having可以进行聚合函数的判断。\n\n\n\n\n\n\n分页查询\n语法：limit 开始的索引,每页查询的条数;\n\n公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数\n – 每页显示3条记录 \n SELECT * FROM student LIMIT 0,3; – 第1页\n SELECT * FROM student LIMIT 3,3; – 第2页\n SELECT * FROM student LIMIT 6,3; – 第3页\n\nlimit 是一个MySQL”方言”\n\n\n  外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。\n\n1. 在创建表时，可以添加外键\n   * 语法：\n     create table 表名(\n     \t....\n     \t外键列\n     \tconstraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n     );\n 举例：constraint emp_dept_fk foreign key (dep_id) references department(id)\n \n\n2. 删除外键\n   ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n3. 创建表之后，添加外键\n   ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\n\n\n```\n 级联操作\n 1. 添加级联操作\n     语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \n             FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;\n 2. 分类：\n     1. 级联更新：ON UPDATE CASCADE \n     2. 级联删除：ON DELETE CASCADE \n\n   \t\n  \t 多对多：\n  \t\t\t\t* 如：学生和课程\n  \t\t\t\t* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 \n\n# SQL\n\n\t1.什么是SQL？\n\t\tStructured Query Language：结构化查询语言\n\t\t其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\n\t\t\n\t2.SQL通用语法\n\t\t1. SQL 语句可以单行或多行书写，以分号结尾。\n\t\t2. 可使用空格和缩进来增强语句的可读性。\n\t\t3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n\t\t4. 3 种注释\n\t\t\t* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \n\t\t\t* 多行注释: &#x2F;* 注释 *&#x2F;\n\t\t\n\t3. SQL分类\n\t\t1) DDL(Data Definition Language)数据定义语言\n\t\t\t用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\n\t\t2) DML(Data Manipulation Language)数据操作语言\n\t\t\t用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\n\t\t3) DQL(Data Query Language)数据查询语言\n\t\t\t用来查询数据库中表的记录(数据)。关键字：select, where 等\n\t\t4) DCL(Data Control Language)数据控制语言(了解)\n\t\t\t用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\n\n## DDL:操作数据库、表\n\n\t1. 操作数据库：CRUD\n\t\t1. C(Create):创建\n\t\t\t* 创建数据库：\n\t\t\t\t* create database 数据库名称;\n\t\t\t* 创建数据库，判断不存在，再创建：\n\t\t\t\t* create database if not exists 数据库名称;\n\t\t\t* 创建数据库，并指定字符集\n\t\t\t\t* create database 数据库名称 character set 字符集名;\n\t\n\t\t\t* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\n\t\t\t\t* create database if not exists db4 character set gbk;\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询所有数据库的名称:\n\t\t\t\t* show databases;\n\t\t\t* 查询某个数据库的字符集:查询某个数据库的创建语句\n\t\t\t\t* show create database 数据库名称;\n\t\t3. U(Update):修改\n\t\t\t* 修改数据库的字符集\n\t\t\t\t* alter database 数据库名称 character set 字符集名称;\n\t\t4. D(Delete):删除\n\t\t\t* 删除数据库\n\t\t\t\t* drop database 数据库名称;\n\t\t\t* 判断数据库存在，存在再删除\n\t\t\t\t* drop database if exists 数据库名称;\n\t\t5. 使用数据库\n\t\t\t* 查询当前正在使用的数据库名称\n\t\t\t\t* select database();\n\t\t\t* 使用数据库\n\t\t\t\t* use 数据库名称;\n\n\n\t2. 操作表\n\t\t1. C(Create):创建\n\t\t\t1. 语法：\n\t\t\t\tcreate table 表名(\n\t\t\t\t\t列名1 数据类型1,\n\t\t\t\t\t列名2 数据类型2,\n\t\t\t\t\t....\n\t\t\t\t\t列名n 数据类型n\n\t\t\t\t);\n\t\t\t\t* 注意：最后一列，不需要加逗号（,）\n\t\t\t\t* 数据库类型：\n\t\t\t\t\t1. int：整数类型\n\t\t\t\t\t\t* age int,\n\t\t\t\t\t2. double:小数类型\n\t\t\t\t\t\t* score double(5,2)\n\t\t\t\t\t3. date:日期，只包含年月日，yyyy-MM-dd\n\t\t\t\t\t4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\n\t\t\t\t\t5. timestamp:时间错类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\n\t\t\t\t\t\t* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\n\t\n\t\t\t\t\t6. varchar：字符串\n\t\t\t\t\t\t* name varchar(20):姓名最大20个字符\n\t\t\t\t\t\t* zhangsan 8个字符  张三 2个字符\n\n\n\t\t\t* 创建表\n\t\t\t\tcreate table student(\n\t\t\t\t\tid int,\n\t\t\t\t\tname varchar(32),\n\t\t\t\t\tage int ,\n\t\t\t\t\tscore double(4,1),\n\t\t\t\t\tbirthday date,\n\t\t\t\t\tinsert_time timestamp\n\t\t\t\t);\n\t\t\t* 复制表：\n\t\t\t\t* create table 表名 like 被复制的表名;\t  \t\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询某个数据库中所有的表名称\n\t\t\t\t* show tables;\n\t\t\t* 查询表结构\n\t\t\t\t* desc 表名;\n\t\t3. U(Update):修改\n\t\t\t1. 修改表名\n\t\t\t\talter table 表名 rename to 新的表名;\n\t\t\t2. 修改表的字符集\n\t\t\t\talter table 表名 character set 字符集名称;\n\t\t\t3. 添加一列\n\t\t\t\talter table 表名 add 列名 数据类型;\n\t\t\t4. 修改列名称 类型\n\t\t\t\talter table 表名 change 列名 新列别 新数据类型;\n\t\t\t\talter table 表名 modify 列名 新数据类型;\n\t\t\t5. 删除列\n\t\t\t\talter table 表名 drop 列名;\n\t\t4. D(Delete):删除\n\t\t\t* drop table 表名;\n\t\t\t* drop table  if exists 表名 ;\n\n* 客户端图形化工具：SQLYog\n\n## DML：增删改表中数据\n\n\t1. 添加数据：\n\t\t* 语法：\n\t\t\t* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\n\t\t* 注意：\n\t\t\t1. 列名和值要一一对应。\n\t\t\t2. 如果表名后，不定义列名，则默认给所有列添加值\n\t\t\t\tinsert into 表名 values(值1,值2,...值n);\n\t\t\t3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\n\t2. 删除数据：\n\t\t* 语法：\n\t\t\t* delete from 表名 [where 条件]\n\t\t* 注意：\n\t\t\t1. 如果不加条件，则删除表中所有记录。\n\t\t\t2. 如果要删除所有记录\n\t\t\t\t1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\n\t\t\t\t2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\n\t3. 修改数据：\n\t\t* 语法：\n\t\t\t* update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,... [where 条件];\n\t\n\t\t* 注意：\n\t\t\t1. 如果不加任何条件，则会将表中所有记录全部修改。\n\n\n\n## DQL：查询表中的记录\n\n\t* select * from 表名;\n\t\n\t1. 语法：\n\t\tselect\n\t\t\t字段列表\n\t\tfrom\n\t\t\t表名列表\n\t\twhere\n\t\t\t条件列表\n\t\tgroup by\n\t\t\t分组字段\n\t\thaving\n\t\t\t分组之后的条件\n\t\torder by\n\t\t\t排序\n\t\tlimit\n\t\t\t分页限定\n\n\n\t2. 基础查询\n\t\t1. 多个字段的查询\n\t\t\tselect 字段名1，字段名2... from 表名；\n\t\t\t* 注意：\n\t\t\t\t* 如果查询所有字段，则可以使用*来替代字段列表。\n\t\t2. 去除重复：\n\t\t\t* distinct\n\t\t3. 计算列\n\t\t\t* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n\t\t\t* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\n\t\t\t\t* 表达式1：哪个字段需要判断是否为null\n\t\t\t\t* 如果该字段为null后的替换值。\n\t\t4. 起别名：\n\t\t\t* as：as也可以省略\n\n\n\t3. 条件查询\n\t\t1. where子句后跟条件\n\t\t2. 运算符\n\t\t\t* &gt; 、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt;\n\t\t\t* BETWEEN...AND  \n\t\t\t* IN( 集合) \n\t\t\t* LIKE：模糊查询\n\t\t\t\t* 占位符：\n\t\t\t\t\t* _:单个任意字符\n\t\t\t\t\t* %：多个任意字符\n\t\t\t* IS NULL  \n\t\t\t* and  或 &amp;&amp;\n\t\t\t* or  或 || \n\t\t\t* not  或 !\n\t\t\t\n\t\t\t\t-- 查询年龄大于20岁\n\t\n\t\t\t\tSELECT * FROM student WHERE age &gt; 20;\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄等于20岁\n\t\t\t\tSELECT * FROM student WHERE age &#x3D; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄不等于20岁\n\t\t\t\tSELECT * FROM student WHERE age !&#x3D; 20;\n\t\t\t\tSELECT * FROM student WHERE age &lt;&gt; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄大于等于20 小于等于30\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp;  age &lt;&#x3D;30;\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20 AND  age &lt;&#x3D;30;\n\t\t\t\tSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n\t\t\t\t\n\t\t\t\t-- 查询年龄22岁，18岁，25岁的信息\n\t\t\t\tSELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25\n\t\t\t\tSELECT * FROM student WHERE age IN (22,18,25);\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩为null\n\t\t\t\tSELECT * FROM student WHERE english &#x3D; NULL; -- 不对的。null值不能使用 &#x3D; （!&#x3D;） 判断\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE english IS NULL;\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩不为null\n\t\t\t\tSELECT * FROM student WHERE english  IS NOT NULL;\n\n\n\n\t\t\t\t-- 查询姓马的有哪些？ like\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n\t\t\t\t-- 查询姓名第二个字是化的人\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n\t\t\t\t\n\t\t\t\t-- 查询姓名是3个字的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n\n\n​\t\t\t\t\n\n\t\t\t\t-- 查询姓名中包含德的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n\n## 数据库备份\n\nmysqldump -uroot -p (数据库名) &gt; d:&#x2F;&#x2F;a.sql\n\n\t# 网络编程\n\nudp：\n\n&#96;&#96;&#96;java\n&#x2F;**\n * UDP发送端\n *&#x2F;\npublic class SendDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        DatagramSocket ds &#x3D; new DatagramSocket();\n        byte[] bys &#x3D; &quot;shit!+\\n&quot;.getBytes();\n        DatagramPacket dp &#x3D; new DatagramPacket(bys,bys.length, InetAddress.getByName(&quot;localhost&quot;),65530);\n        ds.send(dp);\n        ds.close();\n    &#125;\n&#125;\n\n&#x2F;**\n * UDP接收端\n *&#x2F;\npublic class AcceptDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        DatagramSocket ds &#x3D; new DatagramSocket(65530);\n        byte[] by &#x3D; new byte[1024];\n        DatagramPacket dp &#x3D; new DatagramPacket(by,by.length);\n        ds.receive(dp);\n        int len &#x3D; dp.getLength();\n        String dataString &#x3D; new String(by,0,len);\n        System.out.println(&quot;数据是&quot;+dataString);\n        ds.close();\n    &#125;\n&#125;\n\ntcp断开流程：\n假设 Client 端发起中断连接请求，也就是发送 FIN 报文。Server 端接到 FIN 报文后，意思是说 &quot; 我 Client 端没有数据要发给你了 &quot;，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，&quot; 告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息 &quot;。这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，&quot; 告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了 &quot;。Client 端收到 FIN 报文后，&quot; 就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。“，Server 端收到 ACK 后，&quot; 就知道可以断开连接了 &quot;。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！\n\ntcp发送数据的步骤：\n\n创建客户端的Socket对象\nSocket(String host,int port)\n\n获取输出流，写数据\nOutputStream getOutputStream()\n\n释放资源\nvoid close()\n\n\ntcp接收数据的步骤：\n\n创建服务端的Socket对象（ServerSocket）\nServerSocket(int port)\n\n监听客户端连接，返回一个Socket对象\nSocket accept()\n\n获取输入流、读数据，并把数据显示在控制台\nInputStream getInputStream()\n\n释放资源\nvoid close()\n\n\npublic class Send &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;创建客户端的Socket对象\n        Socket sc &#x3D; new Socket(&quot;192.168.1.51&quot;,65530);\n        &#x2F;&#x2F;获取输出流，写数据\n        OutputStream os &#x3D; sc.getOutputStream();\n        os.write(&quot;hello,tcp&quot;.getBytes());\n        &#x2F;&#x2F;释放资源\n        sc.close();\n    &#125;\n&#125;\n\npublic class Accept &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;创建服务端的Socket对象（ServerSocket）\n        ServerSocket sc &#x3D; new ServerSocket(65530);\n        &#x2F;&#x2F;监听客户端连接，返回一个Socket对象\n        Socket s &#x3D; sc.accept();\n        &#x2F;&#x2F;获取输入流、读数据，并把数据显示在控制台\n        InputStream is &#x3D; s.getInputStream();\n        byte[] bys &#x3D; new byte[1024];\n        int len &#x3D; is.read(bys);\n        String data &#x3D; new String(bys,0,len);\n        System.out.println(&quot;数据是：&quot;+data);\n        &#x2F;&#x2F;释放资源\n        sc.close();\n    &#125;\n&#125;\n\nhtmlinput 对应checked 默认\noption 对应 selected \n\n./ 代表当前目录\n../代表上一级目录\n换行\n 标签的 alt 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。\n如何实现全选功能：\n将全选按钮和列表按钮绑定，用循环遍历来逐个绑定。\n&#x2F;&#x2F;1.获取第一个cb\ndocument.getElementById(&quot;firstCb&quot;).onclick &#x3D; function ()&#123;\n    &#x2F;&#x2F; 2.获取下边列表中所有的cb\nvar cbs &#x3D; document.getElementsByName(&quot;uid&quot;);\nfor(var i &#x3D; 0;i&lt;cbs.length;i++)&#123;\n    &#x2F;&#x2F;4.设置这些cbp[i]的checked状态&#x3D;firstCb.checked\n    cbs[i].checked &#x3D; this.checked; \n\n 空格占位符\nhtml建立表单快捷代码  table&gt;tr2&gt;td3 再按Tab  两行三列\nstyle（css样式） 一般在head中，script 一般在body中\n\n类加载器如果写一个类需要动态的获取某个文件的位置，从而能够获取此文件的资源。那么，使用 Class.getResourceAsStream () 方法便可以。\n这样就不用每次去修改代码中文件的绝对地址或详细地址了。\njedisjedis.setex(&quot;activecode&quot;,10,&quot;hehe&quot;);&#x2F;&#x2F;将activecode，hehe键值对存入redis，10秒后删除\n\n\nlist转json\nObjectMapper mapper &#x3D; new ObjectMapper();\nString s &#x3D; mapper.writeValueAsString(list);\n\nJavaScript通过内容来确定类型 var 变量 = 初始化值\ntypeof 来确定类型\njs中== 先做类型转换，再进行比较 3==“3“  true\n=== 先做类型比较，如果类型不同， false\n    5. 逻辑运算符\n        &amp;&amp; || !    （短路效果\n        * 其他类型转boolean：\n           1. number：0或NaN为假，其他为真\n           2. string：除了空字符串(&quot;&quot;)，其他都是true\n           3. null&amp;undefined:都是false\n           4. 对象：所有对象都为true\n\n引号的时候，内双外单或者外双内单    ‘     “   “    ‘   \nplaceholder 虚化的value\n&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入性别&quot; id&#x3D;&quot;c3&quot;&gt;\n\nservlet以 .do结尾的路径不能以/开头\ntomcat8 和以后版本已经解决get请求中文乱码\npost中文乱码需要手动解决  \n\n解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”);\n\n也可以用过滤器等等\nEnumeration&lt;String&gt; parameterNames &#x3D; request.getParameterNames();\n\nwhile(parameterNames.hasMoreElements)&#123;&#125;\n\n&#x2F;&#x2F;遍历枚举\n\n内部资源转发必须用请求转发\n\n&#x2F;&#x2F; $.get(url,[data],[callback],[type]);  路径，数据，回调函数，接收到的响应数据的格式\n\npost语法一样\njson的三个包\n\n    public void Test02() throws JsonProcessingException &#123;\n&#x2F;&#x2F;        将json转为java对象\n        String json &#x3D; &quot;&#123;\\&quot;gender\\&quot;:\\&quot;男\\&quot;,\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;age\\&quot;:23&#125;&quot;;\n        ObjectMapper map &#x3D; new ObjectMapper();\n        Person person &#x3D; map.readValue(json, Person.class);\n        System.out.println(person);\n    &#125;\n\n\n修改tomcat启动默认页面。web.xml\n四大域对象 \npageContext、request、session、ServletContext(全局域对象 随着tomcat启动创建 tomcat消亡而消亡)\nApplicationContext与ServletContext是一个东西\n\nsession工作原理\n枚举\nvalue () 方法可以将枚举类转变为一个枚举类型的数组，因为枚举中没有下标，我们没有办法通过下标来快速找到需要的枚举类，这时候，转变为数组之后，我们就可以通过数组的下标，来找到我们需要的枚举类。接下来就展示代码了。\npublic enum SearchCategory &#123;\n    ALL(&quot;综合查询&quot;),\n    NEWS(&quot;新闻&quot;),\n    TAXPAYER(&quot;纳税人&quot;),\n    QUIZ(&quot;知识问答&quot;),\n    POLICY_LAW(&quot;政策法规&quot;),\n    DOC(&quot;涉税文档&quot;),\n    PIC(&quot;图片&quot;),\n    BAIKE(&quot;税务百科&quot;);\n\n    private String value;\n\n    SearchCategory(String value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public String getValue()&#123;\n        return value;\n    &#125;\n    \n    public static void main(String[] args)&#123;\n        for(SearchCategory s : SearchCategory.values())&#123;\n            System.out.println(s + &quot;---&quot; + s.getValue());\n        &#125;\n    &#125;\n&#125;\n\n转换json并设置格式\n@JsonFormat(pattern &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;,timezone &#x3D; &quot;GMT+8&quot;)\nprivate Date joinDate;\n\n","slug":"java基础","date":"2021-08-07T14:32:21.000Z","categories_index":"java","tags_index":"java","author_index":"icarus"}]