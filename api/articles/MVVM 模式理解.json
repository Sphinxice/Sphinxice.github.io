{"title":"MVVM模式","uid":"20496ea705d490e685d32b89838c0b41","slug":"MVVM 模式理解","date":"2021-10-07T14:32:21.000Z","updated":"2022-01-15T16:51:18.596Z","comments":true,"path":"api/articles/MVVM 模式理解.json","keywords":"Java","cover":[],"content":"<h1 id=\"MVVM-模式理解（转）\"><a href=\"#MVVM-模式理解（转）\" class=\"headerlink\" title=\"MVVM 模式理解（转）\"></a>MVVM 模式理解（转）</h1><p>　　MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其<strong>核心是提供对 View 和 ViewModel 的双向数据绑定，这使得 ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定</strong>。</p>\n<p>　　Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于 View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel 负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>\n<p>　　<strong>为什么会出现 MVVM 呢？</strong></p>\n<p>　　MVC 即 Model-View-Controller 的缩写，就是 模型 — 视图 — 控制器，也就是说一个标准的 Web 应用程式是由这三部分组成的：</p>\n<p>　　View ：用来把数据以某种方式呈现给用户</p>\n<p>　　Model ：其实就是数据</p>\n<p>　　Controller ：接收并处理来自用户的请求，并将 Model 返回给用户</p>\n<p>　　在 HTML5 还未火起来的那些年，MVC 作为 Web 应用的最佳实践是 OK 的，这是因为 Web 应用的 View 层相对来说比较简单，前端所需要的数据在后端基本上都可以处理好，View 层主要是做一下展示，那时候提倡的是 Controller 来处理复杂的业务逻辑，所以 View 层相对来说比较轻量，就是所谓的<strong>瘦客户端思想</strong>。</p>\n<p>　　<strong>为什么前端要工程化，要是使用 MVC？</strong> </p>\n<p>　　相对 HTML4，HTML5 最大的亮点是<strong>它为移动设备提供了一些非常有用的功能</strong>，使得 HTML5 具备了开发 App 的能力， HTML5 开发 App 最大的好处就是<strong>跨平台、快速迭代和上线，节省人力成本和提高效率</strong>，因此很多企业开始对传统的 App 进行改造，逐渐用 H5 代替 Native，到 2015 年的时候，市面上大多数 App 或多或少嵌入都了 H5 的页面。既然要用 H5 来构建 App， 那 View 层所做的事，就不仅仅是简单的数据展示了，它不仅要管理复杂的数据状态，还要处理移动设备上各种操作行为等等。因此，前端也需要工程化，也需要一个类似于 MVC 的框架来管理这些复杂的逻辑，使开发更加高效。 但这里的 MVC 又稍微发了点变化：</p>\n<p>　　View ：UI 布局，展示数据</p>\n<p>　　Model ：管理数据</p>\n<p>　　Controller ：响应用户操作，并将 Model 更新到 View 上</p>\n<p>　　这种 MVC 架构模式对于简单的应用来看是 OK 的，也符合软件架构的分层思想。 但实际上，随着 H5 的不断发展，人们更希望使用 H5 开发的应用能和 Native 媲美，或者接近于原生 App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：</p>\n<p>　　1、 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。</p>\n<p>　　2、大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p>\n<p>　　3、 当 Model 频繁发生变化，开发者需要主动更新到 View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到 Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</p>\n<p>　　其实，早期 jquery 的出现就是为了前端能更简洁的操作 DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。</p>\n<p>　　<strong>MVVM 的出现，完美解决了以上三个问题。</strong></p>\n<p>　　MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>\n<p>　　<strong>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上</strong>。</p>\n<p>　　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>\n<p>　　<strong>Vue.js 的细节</strong></p>\n<p>　　Vue.js 可以说是 MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的 JS 库，API 简洁，很容易上手。Vue 的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：</p>\n<p>　　Vue.js 是<strong>采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的</strong>。<strong>当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</strong></p>\n<p><img src=\"https://s9.51cto.com/images/blog/202108/09/f36512dfeff09664812a03c923cb93c8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt=\"MVVM模式理解（转）_mvc\">****</p>\n<p>　　Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用 Object.defineProperty 的 getter 和 setter 来实现</p>\n<p>　　Compile ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p>\n<p>　　Watcher ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数</p>\n<p>　　Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发 notify 函数，再调用订阅者的 update 方法</p>\n<p>　　从图中可以看出，<strong>当执行 new Vue () 时，Vue 就进入了初始化阶段，一方面 Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器 Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时 Wather 会将自己添加到消息订阅器中 (Dep)，初始化完毕。</strong></p>\n<p>　　<strong>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用 Dep.notify ()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</strong></p>\n","text":"MVVM 模式理解（转） MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对 View 和 ViewModel 的双向数据绑定，这使得 ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 Vu...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":1,"path":"api/categories/前端.json"}],"tags":[{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MVVM-%E6%A8%A1%E5%BC%8F%E7%90%86%E8%A7%A3%EF%BC%88%E8%BD%AC%EF%BC%89\"><span class=\"toc-text\">MVVM 模式理解（转）</span></a></li></ol>","author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Spring基础","uid":"3a37cd072b4ce26a3caecc3401259a9a","slug":"Spring","date":"2021-10-07T14:32:21.000Z","updated":"2022-01-07T14:56:00.641Z","comments":true,"path":"api/articles/Spring.json","keywords":"Java","cover":[],"text":"Spring 导入Spring开发的基本包坐标 编写Dao接口和实现类 创建Spring核心配置文件 在Spring配置文件中配置UserDaoImpl 使用Spring的API获得Bean实例 Spring的重点配置 Spring原始注解 spring集成web环境步骤 视图解...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"}],"tags":[{"name":"Spring","slug":"Spring","count":1,"path":"api/tags/Spring.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}}},"next_post":{"title":"Jquery和原生js的区别","uid":"cf3ece25eb219b32904f64404ccf8150","slug":"Jquery 和 原生js","date":"2021-09-07T14:32:21.000Z","updated":"2022-01-07T14:55:48.161Z","comments":true,"path":"api/articles/Jquery 和 原生js.json","keywords":"Java","cover":null,"text":"Jquery 和 原生js（1）选中dom对象 document.getElementsByClassName(“one”)[0] =$(“.one”) document.getElementsByTagName(“div”)[0] =$(“.div”) document.get...","link":"","photos":[],"count_time":{"symbolsCount":396,"symbolsTime":"1 mins."},"categories":[{"name":"javascript","slug":"javascript","count":1,"path":"api/categories/javascript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":1,"path":"api/tags/JavaScript.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}}}}