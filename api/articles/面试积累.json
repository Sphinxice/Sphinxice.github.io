{"title":"面试积累","uid":"4a4c62b488ae3faf3b7c187892faae11","slug":"面试积累","date":"2022-01-10T14:32:21.000Z","updated":"2022-01-15T16:22:50.969Z","comments":true,"path":"api/articles/面试积累.json","keywords":"Java","cover":[],"content":"<p>linux：</p>\n<p><strong>DevOps的全名：</strong></p>\n<p>Development Operations 开发自运维</p>\n<p><img src=\"http://image.1carus.xyz/20180412212828881\" alt=\"img\"></p>\n<p>首先来回顾一下整个开发流程：</p>\n<p>需求 - 开发 - 测试 - 发布 - 部署 - 监控运维</p>\n<p>项目管理（需求 &amp; BUG）：redmine</p>\n<p>代码托管：gerrit（gitlab）</p>\n<p>持续集成：jenkins</p>\n<p>测试：单元测试：maven 等，Jmeter，或者是自己编写脚本</p>\n<p>代码扫描：sonar</p>\n<p>制品库：JFrog，或者其他工具，这个我也没有想好 JFrog 收费版可以支持 docker，maven, npm 等等等，多得不行，制品这方面目前没有什么好的开源的软件。</p>\n<p>持续部署：K8S</p>\n<p>日志收集：ELK + KAFKA</p>\n<p>监控显示：zabbix，grafana</p>\n<p>其他工具：nginx, lvs，HA, redis，rabbitmq，ldap, ansible。</p>\n<p><strong>实践想法</strong></p>\n<p>认证：LDAP 发现好多的开源的工具都会选择 ldap 来做认证。OPENLDAP。</p>\n<p>项目管理：redmine，开源，有丰富的插件，至少感觉好像还是挺火的。</p>\n<p>代码托管：gerrit 或者是 gitlab 吧，我这边我会选择 gerrit</p>\n<p>持续集成：jenkins, 可惜 jenkins 竟然不开源，不过插件丰富。</p>\n<p>代码扫描：sonar</p>\n<p>额说得有点重了。LDAP 作为所有工具链的一个认证，这样用户信息就统一起来了。</p>\n<p>来个场景吧.</p>\n<p><img src=\"http://image.1carus.xyz/20180412223926546\" alt=\"img\"></p>\n<ol>\n<li><p>BA 接收到需求之后将其录入 Redmine, 指定好开发人员。</p>\n</li>\n<li><p>开发人员接收到任务之后，然后从 gerrit 拉取代码到本地，然后进行开发，开发完成后，将写好的代码弄成一个评审单上传到 gerrit, 并通知相关的评审人员进行评审。</p>\n</li>\n<li><p>在你提交上去的那个刻，jenkins 收到你创建评审单事件，然后开发触发构建的你配置的任务，先拉取你最新提交的代码，然后进行编译构建，扫描你的代码是否符合。代码符合之后，然后进行测试（在构建的时候会先进行单元测试），然后把构建好的包，在测试环境上进行部署，然后拉取自动测试脚本进行测试，测试没有问题之后。jenkins 会对你本次的评审单进行打分。通过了就打 2 分，不过打 - 2 分。这样就避免了浪费大家的时间，在打分通过了的情况下，评审人员才会去评审。</p>\n</li>\n<li><p>评审人员到 gerrit 上进行评审，如果评审不合格，直接拒绝，开发人员重新进行开发。在提交然后再重复 3 步骤。如果评审通过，进行代码合入，然后再次触发 jenkins 的构建任务，不过这个任务是构建 beta 测试版本，构建到测试版本之后，然后发布到制品库中，然后通知测试人员可以进行测试了。然后这个时候将 redmine 的任务状态更改会开发完成。这个时候会通知测试人员可以进行测试了。</p>\n</li>\n<li><p>测试人员收到测试任务之后，从制品库中拉取 beta 包进行部署测试，这个部署测试环境，有了 docker 容器其实也是可以一键部署哦，然后再用自动化脚本进行测试，对于个别场景可以进行手工测试，如果有 bug, 测试人员在 redmine 进行录入，然后通知开发人员，这个时候流程又从 1 开始，直到这个 bug 测试通过了，然后 redmine 会更改 bug 状态。</p>\n</li>\n<li><p>如果测试人员测试通过了，然后又可以出发一次构建任务。将最新的代码构建成 release 版本发到制品库中或者是进行自动部署。而且现在有灰度发布，可以一点一点切流程到新的版本上，看一下运行情况，如果不行直接回退。</p>\n</li>\n</ol>\n<p><strong>列举文件abc.log最后十行：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">tail -n 20 abc.log</code></pre>\n\n<p><strong>Jenkins是什么？有什么作用</strong></p>\n<p>Jenkins 是开源软件项目，基于 Java 开发的持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<p><strong>Jenkins 的功能</strong></p>\n<p>Jenkins 的主要功能是将项目中重复执行的工作自动化的执行。如软件的建造（构建）和在配置文件下设置的 job。具体功能大概有：</p>\n<ol>\n<li><p>软件的持续构建和测试，Jenkins 提供了一个系统，使开发人员可以很容易的将改变集成到工程中。自动化的，持续的构建有利于提高开发效率。</p>\n</li>\n<li><p>监视 job 的执行，如下图所示，job 可以实现很多的功能，Jenkins 可以对这些项目进行显示，让用户更清楚的注意到这些损毁的 job。（具体情况后文中介绍）</p>\n</li>\n<li><p>项目源代码修改的检测，jenkins 能够从项目的 Subversion/CVS 生成最近修改的集合列表，且不会增加 Subversion/CVS Repository 的负载。</p>\n</li>\n<li><p>分布式构建，Jenkins 可以将工程构建到多台机器，更好地利用硬件资源，节省时间。</p>\n</li>\n</ol>\n<p>其他，Jenkins 代码开源，用户可以自己编写插件。所以 jenkins 可以实现很多的功能。</p>\n<p><strong>列举全部的java进程</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ps -ef | grep java</code></pre>\n\n<p><img src=\"http://image.1carus.xyz/20170228180329554\" alt=\"img\"></p>\n<p>扩展：停止特定 java 进程命令：kill -9 java 进程序号     比如:kill -9 97993</p>\n<p><strong>从 <a href=\"http://www.somewebsite.com/file.tar.gz%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6\">http://www.somewebsite.com/file.tar.gz下载一个文件</a></strong></p>\n<p>weget  <a href=\"http://www.somewebsite.com/file.tar.gz\">http://www.somewebsite.com/file.tar.gz</a></p>\n<p>数据库：</p>\n<p><strong>delete和truncate的区别</strong></p>\n<p>DELETE 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>\n<p>TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>\n<p>drop 语句将表所占用的空间全释放掉。</p>\n<p><strong>Statement和PrepareStatement的区别</strong></p>\n<p>Statement 每次执行 sql 语句，数据库都要执行 sql 语句的编译，最好用于仅执行一次查询并返回结果的情形，效率高于 PreparedStatement. 但存在 sql 注入风险。PreparedStatement 是预编译执行的。在执行可变参数的一条 SQL 时，PreparedStatement 要比 Statement 的效率高，因为 DBMS 预编译一条 SQL 当然会比多次编译一条 SQL 的效率高。安全性更好，有效防止 SQL 注入的问题。对于多次重复执行的语句，使用 PreparedStatement 效率会更高一点。</p>\n<p><strong>列举什么字段适合建索引</strong></p>\n<p>1、表的主键、外键必须有索引；<br>2、数据量超过 300 的表应该有索引；<br>3、经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4、经常出现在 Where 子句中的字段，特别是大表的字段，应该建立索引；<br>5、索引应该建在选择性高的字段上；<br>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替<br>8、不包含有 NULL 值的列</p>\n<p><strong>union和union all 有什么不同</strong></p>\n<p>在数据库中，<strong>union</strong> 和 <strong>union all</strong> 关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。</p>\n<p><strong>union</strong> 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果</p>\n<p> 而 <strong>union all</strong> 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。<br>   从效率上说，union all 要比 union 快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用 union all</p>\n<p><strong>CHAR和VARCHAR的区别是什么</strong></p>\n<p>CHAR 和 VARCHAR 最大的不同就是一个是固定长度，一个是可变长度。 由于是可变长度，因此实际存储的时候是实际字符串再加上一个记录字符串长度的字节 (如果超过 255 则需要两个字节)。 如果分配给 CHAR 或 VARCHAR 列的值超过列的最大长度，则对值进行裁剪以使其适合。 如果被裁掉的字符不是空格，则会产生一条警告</p>\n<p><img src=\"http://image.1carus.xyz/image-20220115141941827.png\" alt=\"image-20220115141941827\"></p>\n<h1 id=\"前端：\"><a href=\"#前端：\" class=\"headerlink\" title=\"前端：\"></a>前端：</h1><p><strong>请说出两种减少页面加载时间的方法：</strong></p>\n<ol>\n<li>重复的 HTTP 请求数量应尽量减少</li>\n<li>压缩 Javascript、CSS 代码</li>\n<li>在文件头部放置 css 样式的定义</li>\n<li>在文件末尾放 Javascript 脚本</li>\n<li>css、javascript 改由外部调用</li>\n<li>尽可能减少 DCOM 元素</li>\n<li>避免使用 CSS 脚本 (CSS Expressions)</li>\n<li>服务器启用 gzip 压缩功能</li>\n<li>Ajax 采用缓存调用</li>\n<li>Ajax 调用尽量采用 GET 方法调用</li>\n<li>养成良好的开发维护习惯，尽量避免脚本重复调用</li>\n<li>缩减 iframe 的使用，如无必要，尽量不要使用<br>参考链接：<a href=\"https://blog.csdn.net/Rayshaan/article/details/112130992\">https://blog.csdn.net/Rayshaan/article/details/112130992</a></li>\n</ol>\n<p><strong>html中doctype(文档类型)的作用是什么？你知道多少种文档类型</strong></p>\n<p>doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。</p>\n<p><strong>1、HTML5 &lt;!DOCTYPE&gt; 声明</strong></p>\n<p>HTML5 规定了一种 &lt;!DOCTYPE&gt; 声明，它能向前向后兼容，代码也更加简洁，刘代码推荐使用。</p>\n<p>Markup</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!doctype html&gt;</code></pre>\n\n<p><strong>2、HTML 4.01</strong> Strict</p>\n<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p>\n<p>Markup</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;</code></pre>\n\n<p><strong>3、HTML 4.01</strong> Transitional<br>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p>\n<p>Markup</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</code></pre>\n\n<p> <strong>什么是闭包，如何使用它，为什么要使用它？</strong></p>\n<ol>\n<li>闭包是指有权访问另一个函数作用域中的变量的函数。</li>\n<li>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</li>\n<li>闭包可以用在许多地方。它的最大用处有两个：<ol>\n<li>可以读取函数内部的变量</li>\n<li>让这些变量的值始终保存在内存中</li>\n</ol>\n</li>\n</ol>\n<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。</p>\n<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<p>闭包的真正意义是： 闭包是由于局部变量无法共享和长久的保存，而全局变量可能造成变量污染，当我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 function f1 () { var a=10; return function (){ a++; console.log (a); }; }; var f = f1 (); f (); 当 f () 在不断调用时，a 的状态会被保存，不会在 f1 () 执行完后释放 总结下： 闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装私有变量，这是优点也是缺点，不必要的闭包只会徒增内存消耗！</p>\n<p><strong>请描述一下cookies、sessionStorage和localStorage的区别</strong></p>\n<p>共同点：都是保存在浏览器端，且同源的。</p>\n<p>区别：</p>\n<ol>\n<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li>\n<li>存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li>\n<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li>\n<li>作用域不同，sessionStorage <strong>不在</strong>不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</li>\n</ol>\n<p><strong>什么是mvvm，前端mvvm里面的view model指什么？</strong></p>\n<p>Model–View–ViewModel  是一个软件架构设计模式</p>\n<p>MVVM 分层示意图</p>\n<p>分层设计一直是软件架构的主流设计思想之一，MVVM 也不例外。</p>\n<p><strong>View 层</strong></p>\n<p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2 等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。</p>\n<p><strong>Model 层</strong></p>\n<p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。后端的处理通常会非常复杂：</p>\n<p>前后端对比<br>后端：我们这里的业务逻辑和数据处理会非常复杂！<br>前端：关我屁事！</p>\n<p>后端业务处理再复杂跟我们前端也没有半毛钱关系，只要后端保证对外接口足够简单就行了，我请求 api，你把数据返出来，咱俩就这点关系，其他都扯淡。</p>\n<p><strong>ViewModel 层</strong></p>\n<p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。看到了吧，View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>\n<p>Vue 的 View 模板：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;\n    &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;Click me&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n </code></pre>\n\n<p>Vue 的 ViewModel 层（下面是伪代码）：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var app &#x3D; new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;     &#x2F;&#x2F; 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）\n        message: &#39;Hello Vue!&#39;,  &#x2F;&#x2F; 纯前端定义\n        server: &#123;&#125;, &#x2F;&#x2F; 存放基于 Model 层数据的二次封装数据\n    &#125;,\n    methods: &#123;  &#x2F;&#x2F; 用于描述视图行为（完全前端定义）\n        showMessage()&#123;\n            let vm &#x3D; this;\n            alert(vm.message);\n        &#125;\n    &#125;,\n    created()&#123;\n        let vm &#x3D; this;\n\n        &#x2F;&#x2F; Ajax 获取 Model 层的数据\n        ajax(&#123;\n            url: &#39;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&#39;,\n            success(res)&#123;\n                &#x2F;&#x2F; TODO 对获取到的 Model 数据进行转换处理，做二次封装\n                vm.server &#x3D; res;\n            &#125;\n        &#125;);\n    &#125;\n&#125;)\n </code></pre>\n\n<p>服务端的 Model 层（省略业务逻辑处理，只描述对外接口）：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;url&quot;: &quot;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&quot;,\n    &quot;res&quot;: &#123;\n        &quot;success&quot;: true,\n        &quot;name&quot;: &quot;IoveC&quot;,\n        &quot;domain&quot;: &quot;www.cnblogs.com&quot;\n    &#125;\n&#125;\n </code></pre>\n\n<p>这就是完整的 MVVM 编程模式。</p>\n<p>代码执行之后双向绑定的效果如下:</p>\n<p>Vue 实现的响应的数据绑定</p>\n<p>嘿嘿，前后端可以成功分手了，以后再也不用关心后端个锤子开发进度 \\ 暴怒脸，复杂实现，blabla…，尽情享用前端如丝般顺滑的开发快感吧：)</p>\n<h1 id=\"后端：\"><a href=\"#后端：\" class=\"headerlink\" title=\"后端：\"></a>后端：</h1><p><strong>java中int和Integer有什么区别</strong></p>\n<p>Integer 是 int 的包装类；int 是基本数据类型； Integer 变量必须实例化后才能使用；int 变量不需要； Integer 实际是对象的引用，指向此 new 的 Integer 对象；int 是直接存储数据值； Integer 的默认值是 null；int 的默认值是 0。</p>\n<p><strong>java构造器是否可被重写</strong></p>\n<p>不可以</p>\n<p><strong>java如何实现对象克隆，说出一种方法</strong></p>\n<p><strong>浅克隆 (ShallowClone)</strong> 和 **深克隆 (DeepClone)**。</p>\n<p>在 Java 语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括 int、double、byte、boolean、char 等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。</p>\n<p>一般步骤是（浅克隆）：</p>\n<ol>\n<li><p><strong>被复制的类需要实现 Clonenable 接口</strong>（不实现的话在调用 clone 方法会抛出 CloneNotSupportedException 异常)， 该接口为标记接口 (不含任何方法)</p>\n</li>\n<li><p><strong>覆盖 clone () 方法，访问修饰符设为 public</strong>。 <strong>方法中调用 super.clone () 方法得到需要的复制对象</strong>。（native 为本地方法)</p>\n</li>\n</ol>\n<p>深克隆</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student implements Cloneable&#123;\n    private int number;\n\n    public void setNumber(int number) &#123;\n        this.number &#x3D; number;\n    &#125;\n\n    public int getNumber() &#123;\n\n        return number;\n    &#125;\n    @Override\n    public Object clone()&#123;\n        Student stu &#x3D; null;\n        try &#123;\n            stu &#x3D; (Student) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return stu;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        Student stu1 &#x3D; new Student();\n        stu1.setNumber(12345);\n        Student stu2 &#x3D; (Student) stu1.clone();\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber());\n\n        stu2.setNumber(54321);\n\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber());\n        System.out.println(stu1&#x3D;&#x3D;stu2);\n    &#125;\n&#125;\n输出：\n学生1:12345\n学生2:12345\n学生1:12345\n学生2:54321\nfalse</code></pre>\n\n<h3 id=\"浅复制（浅克隆）\"><a href=\"#浅复制（浅克隆）\" class=\"headerlink\" title=\"浅复制（浅克隆）\"></a>浅复制（浅克隆）</h3><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。</p>\n<p>换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Address  &#123;\n    private String add;\n&#x2F;&#x2F;省略getset方法\n&#125;\nclass Student implements Cloneable&#123;\n    private int number;\n\tprivate Address addr;\n\npublic Address getAddr() &#123;\n    return addr;\n&#125;\n\npublic void setAddr(Address addr) &#123;\n    this.addr &#x3D; addr;\n&#125;\n\npublic int getNumber() &#123;\n    return number;\n&#125;\n\npublic void setNumber(int number) &#123;\n    this.number &#x3D; number;\n&#125;\n\n@Override\npublic Object clone() &#123;\n    Student stu &#x3D; null;\n    try&#123;\n        stu &#x3D; (Student)super.clone();\n    &#125;catch(CloneNotSupportedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    return stu;\n&#125;\n&#125;\npublic class Test &#123;\npublic static void main(String args[]) &#123;\n\n    Address addr &#x3D; new Address();\n    addr.setAdd(&quot;杭州市&quot;);\n    Student stu1 &#x3D; new Student();\n    stu1.setNumber(123);\n    stu1.setAddr(addr);\n\n    Student stu2 &#x3D; (Student)stu1.clone();\n\n    System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());\n    System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());\n&#125;\n&#125;\n       &#x2F;&#x2F;输出：\n        &#x2F;&#x2F;学生1:12345,地址:杭州市\n\t\t&#x2F;&#x2F;学生2:12345,地址:杭州市\n&#x2F;&#x2F;改变一下add，结果两个都一样，因为引用的ADDRESS没有实现clone方法。</code></pre>\n\n<h3 id=\"深复制（深克隆）\"><a href=\"#深复制（深克隆）\" class=\"headerlink\" title=\"深复制（深克隆）\"></a>深复制（深克隆）</h3><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。</p>\n<p>那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。</p>\n<p>换言之，深复制把要复制的对象所引用的对象都复制了一遍。（引用的对象也要实现clone方法）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student implements Cloneable&#123;\n    private int number;\n\tprivate Address addr;\n&#x2F;&#x2F;在这省略getset方法\n    @Override\n    public Object clone()&#123;\n        Student stu &#x3D; null;\n        try &#123;\n            stu &#x3D; (Student) super.clone(); &#x2F;&#x2F;浅复制\n        &#125; catch (CloneNotSupportedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        stu.addr &#x3D; (Address) addr.clone();&#x2F;&#x2F;深度复制\n        return stu;\n    &#125;\n&#125;\n\n class Address implements Cloneable&#123;\n    private String add;\n&#x2F;&#x2F;省略getset构造方法\n    @Override\n     public Object clone()&#123;\n         Address addr &#x3D; null;\n        try &#123;\n            addr &#x3D; (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return addr;\n    &#125;\n     \n     public class Test &#123;\n    public static void main(String[] args) &#123;\n        Address addr &#x3D; new Address();\n        addr.setAdd(&quot;西湖区&quot;);\n        Student stu1 &#x3D; new Student();\n        stu1.setNumber(12345);\n        stu1.setAddr(addr);\n        Student stu2 &#x3D; (Student) stu1.clone();\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());\n        addr.setAdd(&quot;杭州市&quot;);\n&#x2F;&#x2F;        stu2.setAddr(new Address(&quot;杭州市&quot;));\n        System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());\n        System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());\n        &#x2F;**\n        输出：\n        学生1:12345,地址:西湖区\n\t\t学生2:12345,地址:西湖区\n\t\t学生1:12345,地址:杭州市\n\t\t学生2:12345,地址:西湖区\n\t\t*&#x2F;</code></pre>\n\n\n\n<h1 id=\"什么时候使用断言\"><a href=\"#什么时候使用断言\" class=\"headerlink\" title=\"什么时候使用断言\"></a>什么时候使用断言</h1><p>断言（Assertion）是一种调试程序的方式。在 Java 中，使用 <code>assert</code> 关键字来实现断言。</p>\n<p>我们先看一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    double x &#x3D; Math.abs(-123.45);\n    assert x &gt;&#x3D; 0;\n    System.out.println(x);\n&#125;</code></pre>\n\n<p>语句 <code>assert x &gt;= 0;</code> 即为断言，断言条件 <code>x &gt;= 0</code> 预期为 <code>true</code>。如果计算结果为 <code>false</code>，则断言失败，抛出 <code>AssertionError</code>。</p>\n<p>使用 <code>assert</code> 语句时，还可以添加一个可选的断言消息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">assert x &gt;&#x3D; 0 : &quot;x must &gt;&#x3D; 0&quot;;</code></pre>\n\n<p>这样，断言失败的时候，<code>AssertionError</code> 会带上消息 <code>x must &gt;= 0</code>，更加便于调试。</p>\n<p>Java 断言的特点是：断言失败时会抛出 <code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p>\n<p>对于可恢复的程序错误，不应该使用断言。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void sort(int[] arr) &#123;\n    assert arr !&#x3D; null;\n&#125;</code></pre>\n\n<p>应该抛出异常并在上层捕获：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void sort(int[] arr) &#123;\n    if (arr &#x3D;&#x3D; null) &#123;\n        throw new IllegalArgumentException(&quot;array cannot be null&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>当我们在程序中使用 <code>assert</code> 时，例如，一个简单的断言：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; assert</code></pre>\n\n<p> Run</p>\n<p>-1</p>\n<p>断言 <code>x</code> 必须大于 <code>0</code>，实际上 <code>x</code> 为 <code>-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出 <code>AssertionError</code>，而是正常打印了 <code>x</code> 的值。</p>\n<p>这是怎么肥四？为什么 <code>assert</code> 语句不起作用？</p>\n<p>这是因为 JVM 默认关闭断言指令，即遇到 <code>assert</code> 语句就自动忽略了，不执行。</p>\n<p>要执行 <code>assert</code> 语句，必须给 Java 虚拟机传递 <code>-enableassertions</code>（可简写为 <code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ java -ea Main.java\nException in thread &quot;main&quot; java.lang.AssertionError\n\tat Main.main(Main.java:5)</code></pre>\n\n<p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对 <code>com.itranswarp.sample.Main</code> 这个类启用断言。</p>\n<p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有 3 个<code>.</code>），表示对 <code>com.itranswarp.sample</code> 这个包启动断言。</p>\n<p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解 <code>JUnit</code> 的使用。</p>\n<p><strong>小结</strong></p>\n<p>断言是一种调试方式，断言失败会抛出 <code>AssertionError</code>，只能在开发和测试阶段启用断言；</p>\n<p>对可恢复的错误不能使用断言，而应该抛出异常；</p>\n<p>断言很少被使用，更好的方法是编写单元测试。</p>\n<p><strong>spring框架中单例beans是线程安全的吗</strong></p>\n<p>不是，Spring 框架中的单例 bean 不是线程安全的。<br>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 “singleton” 变更为 “prototype”，这样请求 bean 相当于 new Bean () 了， 保证线程安全了。</p>\n<p>有状态就是有数据存储功能。无状态就是不会保存数据。</p>\n<p>Spring 如何处理线程并发问题？<br>一般只有无状态的 Bean 才可以在多线程下共享，大部分是无状态的 Bean。当存有状态的 Bean 的时候，spring 一般是使用 ThreadLocal 进行处理，解决线程安全问题。</p>\n<p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。<br>同步机制采用了 “时间换空间” 的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了 “空间换时间” 的方式。<br>ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。</p>\n<ol>\n<li>在 <code>@Controller/@Service</code> 等容器中，默认情况下，scope 值是单例 - singleton 的，也是线程不安全的。</li>\n<li>尽量不要在 <code>@Controller/@Service</code> 等容器中定义静态变量，不论是单例 (singleton) 还是多实例 (prototype) 他都是线程不安全的。</li>\n<li>默认注入的 Bean 对象，在不设置 <code>scope</code> 的时候他也是线程不安全的。</li>\n<li>一定要定义变量的话，用 <code>ThreadLocal</code> 来封装，这个是线程安全的。</li>\n</ol>\n<h2 id=\"Spring-Bean-作用域\"><a href=\"#Spring-Bean-作用域\" class=\"headerlink\" title=\"Spring Bean 作用域\"></a><strong>Spring Bean 作用域</strong></h2><p>Spring 的 bean 作用域（scope）类型有 5 种：</p>\n<p>1、singleton: 单例，默认作用域。</p>\n<p>2、prototype: 原型，每次创建一个新对象。</p>\n<p>3、request: 请求，每次 Http 请求创建一个新对象，适用于 WebApplicationContext 环境下。</p>\n<p>4、session: 会话，同一个会话共享一个实例，不同会话使用不用的实例。</p>\n<p>5、global-session: 全局会话，所有会话共享一个实例。</p>\n<p>线程安全这个问题，要从单例与原型 Bean 分别进行说明。</p>\n<p><strong>「原型 Bean」</strong>对于原型 Bean, 每次创建一个新对象，也就是线程之间并不存在 Bean 共享，自然是不会有线程安全的问题。</p>\n<p><strong>「单例 Bean」</strong>对于单例 Bean, 所有线程都共享一个单例实例 Bean, 因此是存在资源的竞争。</p>\n<p>如果单例 Bean, 是一个无状态 Bean，也就是线程中的操作不会对 Bean 的成员执行<strong>「查询」</strong>以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。</p>\n<h3 id=\"spring-单例，为什么-controller、service-和-dao-确能保证线程安全？\"><a href=\"#spring-单例，为什么-controller、service-和-dao-确能保证线程安全？\" class=\"headerlink\" title=\"spring 单例，为什么 controller、service 和 dao 确能保证线程安全？\"></a><strong>spring 单例，为什么 controller、service 和 dao 确能保证线程安全？</strong></h3><p>Spring 中的 Bean 默认是单例模式的，框架并没有对 bean 进行多线程的封装处理。实际上大部分时间 Bean 是无状态的（比如 Dao） 所以说在某种程度上来说 Bean 其实是安全的。</p>\n<p>但是如果 Bean 是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变 bean 的作用域 把  <code>singleton</code> 改为 <code>protopyte</code>， 这样每次请求 Bean 就相当于是 new Bean () 这样就可以保证线程的安全了。</p>\n<p>有状态就是有数据存储功能 无状态就是不会保存数据</p>\n<p>controller、service 和 dao 层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。\n局部变量的固有属性之一就是封闭在执行线程中。\n它们位于执行线程的栈中，其他线程无法访问这个栈。</code></pre>\n\n<p>所以其实任何无状态单例都是线程安全的</p>\n<p>首先问 @Controller @Service 是不是线程安全的？</p>\n<p>答：默认配置下不是的。为啥呢？因为默认情况下 @Controller 没有加上 @Scope，没有加 @Scope 就是默认值 singleton，单例的。意思就是系统只会初始化一次 Controller 容器，所以每次请求的都是同一个 Controller 容器，当然是非线程安全的。</p>\n","feature":true,"text":"linux： DevOps的全名： Development Operations 开发自运维 首先来回顾一下整个开发流程： 需求 - 开发 - 测试 - 发布 - 部署 - 监控运维 项目管理（需求 &amp; BUG）：redmine 代码托管：gerrit（gitlab） 持...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"面试积累","slug":"面试积累","count":1,"path":"api/categories/面试积累.json"}],"tags":[{"name":"前后端","slug":"前后端","count":1,"path":"api/tags/前后端.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">前端：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%8E%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">后端：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%85%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B5%85%E5%85%8B%E9%9A%86%EF%BC%89\"><span class=\"toc-text\">浅复制（浅克隆）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E5%85%8B%E9%9A%86%EF%BC%89\"><span class=\"toc-text\">深复制（深克隆）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">什么时候使用断言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Bean-%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">Spring Bean 作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#spring-%E5%8D%95%E4%BE%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-controller%E3%80%81service-%E5%92%8C-dao-%E7%A1%AE%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F\"><span class=\"toc-text\">spring 单例，为什么 controller、service 和 dao 确能保证线程安全？</span></a></li></ol></li></ol></li></ol>","author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"网上的面试题","uid":"3af103a46c3b6ba55fd2cb594bfaa7e8","slug":"面试题2","date":"2022-01-07T14:32:21.000Z","updated":"2022-01-15T16:18:20.132Z","comments":true,"path":"api/articles/面试题2.json","keywords":"Java","cover":[],"text":"3.1 Java 相关3.1.1 ArrayList 使用场景：ArrayList 的底层是一个数组，适合快速匹配，不适合频繁的增删 允许 add null 值，会自动扩容，其中 size (),isEmpty (),get (),add () 方法的复杂度为 O (1) 使用 ...","link":"","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"34 mins."},"categories":[{"name":"面试","slug":"面试","count":1,"path":"api/categories/面试.json"}],"tags":[{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"feature":true}}