{"title":"网上的面试题","uid":"3af103a46c3b6ba55fd2cb594bfaa7e8","slug":"面试题2","date":"2022-01-07T14:32:21.000Z","updated":"2022-01-15T16:18:20.132Z","comments":true,"path":"api/articles/面试题2.json","keywords":"Java","cover":[],"content":"<h3 id=\"3-1-Java-相关\"><a href=\"#3-1-Java-相关\" class=\"headerlink\" title=\"3.1 Java 相关\"></a>3.1 Java 相关</h3><h3 id=\"3-1-1-ArrayList\"><a href=\"#3-1-1-ArrayList\" class=\"headerlink\" title=\"3.1.1 ArrayList\"></a>3.1.1 ArrayList</h3><ul>\n<li>使用场景：ArrayList 的底层是一个数组，适合快速匹配，不适合频繁的增删</li>\n<li><strong>允许</strong> add null 值，会自动扩容，其中 size (),isEmpty (),get (),add () 方法的复杂度为 O (1)</li>\n<li>使用 Collentions.synchronizedList ()，实现线程安全或者 Vector 也可（Vector 在方法上加的 synchronized 锁）</li>\n<li>调用无参构造函数的时候，在 JDK1.8 默认为空数组（<strong>DEFAULT_EMPTY_ELEMENTDATA</strong> = {}），数字大小为 10 是我们第一次调用 add 方法是进行扩容的数组大小<br>若我们在执行构造函数传入的数组大小为 0 时，它使用的不是 DEFAULT_EMPTY_ELEMENTDATA，而是另一个空数组 <strong>EMPTY_ELEMENTDATA</strong> = {}（这个知识点面试没说过）</li>\n<li>add 方法的过程<br>先确定数组大小是否足够，如果我们创建 ArrayList 的时候指定了大小，那么则以给定的大小创建一个数组，否则默认大小为 10；容量够大的情况，直接赋值；如果容量不够大，则进行扩容方法 grow ()，扩容的大小为原来大小的 1.5 倍（newCapicity = oldCapicity + oldCapicity&gt;&gt; 1，其中 &gt;&gt;1，右移一位除以 2），如果扩容后的大小还不够的话，则会将数组大小直接设置为我们需要的大小，扩容的最大值为 Integer.MAX_VALUE，之后会调用 Arrays.copyOf () 方法将原数组中的数组复制过来<br>其中 Arrays.copyOf () 底层调用的是 System.arrayCopy ()，大家可以去简单了解下</li>\n<li>remove 方法<br>该方将被删除位置后的元素<strong>向前复制</strong>，底层调用的也是 System.arrayCopy () 方法，复制完成后，将数组元素的最后一个设置为 null（因为向前复制一个位置，所以最后位置的元素是重复的），这样就解决了复制重复元素的问题</li>\n<li>迭代器和增强 for 是一样的（这是一个 Java 语法糖，我后边还会再写语法糖相关的），过程中会判断 modCount 的值是否符合循环过程中的期望，如果不符合的话则会抛出并发修改异常，比较常见的情况就是在增强 for 中进行删除操作</li>\n</ul>\n<h3 id=\"3-1-2-LinkedList\"><a href=\"#3-1-2-LinkedList\" class=\"headerlink\" title=\"3.1.2 LinkedList\"></a>3.1.2 LinkedList</h3><ul>\n<li>使用场景：适合增删，不适合快速匹配</li>\n<li>底层数据结构是双向链表，每一个节点为 Node，有 pre 和 next 属性</li>\n<li>提供从头添加和从尾添加的方法，节点删除也提供了从头删除和从尾删除的方法</li>\n</ul>\n<h3 id=\"3-1-3-HashMap\"><a href=\"#3-1-3-HashMap\" class=\"headerlink\" title=\"3.1.3 HashMap\"></a>3.1.3 HashMap</h3><ul>\n<li>底层数据结构：数组 + 链表 + 红黑树</li>\n<li>允许 put null 值，HashMap 在调用 hash 算法时，如果 key 为 null，那么 hash 值为 0，这一点区别于 HashTable 和 ConcurrentHashmap<br>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</li>\n<li>loadFactor：负载因子默认为 0.75，是均衡了时间和空间损耗计算出来的，较高的值会减少空间的开销，扩容减小，数组大小增加速度变慢，但是增加了查找的成本，hash 冲突增加，链表变长</li>\n<li>如果有很多需要储存到 HashMap 中的数据，要在一开始把它的容量设置为足够大，防止出现不断扩容</li>\n<li>通过 Collections.synchronizedMap () 来实现线程安全或者使用 ConcurrentHashmap</li>\n<li>需要记住的字段如下</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">DEFAULT_INITIAL_CAPICITY &#x3D; 1 &lt;&lt; 4; 默认大小为16\nMAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30; 最大容量\nDEFAULT_LOAD_FACTOR &#x3D; 0.75f; 默认负载因子\nTREEIFY_THRESHOLD &#x3D; 8; UNTREEIFY_THRESHOLD &#x3D; 6; 树化和退化为链表的阈值\nMIN_TREEIFY_CAPACITY &#x3D; 64; 链表转化为红黑树时需要的数组大小\nthreshold 表示扩用的阈值，大小为 数组大小*负载因子</code></pre>\n\n<ul>\n<li>put 过程<br>首先会判断数组有没有进行初始化，没有的话，先执行初始化操作，resize () 方法<br>(n - 1) &amp; hash 用来定位到数组中具体的位置，如果数组中的该位置为空，直接在该位置添加值<br>如果数组当前位置有值的话，如果是链表，采用的是尾插发，并且当链表长度大于等于 8 时，会进行树化操作；如果是红黑树的话，则会调用红黑树的插入值的方法；添加完成后，会判断 size 是否大于 threshold，是否需要扩容，若扩容的话，数组大小为之前的 2 倍大小，扩容完成后，将原数组上的节点移动到新数组上。<br>一篇我觉得写得不错的博客儿：<a href=\"http://link.zhihu.com/?target=https://blog.csdn.net/u010425839/article/details/106620440?utm_source=app&app_version=4.5.3\">HashMap 扩容时的 rehash 方法中 (e.hash &amp; oldCap) == 0 算法推导</a></li>\n<li>为什么树化操作的阈值是 8？<br>链表的查询时间复杂度为 O (n)，红黑树的查询时间复杂度为 O (logn)，在数据量不多的时候，使用链表比较快，只有当数据量比较大的时候，才会转化为红黑树，但是红黑树占用的空间大小是链表的 2 倍，考虑到时间和空间上的损耗，所以要设置边界值（其实链表长度为 8 的概率很低，在 HashMap 注释中写了，出现的概率不择千万分之一，红黑树只是为了在极端情况下来保证性能）</li>\n<li>为什么还要有一个阈值是 6？（去年面试快手的时候问过）<br>避免频繁的进行树退化为链表的操作，因为退化也是有开销的，当我们移除一个红黑树上的值的时候，如果只有阈值 8 的话，那么它会直接退化，我们若再添加一个值，它有可能又需要变为红黑树了，添加阈值 6 相当于添加了一个缓冲</li>\n<li>hash 算法<br>(key == null) ? 0 : (h = key.hashCode ()) ^ (h &gt;&gt;&gt; 16)，右移 16 位的操作使得 hash 值更加分散</li>\n<li>为什么数组大小始终为 2 的 n 次幂？<br>因为在确定某个值在数组位置的下标时，采用的是（数组大小 - 1）位与上 hash 值，而数组大小减一之后，用 2 进制表示最后几位都是 1，这样每位在位与运算之后，不是 0 就是 1，如果我们 hash 值是均匀分布的话，那么我们得到的数组下表也是均匀分布的，而如果我们的数组容量不是 2 的 n 次幂，那么就没有这个特性了</li>\n<li>数组大小为什么默认是 16？<br>16 是一个经验值，2，4，8 有些小，会频繁的扩容，32 有些大，这样就多占用了空间</li>\n<li>为什么 JDK1.8 采用了尾插法？<br>JDK1.7 时采用的是头插法，它在扩容后 rehash，会使得链表的顺序颠倒，引用关系发生了改变，那么在多线程的情况下，会出现链表成环而死循环的问题，而尾插法就不会有这样的问题，rehash 后链表顺序不变，引用关系也不会发生改变，也就不会发生链表成环的问题</li>\n<li>红黑树的 5 个特点<br>根节点是黑色；<br>所有叶子节点是黑色；<br>其他节点是红色或黑色；<br>从每个叶子节点到根节点所有路径上不能有两个连续的红色节点；<br>从任一节点到每个叶子节点的所有简单路径上包含相同数量的黑色节点</li>\n<li>HashMap 和 Hashtable 的区别<br>实现方式不同：Hashtable：继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类<br>初始容量不同：HashMap 的初始容量为 16，Hashtable 为 11，负载因子都是 0.75<br>扩容机制不同：HashMap 是翻 2 倍，Hashtable 是翻两倍 + 1</li>\n</ul>\n<h3 id=\"3-1-4-HashSet、TreeMap、TreeSet、LinkedHashMap、LinkedHashSet\"><a href=\"#3-1-4-HashSet、TreeMap、TreeSet、LinkedHashMap、LinkedHashSet\" class=\"headerlink\" title=\"3.1.4 HashSet、TreeMap、TreeSet、LinkedHashMap、LinkedHashSet\"></a>3.1.4 HashSet、TreeMap、TreeSet、LinkedHashMap、LinkedHashSet</h3><ul>\n<li>HashSet 底层基于 HashMap 实现，若想实现线程安全，需要使用 Collections.synchronizedSet ();<br>它在底层组合的 HashMap，并没有继承关系，其中 Value 值使用的都是被声明为 Object 的 PRESENT 对象<br>private static final Object PRESENT = new Object();</li>\n<li>TreeMap 的底层数据结构是红黑树，会对 key 进行排序，维护 key 的大小关系<br>我们可以传入比较器 Comparator 或者让作为 key 对象的类实现 Comparable 接口重写 compareTo 方法<br>禁止添加 null 值</li>\n<li>LinkedHashMap 本身继承了 HashMap，拥有 HashMap 的所有特性，在此基础上添加了两个新的特性：<br>能按照插入的顺序进行访问（不过它仅仅提供了单向访问，即按照插入的顺序从头到尾访问）；<br>能实现访问最少最先删除的功能（LRU 算法）</li>\n<li>LinkedHashSet 底层基于 LinkedHashMap 实现</li>\n</ul>\n<h3 id=\"3-1-5-ConcurrentHashMap（JDK1-8）\"><a href=\"#3-1-5-ConcurrentHashMap（JDK1-8）\" class=\"headerlink\" title=\"3.1.5 ConcurrentHashMap（JDK1.8）\"></a>3.1.5 ConcurrentHashMap（JDK1.8）</h3><ul>\n<li>底层基于 CAS + synchronized 实现，所有操作都是线程安全的，允许多个线程同时进行 put、remove 等操作</li>\n<li>底层数据结构：数组、链表和红黑树的基础上还添加了一个转移节点，在扩容时应用</li>\n<li>table 数组被 volatile 修饰</li>\n<li>其中有一个比较重要的字段，sizeCtl<br>= -1 时代表 table 正在初始化<br>table 未初始化时，代表需要初始化的大小<br>table 初始化完成，表示 table 的容量，默认为 0.75table 大小</li>\n<li>put 过程<br>key 和 value 都是不能为空的，否则会产生空指针异常，之后会进入自旋（for 循环自旋），如果当前数组为空，那么进行初始化操作，初始化完成后，计算出数组的位置，如果该位置没有值，采用 CAS 操作进行添加；如果当前位置是转移节点，那么会调用 helptransfer 方法协助扩容；如果当前位置有值，那么用 synchronized 加锁，锁住该位置，如果是链表的话，采用的是尾插发，如果是红黑树，则采用红黑树新增的方法，新增完成后需要判断是否需要扩容，大于 sizeCtl 的话，那么执行扩容操作</li>\n<li>初始化过程<br>在进行初始化操作的时候，会将 sizeCtl 利用 CAS 操作设置为 - 1，CAS 成功之后，还会判断数组是否完成初始化，有一个双重检测的过程<br>过程：进入自旋，如果 sizeCtl &lt;0, 线程礼让（Thread.yield ()）等待初始化；否则 CAS 操作将 sizeCtl 设置为 - 1，再次检测是否完成了初始化，若没有则执行初始化操作</li>\n<li>在 JDK1.7 采用的是 Segment 分段锁，默认并发度为 16</li>\n</ul>\n<h3 id=\"3-1-6-CopyOnWriteArrayList\"><a href=\"#3-1-6-CopyOnWriteArrayList\" class=\"headerlink\" title=\"3.1.6 CopyOnWriteArrayList\"></a>3.1.6 CopyOnWriteArrayList</h3><ul>\n<li>线程安全的，通过锁 + 数组拷贝 + volatile 保证线程安全（底层数组被 volatile 修饰）</li>\n<li>每次进行数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作之后再赋值回去</li>\n<li>对数组的操作，一般分为四步<br>1 加锁<br>2 从原数组中拷贝出新数组<br>3 在新数组上进行操作，并把新数组赋值给原引用<br>4 解锁</li>\n<li>已经加锁了，为什么还需要拷贝新数组？<br>因为在原数组上进行修改，没有办法触发 volatile 的可见性，需要修改内存地址，即将新拷贝的数组赋值给原引用</li>\n<li>在进行写操作的时候，是能读的，但是读的数据是老数组的，能保证数组最终的一致性，不能保证实时一致性；</li>\n<li>存在内存占用问题，写时复制比较影响性能</li>\n</ul>\n<h3 id=\"3-1-7-String\"><a href=\"#3-1-7-String\" class=\"headerlink\" title=\"3.1.7 String\"></a>3.1.7 String</h3><ul>\n<li>不变性：类被 final 修饰，不可被继承；String 中保存的是一个字符数组，被 final 修饰，这样它的内存地址是不能改变的，另外它的访问权限是 private，外部无法访问，也没有公开出对其直接修改的 API，所以能保持不变</li>\n<li>equals 方法得看一看</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public boolean equals(Object anObject) &#123;\n    if (this &#x3D;&#x3D; anObject) &#123;\n        &#x2F;&#x2F;内存地址一致的话，为true\n        return true;\n    &#125;\n    &#x2F;&#x2F;判断是不是String类\n    if (anObject instanceof String) &#123;\n        String anotherString &#x3D; (String)anObject;\n        int n &#x3D; value.length;\n        &#x2F;&#x2F;判断字符串长度是否相等，不等直接返回不等\n        if (n &#x3D;&#x3D; anotherString.value.length) &#123;\n            char v1[] &#x3D; value;\n            char v2[] &#x3D; anotherString.value;\n            int i &#x3D; 0;\n            &#x2F;&#x2F;依次比较每个字符\n            while (n-- !&#x3D; 0) &#123;\n                if (v1[i] !&#x3D; v2[i])\n                    return false;\n                i++;\n            &#125;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h3 id=\"3-1-8-基本类型包装类\"><a href=\"#3-1-8-基本类型包装类\" class=\"headerlink\" title=\"3.1.8 基本类型包装类\"></a>3.1.8 基本类型包装类</h3><ul>\n<li>自动装箱与拆箱是 Java 语法糖，发生在编译期（深入理解 JVM 中的前端编译优化）</li>\n<li>Character 的缓存为 0-127；Byte、Short、Integer、Long 的缓存为 -128-127，若使用的值是这个范围的值，则直接在缓存中取</li>\n<li>float 和 double 在计算中发生精度损失的问题<br>十进制数能转化为二进制数；而小数有时候不能用二进制数进行表示，会造成精度丢失<br>解决办法：使用 BigDecimal，传入构造函数的参数是 String</li>\n</ul>\n<h3 id=\"3-1-9-hashCode-和-equals-方法\"><a href=\"#3-1-9-hashCode-和-equals-方法\" class=\"headerlink\" title=\"3.1.9 hashCode () 和 equals () 方法\"></a>3.1.9 hashCode () 和 equals () 方法</h3><ul>\n<li>hashCode 是 Object 类中一个被 native 修饰的方法，通常是将对象的内存地址转换为整数后返回</li>\n<li>为什么重写 hashCode 必须重写 equals？<br>两个对象相等，hashCode 一定相等；而 hashCode 相等，两个对象不一定相等，需要用 equals 进一步比较</li>\n</ul>\n<h3 id=\"3-1-10-封装、继承和多态\"><a href=\"#3-1-10-封装、继承和多态\" class=\"headerlink\" title=\"3.1.10 封装、继承和多态\"></a>3.1.10 封装、继承和多态</h3><ul>\n<li>你是如何理解面向对象的三个特征的？（京东一面问过）<br>面向对象的特性是封装、继承和多态，封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化，这样做使得代码的复用性更高；继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性，这样做扩展了已存在的代码块，进一步提高了代码的复用性；多态是为了实现接口重用，多态的一大作用就是为了解耦，允许父类引用 (或接口) 指向子类 (或实现类) 对象。多态的表现形式有重写和重载</li>\n<li>说说重写和重载<br>重写发生在父类与子类之间，方法名相同，参数列表相同，返回值可以 “变小”，抛出的异常可以 “变小”，访问修饰符权限不能变小，发生在运行期<br>重载实在一个类中，方法名相同，参数列表不同（参数顺序不同也行），返回值和访问修饰符可以不同，发生在编译期</li>\n</ul>\n<h3 id=\"3-1-11-反射\"><a href=\"#3-1-11-反射\" class=\"headerlink\" title=\"3.1.11 反射\"></a>3.1.11 反射</h3><ul>\n<li>对于任何一个类，都能获取它的方法和属性，动态获取信息和动态调用方法的功能是反射</li>\n</ul>\n<h3 id=\"3-1-12-Java-语法糖（《深入理解-JVM-第三版》第-10-章-前端编译优化）\"><a href=\"#3-1-12-Java-语法糖（《深入理解-JVM-第三版》第-10-章-前端编译优化）\" class=\"headerlink\" title=\"3.1.12 Java 语法糖（《深入理解 JVM 第三版》第 10 章 前端编译优化）\"></a>3.1.12 Java 语法糖（《深入理解 JVM 第三版》第 10 章 前端编译优化）</h3><ul>\n<li>泛型 Java 选择的是 “类型擦除似泛型”，在.java 源代码经过编译成.class 文件后，泛型相关的信息就消失了，泛型是在编译器层面来保证的<br>泛型上界，编译器指导里边存的是 T 的子类，但是不知道是什么具体的类型，只能取，不能往里放<br>泛型下界，能往里放，也能往外拿，但是拿出来的全是 Object 类型，这就使得元素类型失效了</li>\n<li>自动装箱和拆箱</li>\n<li>增强 for 循环，编译后会变为使用迭代器的形式</li>\n<li>条件编译，在 if 条件中，若条件为布尔常量，编译器会把分支中不成立的代码消除掉</li>\n<li>字符串拼接，编译时会自动创建 StringBuilder 对象执行 append 方法拼接</li>\n<li>枚举，编译器会自动创建一个被 final 修饰的枚举<strong>类</strong>继承了 Enum，所以自定义枚举类型是无法被继承的</li>\n<li>还有其他的语法糖，lambda 表达式等等，大家感兴趣可以再去了解…</li>\n</ul>\n<h3 id=\"3-2-JVM-（《深入理解-JVM-第三版》-紫皮儿的，求求了，看看吧，真的挺好的）\"><a href=\"#3-2-JVM-（《深入理解-JVM-第三版》-紫皮儿的，求求了，看看吧，真的挺好的）\" class=\"headerlink\" title=\"3.2 JVM （《深入理解 JVM 第三版》 紫皮儿的，求求了，看看吧，真的挺好的）\"></a>3.2 JVM （《深入理解 JVM 第三版》 紫皮儿的，求求了，看看吧，真的挺好的）</h3><h3 id=\"3-2-1-Java-内存区域\"><a href=\"#3-2-1-Java-内存区域\" class=\"headerlink\" title=\"3.2.1 Java 内存区域\"></a>3.2.1 Java 内存区域</h3><ul>\n<li>程序计数器：当前线程的字节码行号指示器，字节码解释器的工作就是通过改变计数器的值来来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成<br>线程私有，没有 OutOfMemoryError 情况</li>\n<li>Java 虚拟机栈：Java 方法执行的线程内存模型，每个方法被执行的时候，Java 虚拟机都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接、方法出口等信息<br>局部变量表中存储的是基本数据类型，对象的引用和 returnAddress 类型<br>线程私有，生命周期与线程相同<br>如果线程请求的栈深度大于虚拟机所允许的深度，会发生 StackOverflowError，若栈容量支持动态扩展，那么可以发生 OutOfMemoryError 情况，在 HotSpot 虚拟机中不会发生 OutOfMemoryError</li>\n<li>本地方法栈：为被 native 修饰的方法提供服务，与虚拟机栈类似</li>\n<li>Java 堆：所有对象实例以及数组都在堆上分配内存，也是垃圾回收器主要管理的内存区域<br>被所有线程共享的一块区域，当堆内存不够用时，会抛出 OutOfMemoryError</li>\n<li>方法区<br>用于储存被虚拟机加载的：类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据；在 JDK1.8 采用元空间来实现<br>也是线程共享的区域，垃圾回收主要针对常量池的回收和类型卸载，但是类型卸载比较苛刻<br>当方法区无法满足内存分配需求时，将会抛出 OutOfMemoryError</li>\n<li>类型卸载的条件<br>该类所有实例已经被回收<br>加载该类的类加载器已经被回收（Java 自带的三个类加载器不会被回收，那么只有我们自己创建的类加载器加载的类型能被回收）<br>该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法</li>\n</ul>\n<h3 id=\"3-2-2-对象的创建过程？\"><a href=\"#3-2-2-对象的创建过程？\" class=\"headerlink\" title=\"3.2.2 对象的创建过程？\"></a>3.2.2 对象的创建过程？</h3><ul>\n<li>当 Java 虚拟机遇到一条 new 指定后，首先检查这个这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过（简单点儿说，首先检查对应的类型是否被加载过），若没有，则需要先执行类加载的过程，类加载通过后，为新生对象分配内存，并附上初始值 0 值并设置对象头信息，之后执行构造函数，进行对象的初始化，完成对象的创建</li>\n<li>对象的组成？<br>对象头：MarkWord 和类型指针（确定该对象是哪个类的实例）<br>实例数据：存储各种类型的字段<br>对其填充：任何对象都是 8 字节的整数倍，不足时用它来补齐，非必须有</li>\n<li>啥是 MarkWord？<br>MarkWord 是一个有着动态定义的数据结构，包括哈希码，GC 分代年龄，线程持有的锁，偏向线程 Id，偏向时间戳等（图：《深入理解 JVM 》 p482）</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-96eb43c55075d9e67079b26d20cb348a_1440w.jpg?source=3af55fa1\" alt=\"img\"></p>\n<h3 id=\"3-2-3-内存溢出你给我说说？OutOfMemoryError-和-StackOverFlowError\"><a href=\"#3-2-3-内存溢出你给我说说？OutOfMemoryError-和-StackOverFlowError\" class=\"headerlink\" title=\"3.2.3 内存溢出你给我说说？OutOfMemoryError 和 StackOverFlowError\"></a>3.2.3 内存溢出你给我说说？OutOfMemoryError 和 StackOverFlowError</h3><ul>\n<li>如何产生 OutOfMemory？<br>堆内存不够用了，会抛出这个 OutOfMemoryError</li>\n<li>你能用什么方法来抛出这个 Error？<br>可以通过把堆内存通过参数 - Xmx 调小一些，然后写一个 while 的死循环，不断的执行 append 操作</li>\n<li>那如何产生 Stack Overflow Error？<br>这个是栈溢出，我们可以通过写两个方法，A 方法调用 B 方法，B 方法在调用 A 方法，这样可以产生这个 Error</li>\n<li>你还知道其他的 JVM 参数嘛？<br>知道，-Xms 指定堆的初始大小，-Xss 指定栈的大小，-XX:+HeapDumpOnOutOfMemoryError 内存快照的 Dump 文件，可以分析 Dump 文件来查看 OutOfMemoryError</li>\n<li>列举一些垃圾回收的参数（大家随便看看吧，面试没人问过我）<br>指定期望的 GC 的停顿时间（在 Parallel Scavenge、Parallel Old 和 G1 回收器中指定）：-XX:MaxGCPauseMills<br>改变 G2 的 Rigion 容量：-XX:G1HeapRegionSize<br>年轻代大小:-Xmn<br>比例：-XX:SurvivorRatio=8 (8:1:1)<br>大对象直接进入老年代的阈值：-XX:PretenureSizeThreshold</li>\n</ul>\n<h3 id=\"3-2-4-判断对象已死的算法？\"><a href=\"#3-2-4-判断对象已死的算法？\" class=\"headerlink\" title=\"3.2.4 判断对象已死的算法？\"></a>3.2.4 判断对象已死的算法？</h3><ul>\n<li>引用计数算法<br>Java 没有采用这种算法，如果产生对象的循环引用会使对象无法被回收</li>\n<li>可达性分析算法<br>从 GC Roots 根据引用关系乡下搜索，搜索过程中所走过的路径为 “引用链”，如果某个对象到 GC Roots 间没有任何引用链相连，则证明此对象是不可能再使用的</li>\n<li>你给我说说啥样的对象是 GC Roots？（《深入理解 JVM 》 p70）<br>在虚拟机栈中引用的对象<br>在方法区中静态属性引用的对象<br>在方法区中常量引用的对象<br>在本地方法栈中引用的对象<br>Java 虚拟机内部的引用（基本数据类型对应的 Class 对象，一些常驻的异常对象：NullPointException，OutOfMemoryError，还有系统类加载器）<br>被同步锁持有的对象<br>反映 Java 虚拟机内部情况的 JMXBean，JVMTI 中注册的回调，本地代码缓存等（面试我从没有说过这一条，再往下问我我不知道该怎么解释）</li>\n<li>对象不能被 GCRoots 引用关联就立即被回收嘛？<br>其实也不是的，通过可达性分析算法分析后发现对象没有和 GCRoots 发生引用，那么它会第一次被标记为可回收，对象可以实现 finalize () 方法，如果在该方法中能够使得对象再次发生与 GCRoots 引用，那么便可以避免被回收，这个方法只会被调用一次</li>\n</ul>\n<h3 id=\"3-2-5-引用关系-（《深入理解-JVM-》-p71）\"><a href=\"#3-2-5-引用关系-（《深入理解-JVM-》-p71）\" class=\"headerlink\" title=\"3.2.5 引用关系 （《深入理解 JVM 》 p71）\"></a>3.2.5 引用关系 （《深入理解 JVM 》 p71）</h3><ul>\n<li>强引用：引用赋值操作 Object o = new Object (); 无论什么情况下只用有强引用关系存在，那么对象就不会被回收</li>\n<li>软引用：SoftReference，还有用但是非必须的对象，在发生内存溢出前，会对这些对象进行回收，如果回收完成后再不够用，便抛出内存异常错误</li>\n<li>弱引用：WeakReference，在进行垃圾回收时，不论当前内存是否够用，都会将该引用的对象回收掉</li>\n<li>虚引用：PhantomReference，最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</li>\n</ul>\n<h3 id=\"3-2-6-垃圾回收算法\"><a href=\"#3-2-6-垃圾回收算法\" class=\"headerlink\" title=\"3.2.6 垃圾回收算法\"></a>3.2.6 垃圾回收算法</h3><ul>\n<li>标记复制算法：年轻代采用的都是标记复制算法，当一块内存用完了就把仍然存活的对象复制到另一块内存， 必然会产生一定空间的浪费，但是不会出现空间碎片的情况</li>\n<li>为什么 HotSpot 虚拟机采用 8：1：1 的比例分区？<br>根据绝大多数的对象都熬不过第一轮 GC，Hotspot 采用 8：1：1 的分配策略，90% 的空间为新生代可用内存空间，浪费的是 10%，符合对象朝生夕灭的特点，但是如果 10% 的内存不够用时，有逃生门策略来分配对象（逃生门指的是不够分配的对象直接到老年代）</li>\n<li>跨代引用的问题是如何解决的？（《深入理解 JVM 》 p84）<br>垃圾回收器在新生代中建立了记忆集数据结构，用来避免进行垃圾回收的时候把整个老年代的 GC Roots 都扫描一遍（卡表是记忆集的一种具体实现）</li>\n<li>标记清除算法：CMS 垃圾回收器采用的算法，这种算 *** 产生空间碎片</li>\n<li>标记整理算法：让所有的存活对象都向内存空间的一端移动，然后清理掉边界以外的内存，没有空间碎片的烦恼</li>\n</ul>\n<h3 id=\"3-2-7-几种垃圾回收器\"><a href=\"#3-2-7-几种垃圾回收器\" class=\"headerlink\" title=\"3.2.7 几种垃圾回收器\"></a>3.2.7 几种垃圾回收器</h3><ul>\n<li>Serial，面向年轻代的，单线程的的垃圾回收器，采用的是标记复制算法，在进行垃圾回收的时候，必须执行 Stop the world</li>\n<li>ParNew，实际上是 Serial 的多线程版本，同样是标记复制算法，也需要在垃圾回收的时候 Stop the world</li>\n<li>Parallel Scavenge，面向年轻代，也是多线程的，关注的是达到一个可控制的吞吐量，采用的是标记复制算法，也需要在垃圾回收的时候 Stop the world</li>\n<li>Serial Old，Serial 的老年代版本，采用的是标记整理算法，执行垃圾回收需要 Stop the world</li>\n<li>Parallel Old，是 Parallel Scavenge 的老年代版本，支持多线程并行收集，采用标记整理算法，同样也是关注吞吐量</li>\n<li>CMS，获取最短回收停顿为目标，更加关注服务器的响应速度，希望给用户更好交互体验，采用的是标记清除算法，执行过程分为如下四步（两停顿两并发），会产生空间碎片，无法解决 “浮动垃圾”<br>1 初始标记：标记 GC Roots 直接关联的对象，需要 Stop the world<br>2 并发标记：从 GC Roots 遍历能引用到的所有对象<br>3 重新标记：对并发标记阶段的标记进行修正，需要 Stop the world<br>4 并发清除：与用户线程一起运行，执行垃圾回收</li>\n<li>Garbage First，一个浪漫的名字，它是一款面向服务器端应用的垃圾回收器，发布的初衷是为了替代掉 CMS 垃圾回收器，它的垃圾回收机制是面向整个堆，并将其划分为各个大小相等的 Region，采用的算法是标记复制算法，它会维护一个优先级列表，根据我们设置的停顿时间来选择回收收益最大的 Region 进行垃圾回收，将存活的对象复制到空的 Region 中，通过设置停顿时间可以达到在吞吐量和响应速度上的协调，它还有一个 Humongous 区域，只要对象大小超过 Region 的一半，便直接放在这个区域中，它的执行过程为以下四个步骤（三停顿一并发）<br>1 初始标记：标记 GC Roots 直接关联的对象，需要 Stop the world<br>2 并发标记：从 GC Roots 遍历能引用到的所有对象 （前连个阶段和 CMS 基本一致？？？）<br>3 最终标记：处理并发标记后的修正操作，需要 Stop the world<br>4 筛选回收：对各个 Rigion 的回收价值进行排序，根据用户期望的停顿时间按计划回收，并将被回收的 Region 中存活的对象复制到空的 Region 中，再清理掉旧的 Region，需要 Stop the world</li>\n<li>Shenandoha 和 ZGC 这个不大问</li>\n</ul>\n<h3 id=\"3-2-8-类加载（《深入理解-JVM-》-第七章）\"><a href=\"#3-2-8-类加载（《深入理解-JVM-》-第七章）\" class=\"headerlink\" title=\"3.2.8 类加载（《深入理解 JVM 》 第七章）\"></a>3.2.8 类加载（《深入理解 JVM 》 第七章）</h3><ul>\n<li>讲讲类的生命周期<br>类的生命周期是七个阶段，首先类的加载，然后是连接，连接阶段分为三个步骤，是验证、准备和解析，连接完成之后是初始化，完成初始化之后是类的使用，最后是类的卸载</li>\n<li>说说类加载的过程<br>类加载分三个阶段，加载、连接和初始化，其中连接阶段分为验证、准备和解析。<br>1 加载主要是加载二进制字节流，比如 Class 文件，在方法区中生成 Class 对象<br>2 验证阶段是确保 Class 文件中的字节流包含的信息是否符合《Java 虚拟机规范》的全部约束要求，保证这些信息不会危害虚拟机的安全<br>（有文件格式验证、元数据验证、字节码验证、符号引用验证，我面试从没被问过具体的这几个阶段）<br>3 准备阶段是为类中定义的变量（静态变量）分配内存并设置变量的初始值，但是有一种特殊情况，被 final 修饰的话，则会直接赋值为我们要指定的值（初始值！就是 0，false，null 那种，初始化阶段才是我们程序员写的值，谨记）<br>4 解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程，有类和接口的解析，字段解析、方法解析和接口方法解析（符号引用是以一组符号来描述所引用的目标，它是编译原理方面的概念，有被模块到处或者开放的包，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符，方法的句柄和方法类型，动态调用点和动态常量 《深入理解 JVM 》 p218；直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄）<br>5 初始化阶段是类加载的最后一个步骤，它会收集所有为类变量赋值和静态语句块中的语句，为这些静态变量赋值</li>\n<li>类加载的触发条件<br>1 使用 new 关键字实例化对象的时候<br>2 读取或设置一个类型的静态字段<br>3 调用一个类型的静态方法<br>4 使用反射的方法对类型进行反射调用的时候<br>5 进行类初始化时，如果父类没有初始化，要先触发其父类的初始化<br>6 当一个接口中定义了 JDK8 加入的默认方法，如果有这个接口的实现类发生了初始化，那么接口需要在这之前完成初始化</li>\n<li>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被用一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</li>\n<li>双亲委派机制</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-54223af37f64d069cb0a16021e12d0f3_1440w.jpg?source=3af55fa1\" alt=\"img\"></p>\n<p>工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类反馈自己无法完成这个加载请求，子加载器才会尝试自己去完成类加载的过程。</p>\n<ul>\n<li>双亲委派机制的作用：使得 Java 中的类随它的类加载器一起具备了层级关系，例如 Object 类，无论哪个类加载器要加载这个类，最终都会被启动类加载器加载，这样就使得 Object 类在类加载环境中始终是同一个类，若没有双亲委派机制的话，我们自己定义一个在 java.lang 目录下的 Object 类，那么系统中就会出现多个 Object 类</li>\n<li>如何破坏双亲委派机制？<br>重写 ClassLoader 中的 loadClass () 方法</li>\n</ul>\n<h3 id=\"3-2-9-如果大家有书的话，可以看看《深入理解-JVM-》的第十章和第十一章，前端编译优化和后端编译优化，可能第十章的语法糖能在面试的时候被问一下，第十一章就不大问，不过我实习的时候，带我的-mentor-说还蛮重要的\"><a href=\"#3-2-9-如果大家有书的话，可以看看《深入理解-JVM-》的第十章和第十一章，前端编译优化和后端编译优化，可能第十章的语法糖能在面试的时候被问一下，第十一章就不大问，不过我实习的时候，带我的-mentor-说还蛮重要的\" class=\"headerlink\" title=\"3.2.9 如果大家有书的话，可以看看《深入理解 JVM 》的第十章和第十一章，前端编译优化和后端编译优化，可能第十章的语法糖能在面试的时候被问一下，第十一章就不大问，不过我实习的时候，带我的 mentor 说还蛮重要的\"></a>3.2.9 如果大家有书的话，可以看看《深入理解 JVM 》的第十章和第十一章，前端编译优化和后端编译优化，可能第十章的语法糖能在面试的时候被问一下，第十一章就不大问，不过我实习的时候，带我的 mentor 说还蛮重要的</h3><h3 id=\"3-2-10-JVM-对锁的优化（《深入理解-JVM-》-p479）\"><a href=\"#3-2-10-JVM-对锁的优化（《深入理解-JVM-》-p479）\" class=\"headerlink\" title=\"3.2.10 JVM 对锁的优化（《深入理解 JVM 》 p479）\"></a>3.2.10 JVM 对锁的优化（《深入理解 JVM 》 p479）</h3><ul>\n<li>自旋锁与自适应自旋：互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，如果我们可以通过上后面请求锁的线程自旋一会儿，那么将会避免线程切换的开销，但是它还是要占用处理器时间的，如果自旋时间很短的话，它的效果很好，否则长时间的自旋只会白白的浪费处理器时间，自旋的默认值是 10 次；自适应自旋意味着自旋次数不再是固定的了，而是由前一个在同一个锁上的自旋时间及锁的拥有者的状态来决定的，如果很可能获得到锁，那么将自旋等待的次数增多，否则直接省略掉自旋过程，进入阻塞状态，避免浪费处理器资源</li>\n<li>锁消除：对被检测到不可能存在共享数据竞争的锁进行消除</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public String method(String s1, String s2, String s3) &#123;\n  StringBuffer stringBuffer &#x3D; new StringBuffer();\n  stringBuffer.append(s1);\n  stringBuffer.append(s2);\n  stringBuffer.append(s3);\n  return stringBuffer.toString();\n&#125;</code></pre>\n\n<ul>\n<li>锁粗化：如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，虚拟机将会把同步锁的范围扩大到整个操作序列的外部，比如上例中，加锁到第一个 append 操作，解锁到最后一个 append 结束</li>\n<li>轻量级锁：是通过 MarkWord 来实现的，在进入同步块的时候，虚拟机会在当前线程的栈帧空开辟出锁记录的空间，用来存储锁对象的 MarkWord 的拷贝，加锁操作是使用一次 CAS 操作把对象的 MarkWord 更新为指向锁记录的指针，解锁操作也是通过一次 CAS 操作实现的，把复制到锁记录空间的 MarkWord 替换回来；但是轻量级锁不能发生竞争，如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效了，必须要膨胀为重量级锁</li>\n<li>偏向锁：在无竞争的情况下把整个同步都消除掉，连 CAS 操作都省去了，（偏就是偏袒的意思，会偏向第一个获取到它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不再需要进行同步），当锁对象第一次被线程获取的时候，通过 CAS 操作把获取到这个锁的线程 ID 记录到对象的 MarkWord 中，CAS 成功的话，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都不会再进行任何同步操作，一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式立刻宣告结束。<br>当对象进入偏向状态的时候，MarkWord 大部分空间都用于存储持有锁的线程 ID 了，若计算一次哈希值后，就需要在该位置存储哈希值，而不能再进入偏向锁模式了，而当一个对象处于偏向锁模式，又收到了需要计算其一致性哈希值的请求，它的偏向模式会理解被撤销，并且锁会膨胀为重量级锁</li>\n</ul>\n<h3 id=\"3-3-Java-并发编程\"><a href=\"#3-3-Java-并发编程\" class=\"headerlink\" title=\"3.3 Java 并发编程\"></a>3.3 Java 并发编程</h3><h3 id=\"3-3-1-创建线程的-3-种方式\"><a href=\"#3-3-1-创建线程的-3-种方式\" class=\"headerlink\" title=\"3.3.1 创建线程的 3 种方式\"></a>3.3.1 创建线程的 3 种方式</h3><pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public class StarThread1 extends Thread&#123;\n\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;开启线程的第一种方式，继承Thread并重写它的run方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StarThread1 starThread1 &#x3D; new StarThread1();\n\n        starThread1.start();\n    &#125;\n&#125;\npublic class StarThread2 implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;实现runnable接口，重写run方法，并在开启线程时将其传入&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new Thread(new StarThread2()).start();\n    &#125;\n&#125;\npublic class StarThread3 implements Callable&lt;Void&gt; &#123;\n\n    @Override\n    public Void call() &#123;\n        System.out.println(&quot;创建线程的第三种方式，实现Callable接口&quot;);\n        System.out.println(&quot;用Callable接口创建任务，用线程池对其就行提交，返回值为Future，再调用get()方法，获取结果&quot;);\n        System.out.println(&quot;或者将其作为参数传入新建的线程中&quot;);\n        return null;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ExecutorService pool &#x3D; Executors.newFixedThreadPool(1);\n        Future&lt;Void&gt; task &#x3D; pool.submit(new StarThread3());\n        task.get();\n        pool.shutdown();\n        System.out.println(&quot;--------------------------------------&quot;);\n        StarThread3 starThread3 &#x3D; new StarThread3();\n        FutureTask&lt;Void&gt; task1 &#x3D; new FutureTask&lt;&gt;(starThread3);\n        new Thread(task1).start();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-2-线程池相关\"><a href=\"#3-3-2-线程池相关\" class=\"headerlink\" title=\"3.3.2 线程池相关\"></a>3.3.2 线程池相关</h3><pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">import java.util.concurrent.*;\n\npublic class LearnThreadPoolExecutor &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F;CPU密集型,设置最大线程数为：CPU核数\n        Runtime.getRuntime().availableProcessors();\n        &#x2F;&#x2F;IO密集型，根据io任务的线程数来规定最大线程数量\n\n        &#x2F;&#x2F;核心线程数\n        &#x2F;&#x2F;最大线程数，线程池的伸缩性，达到开启条件后，才会不断开启\n        &#x2F;&#x2F;开启条件：当阻塞队列是ArrayBlockingQueue的时候，核心线程全部都处于工作状态，↓\n        &#x2F;&#x2F;且阻塞队列已经被任务塞满了，那么再来新的任务请求，便会开启新的线程\n        &#x2F;&#x2F;若是LinkedBlockingQueue的话，它会不断的存储任务，永远都不会向最大线程数进行线程的扩展！！！\n        &#x2F;&#x2F;活跃时间和活跃时间的单位，当线程的空闲时间超过活跃时间，线程就会被回收\n        &#x2F;&#x2F;阻塞队列：全部核心线程处于忙碌状态，新来的任务放在阻塞队列中\n        &#x2F;&#x2F; 最大承载：队列大小（如果是ArrayBlockingQueue的话）+最大的线程数\n        &#x2F;&#x2F;线程工厂，用于创建线程\n        &#x2F;&#x2F;拒绝策略:AbortPolicy:超过最大承载的话，会发生异常RejectedExecutionException\n        &#x2F;&#x2F;CallerRunsPolicy:哪来的去哪里执行，这里安排不了了\n        &#x2F;&#x2F;DiscardPolicy():多的任务都给我扔了，不执行！\n        &#x2F;&#x2F;DiscardOldestPolicy():将最早执行的任务停止掉，来执行新来的任务\n        ExecutorService threadPool &#x3D; new ThreadPoolExecutor(3, 5,\n                5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3),\n                Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy());\n\n        for (int i &#x3D; 0; i &lt; 33; i++) &#123;\n            int finalI &#x3D; i;\n            threadPool.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; ok &quot; + finalI);\n            &#125;);\n        &#125;\n\n        threadPool.shutdown();\n\n        &#x2F;&#x2F;线程池的作用：统一管理线程，实现线程的复用，更好的利用系统资源\n        &#x2F;&#x2F;四大方法，单个线程的池子；固定线程数的池子；自由伸缩的池子；执行定时任务的池子\n        &#x2F;&#x2F;前两个的阻塞队列为LinkedBlockingQueue\n        &#x2F;&#x2F;CachedThreadPool的阻塞队列为SynchronousQueue\n        ExecutorService singleThreadExecutor &#x3D; Executors.newSingleThreadExecutor();\n        ExecutorService fixedThreadPool &#x3D; Executors.newFixedThreadPool(8);\n        ExecutorService cachedThreadPool &#x3D; Executors.newCachedThreadPool();\n        ScheduledExecutorService scheduledThreadPool &#x3D; Executors.newScheduledThreadPool(10);\n\n        for (int i &#x3D; 0; i &lt; 33; i++) &#123;\n            cachedThreadPool.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName());\n            &#125;);\n        &#125;\n\n        &#x2F;&#x2F;关闭别忘了\n        cachedThreadPool.shutdown();\n\n        &#x2F;&#x2F;TODO 线程池的五种状态\n        &#x2F;&#x2F;RUNNING 接收新任务并处理排队中的任务\n        &#x2F;&#x2F;SHUTDOWN 不接受新任务，处理剩下的任务\n        &#x2F;&#x2F;STOP 不再接收新任务，不处理剩下的任务\n        &#x2F;&#x2F;TIDYING 所与线程都执行完了\n        &#x2F;&#x2F;TERMINATED 线程池终止了\n\n        &#x2F;&#x2F;TODO 线程池的执行流程\n        &#x2F;&#x2F;1. 如果要执行的线程小于核心线程数的话，开启核心线程，直接执行\n        &#x2F;&#x2F;2. 如果大于核心线程数的话，将进程放入阻塞队列中进行排队\n        &#x2F;&#x2F;3. 如果队列中满了话，会开启临时线程执行线程任务\n        &#x2F;&#x2F;4. 如果线程任务超过最大的阈值，也就是大于最大线程数+阻塞队列的值的话，就会采用拒绝策略\n\n        &#x2F;&#x2F;判断是否停止了\n        cachedThreadPool.isTerminated();\n        &#x2F;&#x2F;等待3秒后再进行判断\n        cachedThreadPool.awaitTermination(3, TimeUnit.SECONDS);\n\n        cachedThreadPool.execute( () -&gt; System.out.println(&quot;在shutDown之后，将不再能继续执行任务&quot;));\n\n        &#x2F;&#x2F;强制的立即结束\n        fixedThreadPool.shutdownNow();\n    &#125;\n&#125;</code></pre>\n\n<p>美团技术团队的博客：<a href=\"http://link.zhihu.com/?target=https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\">Java 线程池实现原理及其在美团业务中的实践</a></p>\n<h3 id=\"3-3-3-锁！\"><a href=\"#3-3-3-锁！\" class=\"headerlink\" title=\"3.3.3 锁！\"></a>3.3.3 锁！</h3><ul>\n<li>synchronized 的原理<br>依赖对象头中的 MarkWord 和 monitor 监视器，在 Hotspot 虚拟机中，是 ObjectMonitor 对象<br>其中 MarkWord 是实现偏向锁和轻量级锁的关键<br>monitor 是实现重量级锁的原理，当系统检测到是重量级锁的时候，会把等待想到获取锁的线程进行阻塞，被阻塞的线程不会消耗 CPU，但是阻塞和唤醒一个线程时，都需要操作系统来实现，而要完成用户态与内核态之间的转换，状态转换的开销会很大，对应的字节码指令是 monitorenter 和 monitorexit</li>\n<li>synchronized 和 Lock 的区别<br>1 synchronized 是 java 的关键字，在 JVM 层面；Lock 是 Java 的接口<br>2 synchronized 是非公平锁；Lock 可以设置为公平锁；都是可重入锁<br>3 synchronized 被线程获取后，其他线程必须等待；Lock 可以使用 tryLock 方法尝试获取锁，获取不到可以不等待<br>4 synchronized 会自动释放锁；Lock 需要在 finally 块中手动释放锁<br>5 ReentrantLock 可以绑定多个锁条件（Condition）</li>\n<li>ReentrantLock 的原理（你了解 AQS 嘛？）<br>ReentrantLock 的静态内部类 Sync 实现了抽象类 AQS（AbstractQueuedSynchronizer），其中有一个重要的字段是 state，它在 ReentrantLock 中代表的是重入次数，为 0 是代表锁没有被任何线程持有，为 1 是被一个线程持有，每重入一次，state 加一，每执行一次 unlock 方法，state 减一；而 ReentrantLock 的公平锁和非公平锁机制是通过 AQS 中的队列来实现的，若是公平锁的话，每有一个线程想要获取这个锁，需要进入队列排队，而且不能插队，若是非公平锁的话，队列中的线程是可以插队的</li>\n<li>CountDownLatch、Semaphore 的底层也是 AQS，也可以看看</li>\n</ul>\n<h3 id=\"3-3-4-CAS-是啥呀？\"><a href=\"#3-3-4-CAS-是啥呀？\" class=\"headerlink\" title=\"3.3.4 CAS 是啥呀？\"></a>3.3.4 CAS 是啥呀？</h3><ul>\n<li>CAS，比较并交换，实现它有三个重要的值，内存值、期望值和要修改的值，如果内存值和我们的期望值一致的话，才会将内存值修改为我们要修改的值，否则不进行修改</li>\n<li>ABA 问题，简单去了解一下吧，可以用 AtomicStampedReference 来避免</li>\n</ul>\n<h3 id=\"3-3-5-volatile？\"><a href=\"#3-3-5-volatile？\" class=\"headerlink\" title=\"3.3.5 volatile？\"></a>3.3.5 volatile？</h3><ul>\n<li>它有两个特性，一个是可见性，另一个是禁止指令重排<br>可见性是通过 JMM（Java 内存模型）来实现的，JMM 中有主内存，每个线程有自己的工作内存，线程需要对变量进行操作的时候需要将主内存中的值读到工作内存中，修改完成后，volatile 会使其他线程工作内存中的值失效，而且该线程必须将该值同步到主内存中，这样来保证可见性<br>禁止指令重排是通过内存屏障来实现的，在汇编层面，多执行了一个 “lock addl $0x0,(% esp)”，指令重排序是不能把后面的指令重排序到内存屏障之前的位置（《深入理解 JVM p448》）</li>\n</ul>\n<h3 id=\"3-3-6-其实说到-volatile，建议主动交代一下单例模式\"><a href=\"#3-3-6-其实说到-volatile，建议主动交代一下单例模式\" class=\"headerlink\" title=\"3.3.6 其实说到 volatile，建议主动交代一下单例模式\"></a>3.3.6 其实说到 volatile，建议主动交代一下单例模式</h3><ul>\n<li>双重检测锁单例</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public class DCLSingle &#123;\n\n  private static volatile DCLSingle single;\n\n  public static DCLSingle getSingle () &#123;\n      if (single &#x3D;&#x3D; null) &#123;\n          synchronized (DCLSingle.class) &#123;\n              if (single &#x3D;&#x3D; null)\n                  single &#x3D; new DCLSingle();\n          &#125;\n      &#125;\n      return single;\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>饿汉式</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public class Hungry &#123;\n\n  private static final Hungry hungrySingle &#x3D; new Hungry();\n\n  public static Hungry getInstance() &#123;\n      return hungrySingle;\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>懒汉式</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public class Lazy &#123;\n  private static Lazy lazySingle;\n\n  public Lazy() &#123;\n\n  &#125;\n\n  public static Lazy getLazySingle() &#123;\n      if (lazySingle &#x3D;&#x3D; null) &#123;\n          lazySingle &#x3D; new Lazy();\n      &#125;\n      return lazySingle;\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>静态内部类</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public class InnerClassLazy &#123;\n\n  &#x2F;&#x2F;静态内部类单例的持有者\n  private static class InnerSingleHolder &#123;\n      public static InnerClassLazy INSTANCE &#x3D; new InnerClassLazy();\n  &#125;\n\n  public static InnerClassLazy getSingleton () &#123;\n      return InnerSingleHolder.INSTANCE;\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>枚举</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public enum EnumSingle &#123;\n  ENUM_SINGLE;\n  public static EnumSingle getEnumSingle() &#123;\n      return ENUM_SINGLE;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-7-ThreadLocal\"><a href=\"#3-3-7-ThreadLocal\" class=\"headerlink\" title=\"3.3.7 ThreadLocal\"></a>3.3.7 ThreadLocal</h3><p><a href=\"http://link.zhihu.com/?target=https://blog.csdn.net/qq_46225886/article/details/107881764\">我写过的一篇关于 ThreadLocal 的博客儿</a></p>\n<h3 id=\"3-3-8-引用逃逸（this-escape）\"><a href=\"#3-3-8-引用逃逸（this-escape）\" class=\"headerlink\" title=\"3.3.8 引用逃逸（this escape）\"></a>3.3.8 引用逃逸（this escape）</h3><pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">public class ThisEscape &#123;\n    &#x2F;&#x2F;this引用逃逸 在构造函数中使用了this，该this代表的就是正在执行构造函数的对象（实例中 B构造的对象）\n    &#x2F;&#x2F;我们按线程来调断点\n    &#x2F;&#x2F;我们在B线程中执行的时候先把obj的引用暴露出去了，并让B线程在这里停下（打一个断点）\n    &#x2F;&#x2F;然后A线程会提前拿到这个引用，然而B线程中该构造器并没有执行完，是的i和j的值都为0，这就是引用逃逸\n    int i;\n    int j;\n    public static ThisEscape obj;\n\n    public ThisEscape() &#123;\n        obj &#x3D; this;\n        this.i &#x3D; 1;\n        this.j &#x3D; 1;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Thread threadB &#x3D; new Thread(() -&gt; &#123;\n            obj &#x3D; new ThisEscape();\n        &#125;,&quot;B&quot;);\n\n        Thread threadA &#x3D; new Thread( () -&gt; &#123;\n            ThisEscape objB &#x3D; obj;\n            System.out.println(objB.j);\n            System.out.println(objB.i);\n        &#125;,&quot;A&quot;);\n\n        threadB.start();\n        threadA.start();\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>this 引用逃逸，一般和 final 的禁止指令重排联系起来<br>被 final 修饰的变量在若在构造器中赋值，它是不会被重排到构造器之外的，除非出现 this 的引用逃逸，若没有逃逸的话，执行完构造函数，那么被 final 修饰的值一定是我们代码中给它赋的值</li>\n</ul>\n<h3 id=\"3-4-Spring、SpringMVC，MyBatis，SpringBoot（我只了解个皮毛罢了）\"><a href=\"#3-4-Spring、SpringMVC，MyBatis，SpringBoot（我只了解个皮毛罢了）\" class=\"headerlink\" title=\"3.4 Spring、SpringMVC，MyBatis，SpringBoot（我只了解个皮毛罢了）\"></a>3.4 Spring、SpringMVC，MyBatis，SpringBoot（我只了解个皮毛罢了）</h3><ul>\n<li>BeanFactory 和 ApplicationContext<br>BeanFactory 是 Spring 的底层接口，实现了对 Bean 的配置和管理；ApplicationContext 是 BeanFactory 的子接口，并且扩展了一些功能，包括 AOP，国际化，事件驱动，BeanPostProcessor 和 BeanFactoryPostProcessor</li>\n<li>Bean 的生命周期<br>它分两个阶段，一个是 BeanDefinition 阶段，另一个是 Bean 实例阶段<br>在 BeanDefinition 阶段，加载 xml 配置文件，将声明的 <code>&lt;bean&gt;</code> 转换为 BeanDefinition，解析注解配置类，在 refresh () 方法的 beanDefinitionRegistryPostProcessor 执行阶段，实现对 @Bean 注解方法的解析并封装成 BeanDefinition<br>在 Bean 实例阶段，首先进行 Bean 的实例化，在 refresh () 方法的 finishBeanFactoryInitialization () 方法中，初始化所有非延迟加载的 bean，实例化入口是 getBean (),doGetBean (), 先从三级缓存中去拿，如果缓存中没有的话，执行 createBean (),doCreateBean () 方法，通过调用 createBeanInstance () 方法生成 Bean 实例；之后进行 Bean 的初始化，执行 populateBean () 方法进行属性赋值和依赖注入，以及初始化阶段的方法回调，回调方法分别是被 @PostConstract 注解修饰的方法，之后执行的是 InitializingBean 的 afterPropertiesSet () 方法，再之后是 init-method 方法，之后再是后置处理器的后置回调；接下来是 Bean 的使用阶段；使用完成后要进行 Bean 的销毁，同样有三个回调方法，被 @PreDestroy 注解修饰的方法，DisposableBean 的 destroy () 方法，destroy-method 方法（注：初始化回调和销毁回调都是有先后顺序的，我就是按执行的先后顺序介绍的）</li>\n<li>Bean 的实例化方式<br>1 通过 <code>&lt;bean&gt;</code>, @Bean, @Component 的方式注册 Bean 后实例化<br>2 借助 FactoryBean 实例化 Bean (factory-bean + factory-method)<br>3 使用静态工厂实例化 Bean (factory-method)</li>\n<li>Spring 容器的三级缓存</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">&#x2F;&#x2F;一级缓存：用于存放完全初始好的bean，拿出来可以直接使用\nMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;(256);\n&#x2F;&#x2F;二级缓存：提前曝光的单例对象缓存，存放原始的bean对象（未填充属性），用于解决循环依赖\nMap&lt;String, Object&gt; earlySingletonObjects &#x3D; new HashMap&lt;&gt;(16);\n&#x2F;&#x2F;三级缓存：单例对象缓存，存放bean工厂对象，用于解决循环依赖\nMap&lt;String, ObjectFactory&gt; singltonFactories &#x3D; new HashMap&lt;&gt;(16);</code></pre>\n\n<ul>\n<li>Spring 事务的传播行为<br>1 REQUIRED：必需的（默认值）<br>如果当前没有事务运行，则会开启一个新的事务；如果当前已经有事务运行，则方 *** 运行在当前事务中，“你没有，我开启，你有了，我加入”<br>2 REQUIRES_NEW：新事务<br>如果当前没有事务事务运行，则会开启一个新的事务；如果当前已经有事务运行，则会将原事务挂起，重新开启一个新的事务。当新的事务运行完毕后，再将原来的事务释放，“你没有我开启，你有了我造新的”<br>3 SUPPORTS：支持<br>如果当前有事务运行，则方法运行在当前事务中；如果没有事务运行，则不在事务中运行，“有就有，没有拉到”<br>4 NOT_SUPPORTED：不支持<br>如果当前事务运行，则会将事务挂起，如果当前没有事务运行，则它也不会运行在事务中，“有我不要，没有正好”<br>5 MANDATORY：强制<br>当前方法必须在事务中，如果没有事务，则直接抛出异常，“要干活必须有，没有就打死不干”<br>6 NEVER：不允许<br>当前方法不允许运行在事务中，如果当前已经有事务运行，则抛出异常，“要干活不准有，有了不干活”<br>7 NESTED：嵌套<br>如果当前没有事务运行，则开启一个新的事务；如果当前已经有事务运行，则会记录一个保存点，并继续运行在当前事务中。如果子事务运行中出现异常，则不会全部回滚，而是回滚到哦上一个保存点</li>\n<li>Spring MVC 的处理流程</li>\n</ul>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0a1f10c6b2ce256d7b67eaf35ce13127_1440w.jpg?source=3af55fa1\" alt=\"img\"></p>\n<p>所有的请求发送给 DispatcherServlet 进行处理，DispatcherSerclet 去请求 HandlerMapping，找出容器中被 @Controller 注解修饰的 Bean 以及被 @RequestMapping 修饰的方法，生成 Handler 和 HandlerInterceptor 封装起来并以 HandlerExcutionChain 对象返回，之后 DispatcherServlet 会将 HandlerExcutionChain 发送给 HandlerAdaptor，通过 HandlerAdaptor 执行 Handler 的方法，执行完成后返回 ModelAndView 对象，DispatcherServlet 会把 ModelAndView 发送给 ViewResolver 进行解析，解析完成后返回 View 对象，并进行渲染发送给客户端</p>\n<ul>\n<li>MyBatis 缓存<br>使用缓存来减少与数据库交互的次数，从而提高运行效率，进行查询后，将结果放在缓存中，查询时从缓存中拿<br>一级缓存：是 SQLSession 级别的，操作数据库需要 SQLSession 对象，在对象中有一个 HashMap 用来缓存数据，在同一个 SQLSession 中执行两次相同的查询时，第一次会进行缓存，第二次从缓存中拿，执行修改操作后，缓存失效，保证数据的有效性<br>二级缓存：默认是关闭的，是 Mapper 级别的，当多个 SQLSession 使用同一个 Mapper 的 SQL 语句操作数据库的时候，得到的数据会在二级缓存中，也用 HashMap 存，作用域是 Mapper 的 namespace，不同的 SQLSession 两次执行相同的 SQL，第二次会从二级缓存中拿</li>\n<li><a href=\"http://link.zhihu.com/?target=https://blog.csdn.net/qq_46225886/article/details/107357084?spm=1001.2014.3001.5501\">SpringBoot 的自动装配原理</a></li>\n</ul>\n<h3 id=\"3-5-计算机网络和操作系统（准备这里的面试，我更像是一个赌徒）\"><a href=\"#3-5-计算机网络和操作系统（准备这里的面试，我更像是一个赌徒）\" class=\"headerlink\" title=\"3.5 计算机网络和操作系统（准备这里的面试，我更像是一个赌徒）\"></a>3.5 计算机网络和操作系统（准备这里的面试，我更像是一个赌徒）</h3><h3 id=\"3-5-1-七层和五层\"><a href=\"#3-5-1-七层和五层\" class=\"headerlink\" title=\"3.5.1 七层和五层\"></a>3.5.1 七层和五层</h3><ul>\n<li>七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>\n<li>五层：应用层、传输层、网络层、数据链路层、物理层</li>\n<li>应用层定义应用进程之间的通信和交互规则，有支持域名的 DNS，支持万维网的 HTTP，支持邮件的 SMTP</li>\n<li>传输层负责两台主机进程之间的通信，有 TCP 和 UDP 协议</li>\n<li>网络层负责不同主机间的通信，分数据平面和控制平面，数据平面负责转发，从输入链路接口到输出链路接口；控制平面负责路由选择，从源主机到目的主机的路由器该如何转发数据，有 IP 协议</li>\n<li>数据链路层是将网络层传递下来的 IP 数据报组装成帧，在两个相邻的节点之间链路上传输帧</li>\n</ul>\n<h3 id=\"3-5-2-TCP\"><a href=\"#3-5-2-TCP\" class=\"headerlink\" title=\"3.5.2 TCP\"></a>3.5.2 TCP</h3><ul>\n<li>TCP 是面向连接的传输层协议，提供全双工通信，连接是点对点的，提供可靠的交付服务</li>\n<li>TCP 报文结构：源端口和目的端口；序号（客户端和服务端随机生成一个初始值）；确认号（期望收到对方下一个报文段的第一个序号）；标志字段（URG 紧急标志，SYN 同步标志，FIN 终止标志）；接收窗口；校验和</li>\n<li>TCP 可靠原理<br>1 使用检验和来验证传输报文中的错误<br>2 使用定时器来用于超时重传<br>3 使用序号来检测丢失和冗余，使用确认应答来告诉发送方确认收到信息<br>4 TCP 使用流量控制和拥塞控制来保证可靠性<br>流量控制：发送方的发送速率与接收方的接收速率相匹配，通过报文中的接收窗口大小来指定流量<br>拥塞控制：在网络中对资源的请求超过资源可用量的情况叫拥塞（吞吐量小于理想吞吐量），TCP 的发送方会根据在目的路径之间没什么拥塞而增加发送速率，若有拥塞则降低发送速率。通过超时或连续接收到 3 个冗余的 ACK 来判断拥塞，发送速率由拥塞窗口来控制</li>\n<li>拥塞控制算法<br>发送方维护一个叫做拥塞窗口的状态变量 Cwnd，其值取决于网络拥塞程度，动态变化，慢开始算法阈值 ssthresh，发送窗口大小 Swnd<br>慢开始算法：发送窗口大小 = 拥塞窗口大小（一个较小的值 MSS），随着双方通信，收到确认应答报文，拥塞窗口指数级增长，超过慢开始阈值后，使用拥塞避免算法<br>拥塞避免算法：拥塞窗口随着传输轮次，呈线性增长<br>快重传算法：在传输过程中有报文丢失，发送方累计连续 3 次收到重复确认报文，就将相应的报文段立即重传，而不是在该报文段的超时重传计时器超时重传<br>快恢复：减小拥塞窗口的大小，再进行线性增长，开启拥塞避免算法</li>\n<li>三次握手<br>第一次握手：客户端发送建立连接的请求报文给服务器，其中 SYN = 1，ACK = 0<br>第二次握手：服务端收到连接请求报文后，发送一个确认建立连接的应答报文，其中 SYN = 1， ACK = 1<br>第三次握手：客户端收到服务器确认建立连接报文后，还要发送确认应答报文给服务器，其中 ACK = 1</li>\n<li>三次握手的原因<br>1 防止已经失效的连接请求报文突然传送到服务器产生脏连接<br>2 为了实现可靠的数据传输，TCP 连接双方都需要维护一个序列号，若是两次握手的话，服务端发送的序列号得不到确认（客户端可以接收到序列号，但是没有确认收到的回应发送给服务器）</li>\n<li>四次挥手<br>第一次挥手：客户端向服务器发送一个终止连接报文，FIN = 1<br>第二次挥手：服务器收到该报文后，发送给客户端一个确认报文，ACK = 1<br>第三次挥手：服务器在发送完数据，准备释放连接连接时，会向客户端发送终止连接报文，FIN = 1<br>第四次挥手：客户端收到后，发送确认报文，等待 2MSL 后，进入关闭状态</li>\n<li>四次挥手的原因<br>客户端和服务器采用的是全双工通信，发送方和接收方都需要发送 FIN 和 ACK 报文才能断开</li>\n<li>为什么要等待 2MSL 后才能释放连接？<br>1 等待 2MSL 可以保证连接的所有报文都会从网络上消失，防止新旧连接的混淆<br>2 保证服务端能接收到客户端发送的确认报文（如果该报文丢失，服务端没收收到就会超时重传之前的终止连接报文，若客户端直接进入 closed 状态，则无法收到该报文，也不会发送确认报文，那么服务器就无法正常进入 closed 状态）</li>\n<li>UDP<br>UDP 是面向非连接的，不维护连接状态，支持同时向多个客户端传输相同的信息，报文头只有 8 字节，尽最大努力交付，不保证数据可达</li>\n<li>TCP 和 UDP 的应用场景<br>TCP：文件传输，这种数据要求可靠性高的场景；浏览器访问（HTTP）；发送电子邮件<br>UDP：语音聊天；在线视频</li>\n</ul>\n<h3 id=\"3-5-3-HTTP\"><a href=\"#3-5-3-HTTP\" class=\"headerlink\" title=\"3.5.3 HTTP\"></a>3.5.3 HTTP</h3><ul>\n<li>HTTP 请求类型<br>1 GET 请求：请求获取数据，是幂等的，像数据库的查询请求，只是用来查询不对数据进行修改<br>2 POST 请求：向服务端提交数据进行处理，数据包含在请求体中，可能导致新的资源建立或修改<br>3 PUT 请求：向服务端发送数据进行修改<br>4 DELETE 请求：是用来删除某一资源的<br>5 HEAD 请求：当服务器收到 HEAD 请求时，将会一个 HTTP 报文进行响应，但并不返回请求对象，常用于方法调试跟踪（当我们发送一个 HEAD 请求到服务器时，会收到一个 HTTP 响应报文，但是其中并不包含我们请求的对象）</li>\n<li>HTTP 请求报文<br>请求行：方法，URL 字段，HTTP 版本<br>首部行：主机名；Connection（表示是否使用持续连接）；User-agent（显示浏览器类型）<br>空行<br>实体体：包含我们请求需要传递的数据</li>\n<li>HTTP 响应报文<br>状态行：HTTP 版本，状态码，状态信息<br>首部行：Connection；Date（时间）；Server（服务器）；Last-Modified（最后修改时间）；Content-length：对象字节数；Content-type（对象类型）<br>实体体：包含我们请求的对象</li>\n<li>HTTP 状态码（列出的我记不太住的…)<br>400 BadRequest 客户端请求语法错误<br>401 Unauthorized 请求未经授权<br>403 Forbidden 拒绝访问<br>500 Internal Server Error 服务器内部错误<br>503 Server Unavailable 服务器当前不能处理客户端的请求</li>\n<li>HTTP1.0 和 HTTP1.1<br>HTTP1.0 使用的是非持续性连接，另外每次请求都会有 2 倍的 RTT 开销，另外客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量，非持续性连接对服务器压力较大<br>HTTP1.1 使用的持续性连接，服务器会在发送响应后一段时间内继续保持这条连接，使同一个浏览器和服务器可以继续在这条连接上传输后续的 HTTP 请求和响应报文，支持请求流水线处理，在一个 TCP 连接上可以传送多个请求和响应</li>\n<li>HTTP 2.0<br>使用多了复用技术，做到同一个连接并发处理多个请求，相比于 HTTP1.1 在同一时间同一域名的限制好了几个数量级<br>HTTP2.0 支持使用 HPACK 算法对 HTTP 首部进行压缩，数据体积小，传输更快了<br>服务器推送：服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次请求获取数据</li>\n<li>HTTPS 是以安全为目标的 HTTP 通道，通过 S.S.L，Secure Sockets Layer 安全套接字协议<br>对称加密：使用相同的密钥进行加密，效率快，安全性好<br>非对称加密：加密和解密的密钥不同，通过双方接收到对方的公钥进行加密，使用私钥进行解密，效率慢，但是安全<br>HTTPS 采用混合加密机制，使用非对称加密用于传输对称加密使用的密钥，之后用对称加密进行通信，保证通信效率</li>\n<li>SSL 握手流程<br>浏览器和服务器建立 TCP 连接后，会发送一个请求，包含了自己可实现的算法列表和必要信息<br>服务器收到请求后，会选择加密算法，然后返回证书，包含非对称加密的公钥，加密算法，服务器信息，申请证书的公司，域名等<br>浏览器收到之后，检查签发证书的机构是否正确，公钥签名是否有效，若有效则生成对称密钥，利用公钥进行加密，发送给服务器<br>服务器收到密钥后，用私钥进行解密，之后浏览器和服务器就可以基于对称加密进行数据通信</li>\n<li>在浏览器输入 URL 对峙，回车后会发生什么？<br>1 先查询 web 缓存器，如果有的话则直接显示<br>2 通过 DNS 域名解析服务解析 IP 地址，先从浏览器缓存中查询，如果没有则查询本地 DNS 服务器的缓存<br>3 通过 TCP 的三次握手建立连接，建立连接后，向服务器发送 HTTP 请求<br>4 服务器收到浏览器的请求后，进行处理并发送响应报文<br>5 浏览器收到服务器的响应报文后，如果可以，进行缓存<br>6 浏览器渲染页面并呈现给用户<br>7 四次挥手断开连接</li>\n</ul>\n<h3 id=\"3-5-4-操作系统（我只赌的这两个问题）\"><a href=\"#3-5-4-操作系统（我只赌的这两个问题）\" class=\"headerlink\" title=\"3.5.4 操作系统（我只赌的这两个问题）\"></a>3.5.4 操作系统（我只赌的这两个问题）</h3><ul>\n<li>进程和线程的区别（谨慎参考）<br>进程是资源分配的基本单位，线程是 CPU 调度的基本单位<br>进程包含线程，一条线程只能在一个进程中<br>进程与进程之间是独立的，而线程与线程之间资源可以是共享的</li>\n<li>死锁的条件<br>互斥条件；不可剥夺条件；请求与保持条件；循环等待条件</li>\n</ul>\n<h3 id=\"3-6-Linux-命令（仅仅被问过一次，简历上没写-Linux）\"><a href=\"#3-6-Linux-命令（仅仅被问过一次，简历上没写-Linux）\" class=\"headerlink\" title=\"3.6 Linux 命令（仅仅被问过一次，简历上没写 Linux）\"></a>3.6 Linux 命令（仅仅被问过一次，简历上没写 Linux）</h3><ul>\n<li>ls 列出目录；cd 切换目录；pwd 显示当前目录；mkdir 创建目录；rmdir 删除目录</li>\n<li>cp 复制目录或文件；rm 移除文件或目录；mv 移动文件或目录</li>\n<li>cat 从第一行正序显示内容；tac 从最后一行开始显示内容；head -n20 显示前 20 行；tail 看尾几行</li>\n<li>top 常用的 Linux 性能分析命令，可以查看各个进程的资源占用状况</li>\n<li>开启端口 firewall-cmd –zone=public –add-port=80/tcp –permanent；firewall-cmd –state 查看状态；service firewall start/restar/stop 开启 / 重启 / 停止</li>\n<li>ps -ef|grep redis 查看 redis 的进程信息 （被问过这个）</li>\n</ul>\n<h3 id=\"3-7-MySQL（《MySQL-是怎样运行的》-这本书无敌！真的，大家有时间一定看看，掘金上也有电子版）\"><a href=\"#3-7-MySQL（《MySQL-是怎样运行的》-这本书无敌！真的，大家有时间一定看看，掘金上也有电子版）\" class=\"headerlink\" title=\"3.7 MySQL（《MySQL 是怎样运行的》 这本书无敌！真的，大家有时间一定看看，掘金上也有电子版）\"></a>3.7 MySQL（《MySQL 是怎样运行的》 这本书无敌！真的，大家有时间一定看看，掘金上也有电子版）</h3><ul>\n<li>三大范式（每一范式都在前一范式的基础上）<br>第一范式：每一列都是不可分割的原子项<br>第二范式：每一列都与主键列相关<br>第三范式：每一列与主键列直接相关</li>\n<li>MySQL 聚合函数<br>AVG(),SUM(),COUNT(),MAX(),MIN()…</li>\n</ul>\n<h3 id=\"3-7-1-索引（第六章和第七章）\"><a href=\"#3-7-1-索引（第六章和第七章）\" class=\"headerlink\" title=\"3.7.1 索引（第六章和第七章）\"></a>3.7.1 索引（第六章和第七章）</h3><ul>\n<li>为什么用的是 B + 树而不是 B 树？<br>B + 树仅在叶子节点中存储全部的用户记录，而其他节点存储的只有主键和对应的页号，相比于 B 树在每个节点都存储完整的用户记录，B + 树的树高更低，查询效率更高</li>\n<li>区分一下聚簇索引和非聚簇索引（二级索引）<br>聚簇索引：以主键值的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列<br>非聚簇索引：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列 + 主键值，若要获取完整的用户记录需要进行回表查询</li>\n<li>哈希索引<br>查询效率很高，但是只有精确匹配索引列的查询才有效，Memory 印象显示支持哈希索引，也是它的默认索引<br>哈希索引不能进行排序；哈希索引不支持任何范围查询；哈希索引不能利用部分索引查询，对于联合索引，必须把所有的列全用上再进行计算 hash 值<br>自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些值被使用的非常频繁时，会在内存中基于 B+Tree 索引上再建一个哈希索引（完全自动的内部行为）</li>\n<li>使用索引的时候我们有哪些需要注意的？<br>1 只为用于搜索、排序或分组的列创建索引<br>2 索引列的类型应尽量小<br>3 可以只为索引列前缀创建索引，以减小索引占用的存储空间<br>4 尽可能的让主键拥有 AUTO_INCREMENT 属性，避免发生页分裂的情况<br>5 查询时尽量使用覆盖索引，避免回表操作带来的性能损耗</li>\n<li>查询时用不到索引的情况（索引失效的情况）<br>1 使用索引比全表扫描慢，不用索引<br>2 联合索引没使用到第一部分<br>3 模糊查询以通配符 % 开头<br>4 若为字符串索引，与数值进行匹配的时候，数值没用引号，不走索引<br>5 在搜索条件中，索引列不以单独的列名存在，而使用表达式或函数进行操作的时候，不走索引</li>\n</ul>\n<h3 id=\"3-7-2-explain-SQL-对应的-type-列解析（第十章）\"><a href=\"#3-7-2-explain-SQL-对应的-type-列解析（第十章）\" class=\"headerlink\" title=\"3.7.2 explain SQL 对应的 type 列解析（第十章）\"></a>3.7.2 explain SQL 对应的 type 列解析（第十章）</h3><ul>\n<li>const：用主键或唯一二级索引的常数匹配（非常快！）</li>\n<li>ref：二级索引进行常数匹配，形成单点扫描区间</li>\n<li>ref_or_null：二级索引进行常数匹配（包含空值）</li>\n<li>range：范围查询</li>\n<li>index：扫描全部二级索引或 order by 主键</li>\n<li>all：全表扫描，扫描全部聚簇索引记录</li>\n<li>我为什么要说这个知识点儿？我面京东的时候被问过 explain 后我们怎么发现走没有索引或者优化，我是这么解释的，type 列如果对应的是 all 的话，我们就需要谨慎一些，因为它没有走索引，我们要看看是不是 SQL 语句使索引失效了还是我们没有为查询列创建索引，反过来如果是 const 这种类型的话，它的执行效率是非常高的</li>\n<li>索引合并<br>Intersection 索引合并：是从二级索引回表查询时，获取的主键是有序的，主键取交集查询（where 中 and 条件）<br>Union 索引合并：也是要求从二级索引回表查询获取的主键值有序，取主键值并集查询（or 条件）<br>Sort-Union：对从二级索引回表中获取的主键值进行排序，排序完成后取并集查询</li>\n</ul>\n<h3 id=\"3-7-3-事务（第十八、二十一、二十二章）\"><a href=\"#3-7-3-事务（第十八、二十一、二十二章）\" class=\"headerlink\" title=\"3.7.3 事务（第十八、二十一、二十二章）\"></a>3.7.3 事务（第十八、二十一、二十二章）</h3><ul>\n<li>ACID 原则<br>原子性：事务作为一个不可在分割的单位，其中的操作要么全部执行成功，要么全部执行失败回滚<br>隔离性：多个事务间不相互干扰，在并发执行期间相互隔离<br>一致性：事务执行前后，数据都保持一致性<br>持久性：事务执行完成后，对数据的影响是永久性的（强调结果）</li>\n<li>隔离级别<br>READ UNCOMMITTED：可能发生脏读、不可重复读和幻读<br>READ COMMITTED：可能发生不可重复读和幻读<br>REPEATABLE READ：可能发生幻读<br>SERIALIZABLE：各种问题都不会发生<br>实际上，MySQL 在 REPEATABLE READ 隔离级别下是可以很大程度上避免幻读出现的（很大程度上！不是完全）</li>\n<li>脏读：一个事务读到了另一个未提交事务修改过的数据</li>\n<li>不可重复读：同一条件下，两次读取的值不相同</li>\n<li>幻读：幻读强调的是一个事务在按照某个相同的搜索条件下多次读取纪录时，读到了之前没有读到的数据（出现了幻行）</li>\n</ul>\n<h3 id=\"3-7-4-日志（第十九、二十章）\"><a href=\"#3-7-4-日志（第十九、二十章）\" class=\"headerlink\" title=\"3.7.4 日志（第十九、二十章）\"></a>3.7.4 日志（第十九、二十章）</h3><ul>\n<li>redo log（重启恢复数据时才是爸爸）<br>对数据库的修改并不会立即同步到磁盘中，而是会在 Buffer Pool（缓存池）中进行缓存，由 flush 链表（脏链表）来维护脏页，那么若在未同步时发生断电，需要 redo log 对这些修改数据的操作进行记录，以便重启后对数据进行恢复<br>产生的 redo log 存放在 block 中，block 也相当于页，也会现在 log buffer 缓存区中缓存，它进行同步的时机有 事务提交时；log buffer 超过 50% 空间已用；后台线程以秒为单位刷新；正常关闭服务器；做 checkpoint 时</li>\n<li>对于已经刷新到磁盘的数据，那么对应的 redo 日志已经没用了，可以对这些空间进行覆盖重用</li>\n<li>undo log（主要用于回滚操作），每对记录进行一次增删改都会产生一条 undo log</li>\n<li>这个 redo log 和 undo log 在面试的时候从没被问过…，暂时列举这么多吧，估计用不太上</li>\n</ul>\n<h3 id=\"3-7-5-MVCC（第二十一章）\"><a href=\"#3-7-5-MVCC（第二十一章）\" class=\"headerlink\" title=\"3.7.5 MVCC（第二十一章）\"></a>3.7.5 MVCC（第二十一章）</h3><p>什么是 MVCC？<br>多版本并发控制，在提交读和可重复读两个隔离级别下，执行 select 操作会产生 readview 快照，根据 readview 快照来进行数据读取的过程<br>这两个隔离界别下，产生快照的时机是不同的，在提交读下，每进行一次一次 select 操作都会产生一个新的快照，快照就相当于给数据拍照片，在这个隔离级别下，每查一次就拍一次照，那么获取的数据都是新的，所以有不可重复读和幻读的情况发生；而在可重复读隔离级别下，只在第一次查询的时候拍一张照，每次再查询都要看最开始生成的这样照片，那么它就避免了不可重复读的情况，也在一定程度上避免了幻读<br>为什么是一定程度上而不是完全避免？如果我们现在在 A 事务中执行了一次查询，那么它已经有了 readview 快照，那么事务 B 插入一条数据进来，事务 A 在进行查询的话，还是看不到这条数据的（在匹配条件符合的情况下），但是 A 事务是能够对这条数据进行修改的！重点在这里，对这条数据修改之后，该行数据的隐藏列的事务 id 就会变成 A 事务的事务 id，这时，A 事务在进行查询，就能看见这条新增的数据了，所以是不能完全避免幻读，避免幻读需要使用 gapLock 间隙锁，它能防止其他事务插入数据<br>Readview 快照访问数据的原理，ReadView 中存储的是最小事务 id，最大事务 id，当前正在运行的事务 id，生成该 Readview 的事务 id，根据这些 id 号去访问数据，只有数据的事务 id 号小于最小事务 id 或者是事务 id 是生成该 Readview 的事务 id 才能被访问到</p>\n<h3 id=\"3-7-6-锁（第二十二章）\"><a href=\"#3-7-6-锁（第二十二章）\" class=\"headerlink\" title=\"3.7.6 锁（第二十二章）\"></a>3.7.6 锁（第二十二章）</h3><ul>\n<li>被问的比较少</li>\n<li>SELECT … LOCK IN SHARE MODE 语句为读取的记录加共享锁</li>\n<li>SELECT … FOR UPDATE 语句为读取的记录加排他锁</li>\n<li>Record Lock：只会对记录本身加锁（提交读隔离级别下下采用的是这个锁）</li>\n<li>Gap Lock：锁住的是记录前的间隙，防止别的事务向该间隙插入新记录，避免幻读</li>\n<li>Next-Key Lock：Record Lock 和 Gap Lock 的结合体，既保护记录本身，也防止别的事务向该间隙插入新纪录（可重复读下采用的是这个锁）</li>\n<li>死锁发生时，InnoDB 会选择一个较小的事务进行回滚，可以通过查看死锁日志来分析死锁的发生过程</li>\n</ul>\n<h3 id=\"3-8-Redis（《Redis-设计与实现》这本书非常好，非常值得一读，行文很流畅！）\"><a href=\"#3-8-Redis（《Redis-设计与实现》这本书非常好，非常值得一读，行文很流畅！）\" class=\"headerlink\" title=\"3.8 Redis（《Redis 设计与实现》这本书非常好，非常值得一读，行文很流畅！）\"></a>3.8 Redis（《Redis 设计与实现》这本书非常好，非常值得一读，行文很流畅！）</h3><ul>\n<li>关于读这本书的一个技巧，可以从第八章开始读，然后每一个对象类型都会对应不同的编码格式，每看到一个编码格式，就去翻前边的章节看它写的是怎么回事儿，这样我觉得更清晰一些，后边的章节顺序读就好</li>\n<li>Redis 缓存穿透、击穿、雪崩的解决方案<br>缓存穿透：指查询一个不存在的数据（缓存中没有，数据库中也没有），如果从存储层查询不到，也不写入缓存，这将导致这个不存在的数据每次请求都会 DB 查询，可能导致 DB 挂掉；<br>解决方案：1 查询的数据为空时，仍把这个空结果进行缓存，设定一个比较短的过期时间<br>2 采用布隆过滤器，不存在的数据会被布隆过滤器拦截，从而避免了对 DB 的查询<br>3 接口增加校验，对不合法的参数直接 return<br>缓存穿透：指缓存中没有，但是数据库中有的数据，有大量的请求过来，引起数据库压力过大<br>解决方案：设置热点数据永不过期<br>缓存雪崩：大量的 key 设置了相同的过期时间，导致缓存在某一时刻的失败，使得请求全部到 DB 上，导致 DB 压力过大<br>解决方案：将缓存失效时间分散开，为 key 的过期时间加上一个随机值</li>\n<li>Redis key 的删除策略和淘汰策略<br>在 redis.conf 文件中设置了配置最大可用内存（maxmemory），在未达到最大使用内存时，键自身设置了过期时间的情况下，Redis 会删除过期键，采用定期删除或惰性删除，在达到最大内存使用限制时，会根据配置项 maxmemory-policy 来进行相应的淘汰策略<br>删除策略：1 惰性删除，程序只会在使用键时对键进行过期检查，过期删除，比较浪费内存<br>2 定期删除：每隔一段时间执行一次删除过期键的操作，必须在设置时间和删除频率来达到节省内存和合理使用 CPU 的目的<br>3 定时删除（Redis 没采用这种，书中 p108），使用定时器来对 key 进行删除，对内存最友好<br>淘汰策略：1 volatile-lru，从设置了过期时间的数据集中选出最近最少使用的数据淘汰<br>2 volatile-ttl，从设置了过期时间的数据集中优先删除剩余时间短的 key<br>3 volatile-random，从设置了过期时间的数据集中岁间选择数据进行删除<br>4 allkeys-lru，从所有 key 中，挑选最近最少使用的数据淘汰<br>5 allkeys-random，从所有 key 中，选择任意数据淘汰<br>6 no-eviction，禁止淘汰数据</li>\n</ul>\n<h3 id=\"3-8-1-五种对象类型（第八章）\"><a href=\"#3-8-1-五种对象类型（第八章）\" class=\"headerlink\" title=\"3.8.1 五种对象类型（第八章）\"></a>3.8.1 五种对象类型（第八章）</h3><ul>\n<li>String 类型<br>编码格式：int，embstr，raw<br>int 保存的是可以用 long 类型保存的整数<br>embstr 保存的是字符串长度小于等于 39 字节的短字符串<br>raw 保存字符串大于 39 字节<br>其中 embstr 和 raw 使用的都是 SDS（简单动态字符串类型），它的底层是一个字符数组，其中存有字符串长度和字符数组中未使用的长度<br>long 和 double 类型也作为字符串类型保存，对其进行操作时会转换为浮点数，再转为字符串存起来</li>\n<li>List 类型<br>编码格式 ziplist（压缩列表），linkedlist（双端链表）<br>ziplist 是在节点数小于 512 个且每个字符长度小于 64 字节时使用，它是一种连续内存的顺序型数据结构<br>linkedlist，具有双端列表的特性</li>\n<li>hash 类型<br>编码格式：ziplist，hashtable<br>ziplist 要求数量小于 512 个，键和值长度小于 64 字节，键和值紧挨着连续存储，用两个节点<br>hashtable，使用 map 作为底层实现</li>\n<li>set 类型<br>编码格式：intset，hashtable<br>intset 要求元素都是整数，且小于 512 个<br>hashtable 只使用字典的 key，而 value 值为 null</li>\n<li>zset 类型（这个被问的几率大一些）<br>编码格式：ziplist 和 skiplist<br>ziplist 要求数量小于 512，元素大小小于 64 字节，每个元素用两个紧挨着的压缩列表节点，第一个保存元素的成员，第二个保存分值，并会从小到大的顺序排序，分值较小的放置在靠近表头的位置<br>skpilist 使用的是 map 和跳表两种数据结构，它们共享 zset 中的对象，不会复制元素而造成浪费<br>map 的作用是能够以 O（1）的时间复杂度来获取对象的 score，键时元素成员，值是元素的分值（ZSCORE 命令）<br>跳表是有序的数据结构，对象不可重，分值可重，分值重的按对象大小排序，每个节点都有一个随机的层高，每层保留前往下一个节点的指针和跨度，能够进行快速匹配，调用 zrank 和 zrange 进行范围操作</li>\n</ul>\n<h3 id=\"3-8-2-RDB-持久化机制（第十章）\"><a href=\"#3-8-2-RDB-持久化机制（第十章）\" class=\"headerlink\" title=\"3.8.2 RDB 持久化机制（第十章）\"></a>3.8.2 RDB 持久化机制（第十章）</h3><ul>\n<li>对应的命令 SAVE 和 BGSAVE，BGSAVE 会 fork 出一条子进程，由子进程创建 RDB 文件，父进程继续处理命令请求</li>\n<li>若有 AOF 文件的时候，不会选择 RDB 文件进行数据恢复</li>\n<li>在配置文件中，我们可以配置执行 RDB 持久化的频率，在多少秒内进行了多少次修改就进行一次持久化<br>save 900 1<br>save 300 10<br>save 60 10000</li>\n<li>原理：底层会用一个数组保存上边的信息，还会维护一个 dirty 计数器来保存修改次数和 lastsave 属性来存储上一次执行 BGSAVE 的时间，redis 调用周期函数检查是否符合 RDB 持久化的条件</li>\n</ul>\n<h3 id=\"3-8-3-AOF-持久化机制（第十一章）\"><a href=\"#3-8-3-AOF-持久化机制（第十一章）\" class=\"headerlink\" title=\"3.8.3 AOF 持久化机制（第十一章）\"></a>3.8.3 AOF 持久化机制（第十一章）</h3><ul>\n<li>通过保存 Redis 服务器的写命令来记录数据库的状态，载入时将命令全执行一遍，配置文件中有 3 种同步机制<br>always，将 aof 缓冲区中的内容写入 aof 文件并立即同步到磁盘中<br>everysecond，将 aof 缓冲区中的内容写入 aof 文件，并检查上次操作是否超过一秒，超过则进行同步<br>no，不进行同步，具体时机由系统来决定</li>\n<li>aof 重写，解决 aof 文件体积太大的问题，创建一个新的 aof 文件来替换原文件，对应的命令是 BGREWRITEAOF</li>\n<li>重写原理：先读出所有的键值，之后用一条命令去记录，代替之前的多条命令。子进程在进行 aof 文件重写时，服务器还会对数据进行修改，这就会产生数据不一致的问题，为了解决该问题，会使用 aof 重写缓冲区，执行的命令会在重写过程中向缓冲区中追加，当子进程完成重写操作时，它会向父进程发送信号，此时父进程会将 aof 重写缓冲区中的所有内容写入到 aof 文件中，并将原 aof 文件进行覆盖，完成重写操作</li>\n</ul>\n<h3 id=\"3-8-4-主从复制（第十五章）\"><a href=\"#3-8-4-主从复制（第十五章）\" class=\"headerlink\" title=\"3.8.4 主从复制（第十五章）\"></a>3.8.4 主从复制（第十五章）</h3><ul>\n<li>主从复制的实现包括同步和命令传播两步，主从服务器都会维护一个复制偏移量，主服务器每执行一条命令都会使偏移量增加，从服务器也一样，数据相同时，偏移量也相同</li>\n<li>初次同步，从服务器向主服务器发送 PSYNC 命令，主服务器执行 BGSAVE，在后台生成一个 RDB 文件，并使用缓冲区记录从现在开始执行的所有写命令，之后会将 RDB 文件发送给从服务器，从服务器载入这个 RDB 文件，并执行从主服务器缓冲区中传过来的写命令，使主从服务器状态一致</li>\n<li>命令传播，主服务器会将之后执行的写操作命令发送给从服务器执行</li>\n<li>断线重连后，可能会执行部分重同步或者全同步，如果在复制积压缓冲区中，仍然记录有从服务器偏移量之后的数据，那么便可以执行部分重同步，将这些命令发送给从服务器，相反的话，就执行全同步；从服务器还会存有主服务的 ID，如果重连的一致，那么将进行重同步或部分重同步，如果不一致，直接全同步</li>\n<li>心跳检测：检测主从服务器的网络连接状态，如果超过一秒没有收到心跳检测命令，那主服务器就知道从服务器出了问题；检测命令丢失，如果主服务器向从服务器传播的命令由于网络原因丢失，那么会根据心跳检测的复制偏移量来进行检测，不同的话会采用命令传播进行部分重同步</li>\n</ul>\n<h3 id=\"3-8-5-哨兵模式（第十六章）\"><a href=\"#3-8-5-哨兵模式（第十六章）\" class=\"headerlink\" title=\"3.8.5 哨兵模式（第十六章）\"></a>3.8.5 哨兵模式（第十六章）</h3><ul>\n<li>Sentienl 实例可以监控一个或多个主服务器和从服务器，当有主服务器下线的时候，自动将下线主服务器属下的某个从服务器升级为新的主服务器</li>\n<li>Sentinel 实例中会存有 master，slave 和其他 sentinel 的信息</li>\n<li>检测主观下线：sentinel 会以 1 秒 1 次的频率向其他服务器（主、从、sentinel）发送 PING 命令，若超过我们在配置文件中配置的超时时间，在该时间内是无效回复，那么该 sentinel 会认为它主观下线</li>\n<li>检测客观下线：sentinel 会询问其他监视该服务器的 sentinel，当认为该服务器主观下线的数量大于等于我们在配置文件中的客观下线票数时，会认为它客观下线，认为该主服务器客观下线后，监视这个主服务器的 sentinel 会挑选出一个零头 sentinel，并由该 sentinel 进行故障转移操作</li>\n<li>故障转移<br>1 在已经下线的主服务器的从服务器里边，挑选一个作为主服务器<br>2 让其他的从服务器复制新的主服务器<br>3 将已下线的主服务器设置为新主服务器的从服务器，它上线后直接成从服务器</li>\n<li>重要的配置信息</li>\n</ul>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">sentinel monitor master1 127.0.0.1 6379 2 &#x2F;&#x2F;2为所需支持的投票数量\nsentinel down-after-milliseconds master1 30000 &#x2F;&#x2F;30000毫秒实例未响应的时间，超时主观下线</code></pre>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","feature":true,"text":"3.1 Java 相关3.1.1 ArrayList 使用场景：ArrayList 的底层是一个数组，适合快速匹配，不适合频繁的增删 允许 add null 值，会自动扩容，其中 size (),isEmpty (),get (),add () 方法的复杂度为 O (1) 使用 ...","link":"","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"34 mins."},"categories":[{"name":"面试","slug":"面试","count":1,"path":"api/categories/面试.json"}],"tags":[{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-Java-%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">3.1 Java 相关</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-ArrayList\"><span class=\"toc-text\">3.1.1 ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-LinkedList\"><span class=\"toc-text\">3.1.2 LinkedList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-3-HashMap\"><span class=\"toc-text\">3.1.3 HashMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-4-HashSet%E3%80%81TreeMap%E3%80%81TreeSet%E3%80%81LinkedHashMap%E3%80%81LinkedHashSet\"><span class=\"toc-text\">3.1.4 HashSet、TreeMap、TreeSet、LinkedHashMap、LinkedHashSet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-5-ConcurrentHashMap%EF%BC%88JDK1-8%EF%BC%89\"><span class=\"toc-text\">3.1.5 ConcurrentHashMap（JDK1.8）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-6-CopyOnWriteArrayList\"><span class=\"toc-text\">3.1.6 CopyOnWriteArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-7-String\"><span class=\"toc-text\">3.1.7 String</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-8-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">3.1.8 基本类型包装类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-9-hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.1.9 hashCode () 和 equals () 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-10-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">3.1.10 封装、继承和多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-11-%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">3.1.11 反射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-12-Java-%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%AC-10-%E7%AB%A0-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%EF%BC%89\"><span class=\"toc-text\">3.1.12 Java 语法糖（《深入理解 JVM 第三版》第 10 章 前端编译优化）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-JVM-%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B-%E7%B4%AB%E7%9A%AE%E5%84%BF%E7%9A%84%EF%BC%8C%E6%B1%82%E6%B1%82%E4%BA%86%EF%BC%8C%E7%9C%8B%E7%9C%8B%E5%90%A7%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%8C%BA%E5%A5%BD%E7%9A%84%EF%BC%89\"><span class=\"toc-text\">3.2 JVM （《深入理解 JVM 第三版》 紫皮儿的，求求了，看看吧，真的挺好的）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F\"><span class=\"toc-text\">3.2.1 Java 内存区域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">3.2.2 对象的创建过程？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%BD%A0%E7%BB%99%E6%88%91%E8%AF%B4%E8%AF%B4%EF%BC%9FOutOfMemoryError-%E5%92%8C-StackOverFlowError\"><span class=\"toc-text\">3.2.3 内存溢出你给我说说？OutOfMemoryError 和 StackOverFlowError</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-4-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">3.2.4 判断对象已死的算法？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-5-%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB-%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E3%80%8B-p71%EF%BC%89\"><span class=\"toc-text\">3.2.5 引用关系 （《深入理解 JVM 》 p71）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.2.6 垃圾回收算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-7-%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\"><span class=\"toc-text\">3.2.7 几种垃圾回收器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E3%80%8B-%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.2.8 类加载（《深入理解 JVM 》 第七章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-9-%E5%A6%82%E6%9E%9C%E5%A4%A7%E5%AE%B6%E6%9C%89%E4%B9%A6%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E3%80%8B%E7%9A%84%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%92%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%EF%BC%8C%E5%8F%AF%E8%83%BD%E7%AC%AC%E5%8D%81%E7%AB%A0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E8%83%BD%E5%9C%A8%E9%9D%A2%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E9%97%AE%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%B0%B1%E4%B8%8D%E5%A4%A7%E9%97%AE%EF%BC%8C%E4%B8%8D%E8%BF%87%E6%88%91%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B8%A6%E6%88%91%E7%9A%84-mentor-%E8%AF%B4%E8%BF%98%E8%9B%AE%E9%87%8D%E8%A6%81%E7%9A%84\"><span class=\"toc-text\">3.2.9 如果大家有书的话，可以看看《深入理解 JVM 》的第十章和第十一章，前端编译优化和后端编译优化，可能第十章的语法糖能在面试的时候被问一下，第十一章就不大问，不过我实习的时候，带我的 mentor 说还蛮重要的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-10-JVM-%E5%AF%B9%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E3%80%8B-p479%EF%BC%89\"><span class=\"toc-text\">3.2.10 JVM 对锁的优化（《深入理解 JVM 》 p479）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">3.3 Java 并发编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84-3-%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.3.1 创建线程的 3 种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">3.3.2 线程池相关</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-3-%E9%94%81%EF%BC%81\"><span class=\"toc-text\">3.3.3 锁！</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-4-CAS-%E6%98%AF%E5%95%A5%E5%91%80%EF%BC%9F\"><span class=\"toc-text\">3.3.4 CAS 是啥呀？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-5-volatile%EF%BC%9F\"><span class=\"toc-text\">3.3.5 volatile？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-6-%E5%85%B6%E5%AE%9E%E8%AF%B4%E5%88%B0-volatile%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%B8%BB%E5%8A%A8%E4%BA%A4%E4%BB%A3%E4%B8%80%E4%B8%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.3.6 其实说到 volatile，建议主动交代一下单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-7-ThreadLocal\"><span class=\"toc-text\">3.3.7 ThreadLocal</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-8-%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8%EF%BC%88this-escape%EF%BC%89\"><span class=\"toc-text\">3.3.8 引用逃逸（this escape）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-Spring%E3%80%81SpringMVC%EF%BC%8CMyBatis%EF%BC%8CSpringBoot%EF%BC%88%E6%88%91%E5%8F%AA%E4%BA%86%E8%A7%A3%E4%B8%AA%E7%9A%AE%E6%AF%9B%E7%BD%A2%E4%BA%86%EF%BC%89\"><span class=\"toc-text\">3.4 Spring、SpringMVC，MyBatis，SpringBoot（我只了解个皮毛罢了）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%87%86%E5%A4%87%E8%BF%99%E9%87%8C%E7%9A%84%E9%9D%A2%E8%AF%95%EF%BC%8C%E6%88%91%E6%9B%B4%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E8%B5%8C%E5%BE%92%EF%BC%89\"><span class=\"toc-text\">3.5 计算机网络和操作系统（准备这里的面试，我更像是一个赌徒）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-1-%E4%B8%83%E5%B1%82%E5%92%8C%E4%BA%94%E5%B1%82\"><span class=\"toc-text\">3.5.1 七层和五层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-2-TCP\"><span class=\"toc-text\">3.5.2 TCP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-3-HTTP\"><span class=\"toc-text\">3.5.3 HTTP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%88%91%E5%8F%AA%E8%B5%8C%E7%9A%84%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">3.5.4 操作系统（我只赌的这两个问题）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-Linux-%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BB%85%E4%BB%85%E8%A2%AB%E9%97%AE%E8%BF%87%E4%B8%80%E6%AC%A1%EF%BC%8C%E7%AE%80%E5%8E%86%E4%B8%8A%E6%B2%A1%E5%86%99-Linux%EF%BC%89\"><span class=\"toc-text\">3.6 Linux 命令（仅仅被问过一次，简历上没写 Linux）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-MySQL%EF%BC%88%E3%80%8AMySQL-%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B-%E8%BF%99%E6%9C%AC%E4%B9%A6%E6%97%A0%E6%95%8C%EF%BC%81%E7%9C%9F%E7%9A%84%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%9C%89%E6%97%B6%E9%97%B4%E4%B8%80%E5%AE%9A%E7%9C%8B%E7%9C%8B%EF%BC%8C%E6%8E%98%E9%87%91%E4%B8%8A%E4%B9%9F%E6%9C%89%E7%94%B5%E5%AD%90%E7%89%88%EF%BC%89\"><span class=\"toc-text\">3.7 MySQL（《MySQL 是怎样运行的》 这本书无敌！真的，大家有时间一定看看，掘金上也有电子版）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-1-%E7%B4%A2%E5%BC%95%EF%BC%88%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.7.1 索引（第六章和第七章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-2-explain-SQL-%E5%AF%B9%E5%BA%94%E7%9A%84-type-%E5%88%97%E8%A7%A3%E6%9E%90%EF%BC%88%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.7.2 explain SQL 对应的 type 列解析（第十章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-3-%E4%BA%8B%E5%8A%A1%EF%BC%88%E7%AC%AC%E5%8D%81%E5%85%AB%E3%80%81%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.7.3 事务（第十八、二十一、二十二章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-4-%E6%97%A5%E5%BF%97%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B9%9D%E3%80%81%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.7.4 日志（第十九、二十章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-5-MVCC%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.7.5 MVCC（第二十一章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-6-%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.7.6 锁（第二十二章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-Redis%EF%BC%88%E3%80%8ARedis-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%99%E6%9C%AC%E4%B9%A6%E9%9D%9E%E5%B8%B8%E5%A5%BD%EF%BC%8C%E9%9D%9E%E5%B8%B8%E5%80%BC%E5%BE%97%E4%B8%80%E8%AF%BB%EF%BC%8C%E8%A1%8C%E6%96%87%E5%BE%88%E6%B5%81%E7%95%85%EF%BC%81%EF%BC%89\"><span class=\"toc-text\">3.8 Redis（《Redis 设计与实现》这本书非常好，非常值得一读，行文很流畅！）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-1-%E4%BA%94%E7%A7%8D%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.8.1 五种对象类型（第八章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-2-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%88%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.8.2 RDB 持久化机制（第十章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-3-AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.8.3 AOF 持久化机制（第十一章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-4-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.8.4 主从复制（第十五章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-5-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%89\"><span class=\"toc-text\">3.8.5 哨兵模式（第十六章）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol>","author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"面试积累","uid":"4a4c62b488ae3faf3b7c187892faae11","slug":"面试积累","date":"2022-01-10T14:32:21.000Z","updated":"2022-01-15T16:26:21.863Z","comments":true,"path":"api/articles/面试积累.json","keywords":"Java","cover":[],"text":"linux： DevOps的全名： Development Operations 开发自运维 首先来回顾一下整个开发流程： 需求 - 开发 - 测试 - 发布 - 部署 - 监控运维 项目管理（需求 &amp; BUG）：redmine 代码托管：gerrit（gitlab） 持...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"面试积累","slug":"面试积累","count":1,"path":"api/categories/面试积累.json"}],"tags":[{"name":"前后端","slug":"前后端","count":1,"path":"api/tags/前后端.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"能遇见你，甚是开心","uid":"d072989fb1060a7ab47385f712edd6a0","slug":"引言","date":"2022-01-07T14:32:21.000Z","updated":"2022-01-08T05:19:23.148Z","comments":true,"path":"api/articles/引言.json","keywords":"Java","cover":null,"text":"欢迎来到我的世界，这是我的个人博客。基于 Hexo 框架搭建，采用 hexo-theme-aurora 主题。 后期也会不定时增加新的功能，敬请期待！！！ ","link":"","photos":[],"count_time":{"symbolsCount":79,"symbolsTime":"1 mins."},"categories":[{"name":"引言","slug":"引言","count":1,"path":"api/categories/引言.json"}],"tags":[{"name":"入站须知","slug":"入站须知","count":1,"path":"api/tags/入站须知.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"feature":true}}