{"title":"RequestMapping注解","uid":"dae83d1c88f5937753ca40f0c60cab64","slug":"@RequestMapping注解","date":"2021-11-07T14:32:21.000Z","updated":"2022-01-07T15:00:24.874Z","comments":true,"path":"api/articles/@RequestMapping注解.json","keywords":"Java","cover":null,"content":"<h1 id=\"RequestMapping注解\"><a href=\"#RequestMapping注解\" class=\"headerlink\" title=\"@RequestMapping注解\"></a>@RequestMapping注解</h1><p>一个用来处理请求地址映射的注解，可用于类或方法上。</p>\n<h5 id=\"用于类上，表示类中的所有请求的方法都是以该地址作为父路径\"><a href=\"#用于类上，表示类中的所有请求的方法都是以该地址作为父路径\" class=\"headerlink\" title=\"用于类上，表示类中的所有请求的方法都是以该地址作为父路径\"></a>用于类上，表示类中的所有请求的方法都是以该地址作为父路径</h5><pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">@RestController\n@RequestMapping(&quot;&#x2F;test&quot;)\npublic class TestController &#123;\n    @Autowired\n    private MerchantConfigRepository merchantConfigService;\n    @Autowired\n    DealerService dealerService;</code></pre>\n\n<h5 id=\"用在类开头，为整个类规定它的父路径\"><a href=\"#用在类开头，为整个类规定它的父路径\" class=\"headerlink\" title=\"用在类开头，为整个类规定它的父路径\"></a>用在类开头，为整个类规定它的父路径</h5><p>在方法前使用@RequestMapping ，相当于规定该调用方法的路径</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;addDealer&quot;,method &#x3D; RequestMethod.POST)\n    public String addDealer(@Valid @RequestBody DealerModel dealerModel, BindingResult bindingResult) &#123;\n        return dealerService.addDealer(dealerModel);\n    &#125;</code></pre>\n\n","text":"@RequestMapping注解一个用来处理请求地址映射的注解，可用于类或方法上。 用于类上，表示类中的所有请求的方法都是以该地址作为父路径@RestController @RequestMapping(&quot;&#x2F;test&quot;) public class ...","link":"","photos":[],"count_time":{"symbolsCount":605,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"}],"tags":[{"name":"spring","slug":"spring","count":1,"path":"api/tags/spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RequestMapping%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">@RequestMapping注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%94%A8%E4%BA%8E%E7%B1%BB%E4%B8%8A%EF%BC%8C%E8%A1%A8%E7%A4%BA%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E4%BB%A5%E8%AF%A5%E5%9C%B0%E5%9D%80%E4%BD%9C%E4%B8%BA%E7%88%B6%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">用于类上，表示类中的所有请求的方法都是以该地址作为父路径</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%94%A8%E5%9C%A8%E7%B1%BB%E5%BC%80%E5%A4%B4%EF%BC%8C%E4%B8%BA%E6%95%B4%E4%B8%AA%E7%B1%BB%E8%A7%84%E5%AE%9A%E5%AE%83%E7%9A%84%E7%88%B6%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">用在类开头，为整个类规定它的父路径</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"面试题","uid":"5f849d772fd372114a5b63b97d1479ef","slug":"面试题","date":"2022-01-01T15:32:53.000Z","updated":"2022-01-08T05:31:25.419Z","comments":true,"path":"api/articles/面试题.json","keywords":"Java","cover":null,"text":"object类中的方法：实现对象的浅拷贝的clone方法 获得运行时类型的getclass方法 释放资源的finalize方法 用户哈希查找的hashcode方法 使当前线程等待该对象的锁wait方法 访问修饰符：​ 本类中 同个包 子类 任何地方 public protect ...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"面试题","slug":"面试题","count":1,"path":"api/categories/面试题.json"}],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}}},"next_post":{"title":"MVVM模式","uid":"20496ea705d490e685d32b89838c0b41","slug":"MVVM 模式理解","date":"2021-10-07T14:32:21.000Z","updated":"2022-01-15T16:52:54.970Z","comments":true,"path":"api/articles/MVVM 模式理解.json","keywords":"Java","cover":[],"text":"MVVM 模式理解（转） MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对 View 和 ViewModel 的双向数据绑定，这使得 ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 Vu...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":2,"path":"api/categories/前端.json"}],"tags":[{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}}}}