{"title":"java基础","uid":"bb75e9d1c3429d83254e84314ef5ffe1","slug":"java基础","date":"2021-08-07T14:32:21.000Z","updated":"2022-01-07T14:55:34.895Z","comments":true,"path":"api/articles/java基础.json","keywords":"Java","cover":[],"content":"<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h2 id=\"方法的覆盖重写\"><a href=\"#方法的覆盖重写\" class=\"headerlink\" title=\"方法的覆盖重写\"></a>方法的覆盖重写</h2><p>1.必须保证父子类之间方法的名称相同，参数列表也相同；</p>\n<p>@Override，写在方法签名，用来检测是不是有效的正确覆盖重写。</p>\n<p>写不写都行，写了可以验证一下方法名是否与父类方法对应。</p>\n<p>2.子类方法的返回值必须小于等于父类方法的返回值范围</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Zi extends Fu&#123;\n    @Override\n    public String method()&#123;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Fu &#123;\n    public Object method()&#123;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<p>返回值范围：Object&gt;String</p>\n<p>注：所有的引用类型（Object、String等）都可以用null作返回值。</p>\n<p>3.子类方法的权限必须大于等于父类方法的权限修饰符。</p>\n<p>public &gt; protected &gt; (default) &gt; private</p>\n<p>（default ）不是关键字default，而是不写修饰符，留空。</p>\n<p>4.子类必须调用父类构造方法</p>\n<p>5.super的子类调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。</p>\n<p>6.子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定super调用，super只能有一个，还必须是第一个。</p>\n<p>7.this(…)调用也必须是构造方法的第一个语句，唯一一个。</p>\n<p>super和this两种构造调用，不能同时使用。</p>\n<h2 id=\"继承的三个特点\"><a href=\"#继承的三个特点\" class=\"headerlink\" title=\"继承的三个特点\"></a>继承的三个特点</h2><p>java语言是单继承的，一个类的直接父类只能有唯一一个</p>\n<p>java语言可以多级继承，一个父类可以拥有很多个子类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class A&#123;&#125;\nclass B extends A&#123;&#125;&#x2F;&#x2F;正确\nclass C extends B&#123;&#125;&#x2F;&#x2F;正确</code></pre>\n\n<h2 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h2><p>如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法</p>\n<p>抽象方法：加上abstract 关键字，然后去掉大括号，直接分号结束。</p>\n<p>抽象类：抽象方法所在的类，必须是抽象类，在class前加上abstract。</p>\n<p>如何使用抽象类和抽象方法：</p>\n<p>1.必须用一个子类来继承抽象父类</p>\n<p>2.子类必须覆盖重写抽象父类当中的所有抽象方法。子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</p>\n<p>面试题：</p>\n<p><strong>抽象类可以被实例化吗？</strong></p>\n<p>抽象类其实是可以被实例化的，但是它的实例化方式并不是通过普通的 new 方式来创建对象，而是通过父类的应用来指向子类的实例间接地实现父类的实例化，因为子类在实例化之前，一定会先实例化它的父类。 … 注意：接口与抽象类非常类似，但是它不可以被实例化，因为接口压根没有构造函数</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>1.不能直接创建抽象类对象，之恶能创建非抽象子类的对象</p>\n<p>ps：加入创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>\n<p>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>\n<p>3.抽象类不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>\n<p>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>接口就是一种公共的规范标准。</p>\n<p>接口是一种引用数据类型，最重要的内容是其中的抽象方法</p>\n<p>接口中可以包含的内容有：</p>\n<ol>\n<li><p>常量 （java7）</p>\n</li>\n<li><p>抽象方法（java7）</p>\n</li>\n<li><p>默认方法（java8）</p>\n</li>\n<li><p>静态方法（java8）</p>\n</li>\n<li><p>私有方法（java9）</p>\n<p>1.普通私有方法，解决多个默认方法之间重复代码问题</p>\n<p>格式：private 返回值类型 方法名称（参数列表）{方法体}</p>\n<p>2.静态私有方法：解决多个静态方法之间重复代码问题</p>\n<p>格式：private static 返回值类型 方法名称（参数列表）{方法体}</p>\n</li>\n</ol>\n<p>接口当中的抽象方法，修饰符必须是两个固定的关键字：</p>\n<p>public abstract，所以写不写修饰符都一样</p>\n<p>接口的使用步骤：</p>\n<ol>\n<li><p>接口必须有一个实现类来实现该接口</p>\n</li>\n<li><p>接口的实现类必须覆盖重写接口中的所有抽象方法</p>\n<p>去掉方法的abstract关键字，然后补上方法体大括号。</p>\n</li>\n<li><p>创建实现类的对象进行使用。</p>\n<p>不能通过接口实现类的对象来调用接口当中的静态方法，可以通过接口名称直接调用其中的静态方法。</p>\n<h4 id=\"多接口的注意事项\"><a href=\"#多接口的注意事项\" class=\"headerlink\" title=\"多接口的注意事项\"></a>多接口的注意事项</h4><ol>\n<li>一个类的直接父类是唯一的，但一个类可以实现多个接口</li>\n<li>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</li>\n<li>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</li>\n<li>如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li>\n<li>一个类如果实现父类当中的方法，和接口当中的默认方法产生了冲突，则优先用父类当中的方法。</li>\n<li>接口是没有静态代码块或者构造方法的。</li>\n<li>多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，而且带着default关键字。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>父类引用指向子类对象。</p>\n<p>格式：父类名称 对象名 = new 子类名称（）；</p>\n<p>或者 接口名称 对象名 = new 实现类名称（）；</p>\n<p>访问成员变量的两种方式：</p>\n<ol>\n<li>直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Fu &#123;\n    int num &#x3D; 10;\n&#125;\npublic class Zi extends Fu&#123;\n    int num &#x3D; 20;\n&#125;\nFu obj &#x3D; new Zi(); &#x2F;&#x2F;输出10</code></pre>\n\n<ol start=\"2\">\n<li>间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找</li>\n</ol>\n<p>在多态的代码中，成员方法的访问规则是：</p>\n<p>看new的是谁，就优先用谁，没有则向上找</p>\n<p>口诀：编译看左边，运行看右边</p>\n<p>成员变量：编译看左边，运行还看左边</p>\n<p>成员方法：编译看左边，运行看右边</p>\n<h3 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h3><p>对象的向上转型，就是多态的写法：父类引用指向子类对象。</p>\n<p>向上转型一定是安全的。</p>\n<h3 id=\"向下转型\"><a href=\"#向下转型\" class=\"headerlink\" title=\"向下转型\"></a>向下转型</h3><p>其实是一个还原动作</p>\n<p>格式：子类名称 对象名 = （子类名称）父类对象；</p>\n<p>即将父类对象还原为本来的子类对象。</p>\n<p>向下转型要先进行判断，使用instanceof 关键字进行类型判断  返回boolean</p>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><p>当final关键字用来修饰一个方法的时候，该方法不能被覆盖重写。</p>\n<p>对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。</p>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><p>类似于身体于心脏的关系</p>\n<p>格式： </p>\n<p>修饰符 class 外部类名称{</p>\n<p>​    修饰符 class 内部类名称{</p>\n<p>​         }</p>\n<p>}</p>\n<p>内用外，随意访问；外用内，需要内部类对象。</p>\n<p>使用成员内部类的方法：</p>\n<ol>\n<li>间接方式，在外部类的方法当中，使用内部类，main只是调用外部类的方法。</li>\n<li>直接方式，公式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称</li>\n</ol>\n<p>在内部类方法访问外部类的成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Body &#123;\n    public class Heart&#123;\n        int num &#x3D; 20;&#x2F;&#x2F;内部类的成员变量\n        public void methodHeart()&#123;\n            int num &#x3D; 40;\n            System.out.println(Body.this.num); &#x2F;&#x2F;在内部类访问外部类的成员变量\n            System.out.println(name+&quot;内部类的方法&quot;);\n        &#125;\n\n\n    &#125;\n    private String name;\n    int num &#x3D; 10;&#x2F;&#x2F;外部类的成员变量\n    public  void methodBody()&#123;\n        int num &#x3D; 30;&#x2F;&#x2F;外部类的方法的局部变量\n        Heart heart &#x3D; new Heart();\n        System.out.println(&quot;外部类的方法&quot;);\n        heart.methodHeart();\n\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>在外部类方法里定义的类叫做局部内部类</p>\n<p>定义一个类的时候，权限修饰符规则：</p>\n<ol>\n<li><p>外部类：public / （default）</p>\n</li>\n<li><p>成员内部类：public / protected / (default) / private</p>\n</li>\n<li><p>局部内部类，什么都不能写。</p>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><p>如果接口的实现类或者是父类的子类只需要使用一次，这种情况可以省略掉该类的定义，而改为使用匿名内部类。</p>\n</li>\n</ol>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><p>看一个类是否重写了toString方法，直接打印这个类对应对象名字即可</p>\n<p>如果没有重写toString方法，那么打印的就是对象的地址值（默认）</p>\n<p>如果重写toString方法，那么就按照重写的方式打印。</p>\n<p>equals方法，默认比较两个对象的地址值。</p>\n<ol>\n<li><p>Object类介绍：是所有类的父类，一个类都会直接或者间接地继承自该类，该类中提供了一些非常常用的方法</p>\n</li>\n<li><p>toString()方法</p>\n<p>作用：打印对象信息</p>\n<p>重写前：打印的是包名类名@地址值</p>\n<p>重写后：打印的是对象中的属性值</p>\n</li>\n<li><p>equals()方法</p>\n<p>作用：比较两个对象</p>\n<p>重写前：比较的是对象的地址值</p>\n<p>重写后：比较的是对象中的属性值</p>\n</li>\n</ol>\n<h2 id=\"Objects\"><a href=\"#Objects\" class=\"headerlink\" title=\"Objects\"></a>Objects</h2><p>equals()方法：</p>\n<p>比较两个对象是否相同，但是增加了一些健壮性的判断！</p>\n<p>Object.equals（a,b）</p>\n<h1 id=\"Date类\"><a href=\"#Date类\" class=\"headerlink\" title=\"Date类\"></a>Date类</h1><p>long getTime()</p>\n<p>返回自1970年1月1日 00:00:00 GMT以来此Date对象表示的毫秒数</p>\n<p>Date类的带参构造方法：</p>\n<p>​    Date(long date) ：传递毫秒值，把毫秒转换为Date日期</p>\n<p>Date类的空参构造方法：</p>\n<p>​    Date()获取的是当前系统的日期和时间</p>\n<h1 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h1><p>成员方法：</p>\n<p>public StringBuilder append（…）：添加任意类型的字符串形式，并返回当前对象自身。</p>\n<p>参数：可以是任意数据类型。</p>\n<h1 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h1><p>拆箱：在包装类中取出基本数据类型的数据（包装类-&gt;基本类型的数据）</p>\n<p>成员方法：int intValue() 以int 类型返回该Integer的值</p>\n<p>装箱：把基本类型的数据，包装到包装类中（基本类型的数据-&gt;包装类）</p>\n<p>如果方法上有横线，说明方法过时了</p>\n<p>静态方法：</p>\n<p>static Integer valueOf(int i) 返回一个表示指定的int值的Integer实例</p>\n<p>static Integer valueOf（String s）返回保存指定的String的值的Integer对象。</p>\n<h1 id=\"集合框架\"><a href=\"#集合框架\" class=\"headerlink\" title=\"集合框架\"></a>集合框架</h1><p>学习目标：</p>\n<ol>\n<li>会使用集合存储数据</li>\n<li>会遍历集合，把数据取出来</li>\n<li>掌握每种集合的特性</li>\n</ol>\n<p>学习方式：</p>\n<ol>\n<li>学习顶层：学习顶层接口/抽象类中共性的方法，所有的子类都可以使用</li>\n<li>使用底层：底层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用</li>\n</ol>\n<p>Collection 接口：</p>\n<p>定义的是所有单列集合中共性的方法</p>\n<p>所有的单列集合都可以使用共性的方法</p>\n<p>没有带索引的方法</p>\n<p>List接口：</p>\n<ol>\n<li>有序的集合（存储和取出元素顺序相同）</li>\n<li>允许存储重复的元素</li>\n<li>有索引，可以使用普通的for循环遍历</li>\n</ol>\n<p>Set接口：</p>\n<ol>\n<li><p>不允许存储重复元素</p>\n</li>\n<li><p>没有索引（不能使用普通的for循环遍历）</p>\n<p>TreeSet集合和HashSet集合：</p>\n<p>无序的集合（存储和取出元素的顺序有可能不一致）</p>\n</li>\n</ol>\n<p>LinkedHashSet集合：有序的集合</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142018726.png\" alt=\"image-20220107142018726\"></p>\n<p>共性的方法：</p>\n<p>public boolean add(E e)：把给定的对象添加到当前集合中</p>\n<p>public void clear()：清空集合中所有的元素</p>\n<p>public boolean remove(E e)：把给定的对象在当前集合中删除</p>\n<p>public boolean contains(E e)：判断当前集合中是否包含给定的对象</p>\n<p>public boolean isEmpty()：判断当前集合是否为空</p>\n<p>public int size()：返回集合中元素的个数</p>\n<p>public Object[] toArray() 把集合中的元素存储到数组中</p>\n<p>迭代器：通用的取出集合的方法。主要针对没有索引的集合。</p>\n<p>方法：</p>\n<p>使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</p>\n<p>注意：Iterator<E>接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型。</p>\n<p>hasNext() 如果仍有元素可以迭代，则返回true</p>\n<p>next() 返回迭代的下一个元素，一旦执行就会取出一个元素</p>\n<p>remove() 从迭代器指向的collection中移除迭代器返回的最后一个元素</p>\n<h1 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h1><p>增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写，是JDK1.5之后出现的新特性，用来遍历集合或数组</p>\n<p>Collection<E> extends Iterable<E> ：所有的单列集合都可以使用增强for</p>\n<p>public interface Iterable<T> 实现这个接口允许对象成为”foreach”语句的目标</p>\n<p>格式：</p>\n<p>for(集合/数组的数据类型 变量名 ： 集合名/数组名){</p>\n<p>sout(变量名);</p>\n<p>}</p>\n<p>public class Demo02Foreach{</p>\n<p>}</p>\n<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><p>创建集合对象，使用泛型的好处：</p>\n<ol>\n<li><p>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</p>\n</li>\n<li><p>把运行期异常（代码运行后会抛出的异常），提升到了编译器（写代码的时候会报错）</p>\n<p>不确定用什么数据类型的时候，可以使用泛型  E</p>\n</li>\n</ol>\n<p>定义含有泛型的方法：泛型定义在方法的修饰符和返回值类型之间</p>\n<p>格式：</p>\n<p>​    修饰符&lt;泛型&gt;返回值类型  方法名 ( 参数列表(使用泛型) ){</p>\n<p>​    方法体；</p>\n<p>}</p>\n<p>含有泛型的方法，在调用方法的时候确定泛型的数据类型</p>\n<p>传递什么类型的参数，泛型就是什么类型</p>\n<h2 id=\"泛型的通配符\"><a href=\"#泛型的通配符\" class=\"headerlink\" title=\"泛型的通配符\"></a>泛型的通配符</h2><p>？：代表任意的数据类型</p>\n<p>使用方式：</p>\n<p>​        不能创建对象使用</p>\n<p>​        只能作为方法的参数使用</p>\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h1><p>ArrayList查询快增删慢</p>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><p>LinkedList 集合的特点：</p>\n<ol>\n<li><p>底层是一个链表结构：查询慢，增删快</p>\n</li>\n<li><p>里边包含了大量操作首尾元素的方法</p>\n<p>注意：使用LinkedList集合特有的方法，不能使用多态</p>\n</li>\n</ol>\n<p>public void addFirst(E e) ：将指定元素插入到列表的开头</p>\n<p>public void addList(E e)：将指定元素添加到此列表的结尾</p>\n<p>public void push(E e)：将元素插入此列表所表示的堆栈</p>\n<p>public E getFirst()：返回此列表的第一个元素</p>\n<p>public E getLast()：返回此列表的最后一个元素</p>\n<p>public E removeFirst()：移除并返回此列表的第一个元素</p>\n<p>public E removeLast()：移除并返回此列表的最后一个元素</p>\n<p>public E pop()：从此列表所表示的堆栈处弹出一个元素</p>\n<h2 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h2><p>特点：</p>\n<ol>\n<li><p>不允许存储重复的元素</p>\n</li>\n<li><p>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</p>\n</li>\n<li><p>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p>\n</li>\n<li><p>底层是一个哈希表结构（查询的速度非常的快）</p>\n<p>HashSet是implement Set接口，Set接口只有以上1、2特点。</p>\n</li>\n</ol>\n<p>存储数据的结构（哈希表）</p>\n<p>jdk 1.8 版本之前： 哈希表=数组+链表</p>\n<p>jdb 1.8版本之后 ：</p>\n<p>​                                哈希表=数组+链表；</p>\n<p>​                                哈希表=数组+红黑树（提高查询的速度）</p>\n<p>哈希表的特点：速度快</p>\n<p>Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否被重复</p>\n<h1 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h1><p>是jdk 1.5之后出现的新特性</p>\n<p>使用前提：</p>\n<p>​        当方法的参数列表数据类型已经确定，但参数的个数不确定，就可以使用可变参数</p>\n<p>使用格式：方法定义时使用</p>\n<p>​    修饰符 返回值类型 方法名 （ 数据类型…变量名）{}</p>\n<p>可变参数的原理：</p>\n<p>​        可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数可以是0或多个。</p>\n<p>一个方法的参数列表，只能有一个可变参数。</p>\n<p>如果方法的参数有多个，可变参数必须写在末尾。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void method(String a,double b,int...c)</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo4VarArgs &#123;\n    public static void main(String[] args) &#123;\n        int i &#x3D; add(55,44,55,66,55,7);\n        System.out.println(i);\n    &#125;\n    public static int add(int... arr) &#123; &#x2F;&#x2F;[I@1b6d3586底层是数组\n\n        int sum &#x3D; 0;\n        for (int i : arr) &#123;\n            sum +&#x3D; i;\n        &#125;\n        return sum;\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"对象排序\"><a href=\"#对象排序\" class=\"headerlink\" title=\"对象排序\"></a>对象排序</h1><p>java.utils.Collections 是集合工具类，用来对集合进行操作，部分方法如下：</p>\n<p>public static <T> void sort(List<T> list)：将集合中元素按照默认规则排序</p>\n<p>注意：sort(List<T> list)使用前提</p>\n<p>被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法comparaTo定义的排序规则</p>\n<p>Comparable 接口的排序规则：</p>\n<p>自己(this)-参数：升序</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">实体类：   \n@Override\npublic int compareTo(Employee o) &#123;\n        return this.getSalary()-o.getSalary();\n    &#125;\n主方法：\nCollections.sort(list);</code></pre>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>集合特点：</p>\n<ol>\n<li>Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）</li>\n<li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li>\n<li>Map集合中的元素，key是不允许重复的，value是可以重复的</li>\n<li>Map集合中的元素，key和value是一一对应的。</li>\n</ol>\n<p>java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口</p>\n<p>HashMap集合的特点：</p>\n<ol>\n<li><p>HashMap集合底层是哈希表：查询的速度特别快</p>\n<p>​        jdk1.8之前：数组+单向链表</p>\n<p>​       jdk1.8之后：数组+单向链表/红黑树（链表的长度超过8）：提高查询的速度</p>\n</li>\n<li><p>hashMap是一个无序的集合，存储元素和取出元素的顺序可能不一致</p>\n</li>\n</ol>\n<p>java.util.LinkedHashMap&lt;k,v&gt;集合，extends HashMap&lt;k,v&gt;集合</p>\n<p>LinkedHashMap的特点：</p>\n<ol>\n<li>LinkedHashMap集合底层是哈希表+链表（保证迭代的顺序）</li>\n<li>LinkedHashMap集合是一个有序的集合，存储元素和取出元素的顺序有可能不一致</li>\n</ol>\n<p><img src=\"http://image.1carus.xyz/image-20220107224830150.png\" alt=\"image-20220107224830150\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo5Map &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;盲僧&quot;,1);\n        map.put(&quot;盖伦&quot;,2);\n        map.put(&quot;亚索&quot;,3);\n        &#x2F;&#x2F;使用map集合中的方法keySet()，把map集合中所有的key取出来存到Set集合中\n        Set&lt;String&gt; set &#x3D; map.keySet();\n        Iterator&lt;String&gt; it &#x3D; set.iterator();\n        while(it.hasNext())&#123;\n            String key &#x3D; it.next();\n            &#x2F;&#x2F;通过Map集合中的方法get(key),通过key找到value\n            Integer value &#x3D; map.get(key);\n            System.out.println(key+value);\n\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>第二种遍历方式</p>\n<p>map集合中的方法：</p>\n<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图</p>\n<p>实现步骤：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1.使用map集合中的方法entrySet()，把Map集合中的多个Entry对象取出来，存储到一个Set集合中</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2.历Set集合，获取每一个Entry对象</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">3.使用entry对象中的方法getKey()和getValue()获取键和值</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(&quot;盲僧&quot;,1);\n    map.put(&quot;盖伦&quot;,2);\n    map.put(&quot;亚索&quot;,3);\n    &#x2F;&#x2F;1.使用map集合中的方法entrySet()，把Map集合中的多个Entry对象取出来，存储到一个Set集合中\n    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set &#x3D; map.entrySet();\n    &#x2F;&#x2F;2.历Set集合，获取每一个Entry对象\n    &#x2F;&#x2F;使用迭代器遍历Set集合\n    Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it  &#x3D; set.iterator();\n    while(it.hasNext()) &#123;\n        Map.Entry&lt;String, Integer&gt; entry &#x3D; it.next();\n        &#x2F;&#x2F;3.使用entry对象中的方法getKey()和getValue()获取键和值\n        String key &#x3D; entry.getKey();\n        Integer value &#x3D; entry.getValue();\n        System.out.println(key + &quot;-&quot; + value);\n        System.out.println(&quot;-------------------&quot;);\n    &#125;</code></pre>\n\n<p>hashTable</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142032268.png\" alt=\"image-20220107142032268\"></p>\n<p>jdk9新特性：</p>\n<p>List接口，Set接i口，Map接口：里边增加了一个静态的方法of，可以给集合一次行添加多个元素</p>\n<p>static <E> List<E> of ( E…element)</p>\n<p>使用前提：</p>\n<p>​        当集合中存储的元素的个数已经确定了，不再改变时使用。</p>\n<p>注意：</p>\n<ol>\n<li>of方法只适用于List接口，Set接i口，Map接口，不适用于接口的实现类</li>\n<li>of方法的返回值是一个不能改变的结合，集合不能再使用add，put方法添加元素，会抛出异常</li>\n<li>Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常。</li>\n</ol>\n<p>Map.get () 方法：返回指定键所映射的值</p>\n<p>ss</p>\n<h1 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h1><p><img src=\"http://image.1carus.xyz/image-20220107142040526.png\" alt=\"image-20220107142040526\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142048549.png\" alt=\"image-20220107142048549\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142056062.png\" alt=\"image-20220107142056062\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142103518.png\" alt=\"image-20220107142103518\"></p>\n<p>request对象和response对象的原理：</p>\n<ol>\n<li><p>request和response对象是由服务器创建的，我们来使用他们</p>\n</li>\n<li><p>request对象是来获取请求消息的，response对象是设置响应消息的</p>\n</li>\n<li><p><img src=\"http://image.1carus.xyz/image-20220107142114364.png\" alt=\"image-20220107142114364\"></p>\n<h2 id=\"request功能\"><a href=\"#request功能\" class=\"headerlink\" title=\"request功能\"></a>request功能</h2></li>\n</ol>\n<p><img src=\"http://image.1carus.xyz/image-20220107142120576.png\" alt=\"image-20220107142120576\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    &#x2F;&#x2F;1.获取请求方式：GET\n    String method &#x3D; request.getMethod();\n    System.out.println(method);\n    &#x2F;&#x2F;2.（*重点）获取虚拟目录：&#x2F;day14\n    String contextPath &#x3D; request.getContextPath();\n    System.out.println(contextPath);\n    &#x2F;&#x2F;3.获取Servlet路径 ：&#x2F;demo1\n    String servletPath &#x3D;request.getServletPath();\n    System.out.println(servletPath);\n    &#x2F;&#x2F;4.获取get方法请求参数：name &#x3D; zhangsan\n    String queryString &#x3D; request.getQueryString();\n    System.out.println(queryString);\n    &#x2F;&#x2F;5.(*重点)获取请求URI：&#x2F;day14&#x2F;demo1\n    String requestURI &#x3D; request.getRequestURI();\n    StringBuffer requestURL&#x3D; request.getRequestURL();\n    System.out.println(requestURI);\n    System.out.println(requestURL);\n    &#x2F;&#x2F;6.获取协议及版本：HTTP&#x2F;1.1\n    String protocol &#x3D; request.getProtocol();\n    System.out.println(protocol);\n    &#x2F;&#x2F;7.获取客户机的IP地址\n    String remoteAddr &#x3D; request.getRemoteAddr();\n    System.out.println(remoteAddr);\n&#125;</code></pre>\n\n<p>获取请求头数据：</p>\n<p>方法：</p>\n<p>​    String getHeader(String name):通过请求头的名称获取请求头的值</p>\n<p>   Enumeration<String> getHeaderNames( );获取所有的请求头名称</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142130055.png\" alt=\"image-20220107142130055\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n&#x2F;&#x2F;获取请求消息体--请求参数\n    &#x2F;&#x2F;1.获取字符流\n    BufferedReader br &#x3D; request.getReader();\n    &#x2F;&#x2F;2.读取数据\n    String line &#x3D; null;\n    while((line&#x3D; br.readLine())!&#x3D;null)&#123;\n        System.out.println(line);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;form action&#x3D;&quot;&#x2F;requestDemo5&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type &#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入用户名&quot; name &#x3D; &quot;username&quot;&gt; &lt;br&gt;\n    &lt;input type &#x3D; &quot;text&quot; placeholder&#x3D;&quot;请输入密码&quot; name&#x3D;&quot;password&quot;&gt; &lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<p> 其他功能：</p>\n<ol>\n<li><p>获取请求参数通用方式</p>\n<ol>\n<li><p>String getParameter(String name)：根据参数名称获取参数值 username=zs&amp;password=123</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String username &#x3D; request.getParameter(&quot;username&quot;);</code></pre></li>\n<li><p>String[] getParameterValues(String name)：根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String[] choose &#x3D; request.getParameterValues(&quot;hobby&quot;);</code></pre>\n\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;game&quot;&gt;游戏\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;study&quot;&gt;学习</code></pre></li>\n<li><p>Enumeration<String> getParameterNames()：获取所有请求的参数名称</p>\n</li>\n<li><p>Map&lt;String，String[]&gt; getParameterMap()：获取所有参数的map集合</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">    Map&lt;String,String[]&gt; parameterMap &#x3D; request.getParameterMap();\n    Set&lt;String&gt; keyset &#x3D; parameterMap.keySet();\n    for (String s : keyset) &#123;\n        String[] value &#x3D; parameterMap.get(s);\n        System.out.println(s);\n        for (String value2 : value) &#123;\n            System.out.println(value2);\n        &#125;\n        System.out.println(&quot;----------------------&quot;);\n\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>请求转发</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">RequestDispatcher requestDispatcher &#x3D; request.getRequestDispatcher(&quot;&#x2F;requestDemo9&quot;);\nrequestDispatcher.forward(request,response);\n   </code></pre>\n\n<p><img src=\"C:\\Users\\zkw\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210923111924878.png\" alt=\"image-20210923111924878\"></p>\n</li>\n<li><p>共享数据</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142138739.png\" alt=\"image-20220107142138739\"></p>\n</li>\n<li><p>获取ServletContext</p>\n<p>ServletContext getServletContext()</p>\n</li>\n</ol>\n<p>。。</p>\n<p>中文乱码问题：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre>\n\n<p><img src=\"http://image.1carus.xyz/image-20220107142146054.png\" alt=\"image-20220107142146054\"></p>\n<h1 id=\"response\"><a href=\"#response\" class=\"headerlink\" title=\"response\"></a>response</h1><p><img src=\"http://image.1carus.xyz/image-20220107142156885.png\" alt=\"image-20220107142156885\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142205029.png\" alt=\"image-20220107142205029\"></p>\n<p>响应体：传输的数据</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142211595.png\" alt=\"image-20220107142211595\"></p>\n<p>重定向</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142219627.png\" alt=\"image-20220107142219627\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142234140.png\" alt=\"image-20220107142234140\"></p>\n<p>转发不需要写虚拟目录</p>\n<p>重定向需要写虚拟目录</p>\n<p>路径写法：</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142242559.png\" alt=\"image-20220107142242559\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142252775.png\" alt=\"image-20220107142252775\"></p>\n<p>字节流一般输出图片。</p>\n<p>3.服务器输出字节数据到浏览器</p>\n<p>4.验证码：</p>\n<p>​            1.本质：图片</p>\n<p>​            2.防止恶意表单注册</p>\n<h1 id=\"ServletContext对象\"><a href=\"#ServletContext对象\" class=\"headerlink\" title=\"ServletContext对象\"></a>ServletContext对象</h1><p>1.概念：代表整个web应用，可以和程序的容器（服务器）来通信</p>\n<p>2.功能：</p>\n<p>​        1.获取MIME类型</p>\n<p>​        2.域对象：共享数据</p>\n<p>​        3.获取文件的真实（服务器）路径</p>\n<p>ServletContext对象获取：</p>\n<p>​        1.通过request对象获取</p>\n<p>​                request.getServletContext();</p>\n<p>​        2.通过HttpServlet获取</p>\n<p>​                this.getServletContext()；</p>\n<p>​        3.功能：</p>\n<p>​            1.获取MIME类型</p>\n<p>​                *MIME类型：在互联网通信过程中定义的一种文件数据类型</p>\n<p>​                    *格式：大类型/小类型  text/html   image/jpeg</p>\n<p>​                *获取：String getMimeType（String file）</p>\n<p>​            2.域对象：共享数据</p>\n<p>​                1.setAttribute（String name，Object value）</p>\n<p>​                2.getAttribute（String name）</p>\n<p>​                3.removeAttribute（String name）</p>\n<p>​                *ServletContext对象范围：所有用户所有请求的数据 </p>\n<p>​            3.获取文件的真实（服务器）路径</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142259921.png\" alt=\"image-20220107142259921\"></p>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><p>框架设计的灵魂</p>\n<p>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</p>\n<p>反射：将类的各个组成部分封装成其他对象，这就是反射机制。</p>\n<p>好处：1.可以在程序运行过程中，操作这些对象</p>\n<p>​            2.可以解耦，提高程序的可扩展性</p>\n<p>获取Class对象的方式：</p>\n<ol>\n<li>Class.forName(“全类名”)；将字节码文件加载进内存，返回Class对象</li>\n<li>类名.class，通过类名的属性class获取</li>\n<li>对象.getClass().getClass()方法在Object类中定义着</li>\n</ol>\n<p>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</p>\n<h1 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h1><p>try()中定义流对象，会自动关流</p>\n<p>字符流 FileReader FileWriter 操作单位时字符，一个一个读和写 一组一组读和写</p>\n<p>字节流 FileInputStream FileOutputStream 数据底层皆为字节</p>\n<p>序列化流 前置条件：实现接口 Serialiable ObjectOutputStream ObjectInputStream 方便网络或文件中传递</p>\n<p>转换流：OutputStreamWriter InputStreamReader 指定编码读写</p>\n<p>字符缓冲流：BufferedReader .readline() BufferedWriter  writeline()</p>\n<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><p>Deprecated 表示已过时</p>\n<p>SuppresWarnings 压制警告</p>\n<p>​    一般传递参数all @SuppresWarnings(“all”)</p>\n<h2 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h2><p><img src=\"http://image.1carus.xyz/image-20220107142306861.png\" alt=\"image-20220107142306861\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142313918.png\" alt=\"image-20220107142313918\"></p>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><p>Thread和Runnable的区别</p>\n<p>实现Runnable接口创建多线程程序的好处：</p>\n<ol>\n<li><p>适合多个相同的程序代码的线程去共享同一个资源</p>\n</li>\n<li><p>可以避免java中的单继承的局限性。</p>\n</li>\n<li><p>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立</p>\n</li>\n<li><p>线程池只能放入实现Runabl或Callable类线程，不能直接放入继承Thread的类。<br>​    增强了程序的扩展性，降低了程序的耦合性（解耦）</p>\n<p>​    实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）</p>\n<p>​    实现类中，重写了run方法：用来设置线程任务</p>\n<p>​    创建Thread类对象，调用start方法，用来开启新线程</p>\n</li>\n</ol>\n<h2 id=\"线程安全问题\"><a href=\"#线程安全问题\" class=\"headerlink\" title=\"线程安全问题\"></a>线程安全问题</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Ticket &#123;\n    public static void main(String[] args) &#123;\n        RunnableImpl run &#x3D; new RunnableImpl();\n        Thread t0 &#x3D; new Thread(run);\n        Thread t1 &#x3D; new Thread(run);\n        Thread t2 &#x3D; new Thread(run);\n        t0.start();\n        t1.start();\n        t2.start();\n\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RunnableImpl implements Runnable&#123;\n    private int ticket &#x3D; 100;\n    @Override\n    public void run() &#123;\n        while(true)&#123;\n            if(ticket&gt;0)&#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);\n                   ticket--;\n            &#125;\n&#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Thread-0–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第100张票<br>Thread-1–&gt;正在卖第100张票<br>Thread-0–&gt;正在卖第97张票</p>\n<p>…</p>\n<p>Thread-2–&gt;正在卖第2张票<br>Thread-1–&gt;正在卖第1张票<br>Thread-0–&gt;正在卖第1张票<br>Thread-2–&gt;正在卖第-1张票</p>\n<p>三个线程抢cpu执行，导致负票和打印同一张票。</p>\n<p><strong>线程是处理机调度的单位，进程是资源分配的单位</strong></p>\n<h2 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h2><p>synchronized</p>\n<p>在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决线程不安全问题。</p>\n<p>同步操作：</p>\n<ol>\n<li>同步代码块</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;创建一个锁对象\nObject obj &#x3D; new Object();\n\n@Override\npublic void run() &#123;\n    while (true) &#123;\n        synchronized (obj) &#123;\n            if (ticket &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                ticket--;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://image.1carus.xyz/image-20220107142322335.png\" alt=\"image-20220107142322335\"></p>\n<ol start=\"2\">\n<li><p>同步方法</p>\n<p>使用步骤：</p>\n<p>1.把访问了共享数据的代码抽取出来，放到一个方法中</p>\n<p>2.在方法上添加synchronized修饰符</p>\n<p>格式：  修饰符 synchronized 返回值类型 方法名(参数列表){</p>\n<p>可能会出现线程安全问题的代码}</p>\n<p>同步方法的锁对象是谁？</p>\n<p>就是实现类对象 new RunnableImpl()</p>\n<p>也就是this</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int ticket &#x3D; 100;\n    &#x2F;&#x2F;创建一个锁对象\n    Object obj &#x3D; new Object();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            payTicket();\n\n        &#125;\n    &#125;\n\npublic static synchronized void payTicket() &#123;\n            if (ticket &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(10);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                ticket--;\n            &#125;\n    &#125;</code></pre>\n\n<p>静态的同步方法</p>\n<p>不能是this ， this是创建对象后产生的</p>\n<p>锁对象是本来的class属性–&gt;class文件对象（反射）</p>\n</li>\n<li><p>锁机制</p>\n<p>Lock实现提供了 比使用synchronized方法和语句可获得的更广泛的锁定操作</p>\n<p>Lock接口中的方法：</p>\n<p>void lock()获取锁。</p>\n<p>void unlock()释放锁</p>\n<p>java.util.concurrent.locks.ReentrantLock implements Lock接口</p>\n</li>\n</ol>\n<p><img src=\"http://image.1carus.xyz/image-20220107142351785.png\" alt=\"image-20220107142351785\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RunnableImpl implements Runnable &#123;\n    private int ticket &#x3D; 100;\n    Lock l &#x3D; new ReentrantLock();\n    &#x2F;&#x2F;创建一个锁对象\n    Object obj &#x3D; new Object();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            l.lock();\n\n                if (ticket &gt; 0) &#123;\n                    try &#123;\n                        Thread.sleep(10);\n                        System.out.println(Thread.currentThread().getName() + &quot;--&gt;正在卖第&quot; + ticket + &quot;张票&quot;);\n                        ticket--;\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;finally &#123;\n                        l.unlock();\n                    &#125;\n\n                &#125;\n\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><p>new ：new Thread() new Thread子类()</p>\n<p>runnable</p>\n<p>wait</p>\n<p>notify</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>使用步骤：</p>\n<ol>\n<li>使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</li>\n<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>\n<li>调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>\n<li>调用ExecutorService中的方法shutdown销毁线程池（不建议执行）</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPool &#123;\n    public static void main(String[] args) &#123;\n        ExecutorService es &#x3D; Executors.newFixedThreadPool(2);\n        es.submit(new RunnableImpl());\n        es.submit(new RunnableImpl());\n        es.shutdown();\n    &#125;\n&#125;</code></pre>\n\n<p>ll</p>\n<h1 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h1><p><img src=\"http://image.1carus.xyz/image-20220107142359421.png\" alt=\"image-20220107142359421\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142404770.png\" alt=\"image-20220107142404770\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@WebServlet(&quot;&#x2F;cookieDemo2&quot;)\npublic class CookieDemo2 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request, response);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        Cookie[] cs &#x3D; request.getCookies();\n        if(cs!&#x3D;null)&#123;\n            for (Cookie c : cs) &#123;\n                String name &#x3D; c.getName();\n                String value &#x3D; c.getValue();\n                System.out.println(name+&quot;:&quot;+value);\n            &#125;\n        &#125;\n        \n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@WebServlet(&quot;&#x2F;cookieDemo1&quot;)\npublic class CookieDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request, response);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        Cookie c &#x3D; new Cookie(&quot;msg&quot;,&quot;hello&quot;);\n        response.addCookie(c);\n    &#125;\n&#125;</code></pre>\n\n<p>3.实现原理</p>\n<p>基于响应头set-cookie和请求头cookie实现 </p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142412464.png\" alt=\"image-20220107142412464\"></p>\n<h1 id=\"JSP原理\"><a href=\"#JSP原理\" class=\"headerlink\" title=\"JSP原理\"></a>JSP原理</h1><p>本质是一个Servlet</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142419922.png\" alt=\"image-20220107142419922\"></p>\n<p>jsp的脚本：jsp定义java代码的方式</p>\n<ol>\n<li><p>&lt;% 代码 %&gt;</p>\n</li>\n<li><p>&lt;%! 代码 %&gt;</p>\n</li>\n<li><p>&lt;%= 代码 %&gt;</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142427857.png\" alt=\"image-20220107142427857\"></p>\n</li>\n</ol>\n<p>jsp的内置对象</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142434853.png\" alt=\"image-20220107142434853\"></p>\n<h1 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h1><p><img src=\"http://image.1carus.xyz/image-20220107142442975.png\" alt=\"image-20220107142442975\"></p>\n<p>3.原理：Session的实现是依赖于Cookie的</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142450391.png\" alt=\"image-20220107142450391\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142502258.png\" alt=\"image-20220107142502258\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142509891.png\" alt=\"image-20220107142509891\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142516976.png\" alt=\"image-20220107142516976\"></p>\n<h1 id=\"jsp\"><a href=\"#jsp\" class=\"headerlink\" title=\"jsp\"></a>jsp</h1><p><img src=\"http://image.1carus.xyz/image-20220107142525543.png\" alt=\"image-20220107142525543\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142534707.png\" alt=\"image-20220107142534707\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142541525.png\" alt=\"image-20220107142541525\"></p>\n<h2 id=\"EL表达式\"><a href=\"#EL表达式\" class=\"headerlink\" title=\"EL表达式\"></a>EL表达式</h2><p><img src=\"http://image.1carus.xyz/image-20220107142548823.png\" alt=\"image-20220107142548823\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142557862.png\" alt=\"image-20220107142557862\"></p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142605447.png\" alt=\"image-20220107142605447\"></p>\n<p>获取对象、List集合、Map集合的值</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142612075.png\" alt=\"image-20220107142612075\"></p>\n<p>隐式对象：</p>\n<p>el表达式有11个隐式对象</p>\n<p>pageContext：</p>\n<p>获取jsp其他八个内置对象</p>\n<p>${pageContext.request.contextPath}：动态获取虚拟目录</p>\n<h1 id=\"JSTL\"><a href=\"#JSTL\" class=\"headerlink\" title=\"JSTL\"></a>JSTL</h1><p><img src=\"http://image.1carus.xyz/image-20220107142620377.png\" alt=\"image-20220107142620377\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n&lt;%\n    request.setAttribute(&quot;number&quot;,3);\n%&gt;\n&lt;c:choose&gt;\n    &lt;c:when test&#x3D;&quot;$&#123;number&#x3D;&#x3D;3&#125;&quot;&gt;星期三&lt;&#x2F;c:when&gt;\n    &lt;c:otherwise&gt;数字有误&lt;&#x2F;c:otherwise&gt;\n&lt;&#x2F;c:choose&gt;</code></pre>\n\n<p><img src=\"http://image.1carus.xyz/image-20220107142627554.png\" alt=\"image-20220107142627554\"></p>\n<h2 id=\"foreach-1\"><a href=\"#foreach-1\" class=\"headerlink\" title=\"foreach\"></a>foreach</h2><p><img src=\"http://image.1carus.xyz/image-20220107142634365.png\" alt=\"image-20220107142634365\"></p>\n<h1 id=\"数据库连接池\"><a href=\"#数据库连接池\" class=\"headerlink\" title=\"数据库连接池\"></a>数据库连接池</h1><p><img src=\"http://image.1carus.xyz/image-20220107142641750.png\" alt=\"image-20220107142641750\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JDBCUtils &#123;\n    private static DataSource ds;\n\n    static&#123;\n        try &#123;\n&#x2F;&#x2F;            导入jar包\n            Properties pro &#x3D; new Properties();\n&#x2F;&#x2F;            定义配置文件\n            InputStream is &#x3D; JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n&#x2F;&#x2F;            加载配置文件\n            pro.load(is);\n&#x2F;&#x2F;            获取连接池对象\n            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static DataSource getDataSource()&#123;\n        return ds;\n    &#125;\n&#x2F;&#x2F;    获取连接\n    public static Connection getConnection() throws SQLException&#123;\n        return  ds.getConnection();\n    &#125;\n&#125;</code></pre>\n\n<p>druid.properties</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">driverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test\nusername&#x3D;root\npassword&#x3D;123456\n    &#x2F;&#x2F;初始化连接对象数目\ninitialSize&#x3D;5\n    &#x2F;&#x2F; 最大连接数 10\nmaxActive&#x3D;10\n    &#x2F;&#x2F;最大等待时间 3s\nmaxWait&#x3D;3000</code></pre>\n\n<h2 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h2><p><img src=\"http://image.1carus.xyz/image-20220107142649346.png\" alt=\"image-20220107142649346\"></p>\n<h2 id=\"数据库的基本概念\"><a href=\"#数据库的基本概念\" class=\"headerlink\" title=\"数据库的基本概念\"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB\n2. 什么数据库？\n    * 用于存储和管理数据的仓库。\n\n3. 数据库的特点：\n    1. 持久化存储数据的。其实数据库就是一个文件系统\n    2. 方便存储和管理数据\n    3. 使用了统一的方式操作数据库 -- SQL\n</code></pre>\n<p>​    </p>\n<pre><code>4. 常见的数据库软件\n    * 参见《MySQL基础.pdf》\n</code></pre>\n<h1 id=\"MySQL数据库软件\"><a href=\"#MySQL数据库软件\" class=\"headerlink\" title=\"MySQL数据库软件\"></a>MySQL数据库软件</h1><pre><code>1. 安装\n    * 参见《MySQL基础.pdf》\n2. 卸载\n    1. 去mysql的安装目录找到my.ini文件\n        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n    2. 卸载MySQL\n    3. 删除C:/ProgramData目录下的MySQL文件夹。\n    \n3. 配置\n    * MySQL服务启动\n        1. 手动。\n        2. cmd--&gt; services.msc 打开服务的窗口\n        3. 使用管理员打开cmd\n            * net start mysql : 启动mysql的服务\n            * net stop mysql:关闭mysql服务\n    * MySQL登录\n        1. mysql -uroot -p密码\n        2. mysql -hip -uroot -p连接目标的密码\n        3. mysql --host=ip --user=root --password=连接目标的密码\n    * MySQL退出\n        1. exit\n        2. quit\n\n    * MySQL目录结构\n        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;\n            * 配置文件 my.ini\n        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n            * 几个概念\n                * 数据库：文件夹\n                * 表：文件\n                * 数据：数据\n</code></pre>\n<p>查询时去重：select distinct</p>\n<p>查询某两列的和： row1+row2，如果某列有null值 select row1+ifnull(row2,0) from table</p>\n<p>起别名：select row1+ifnull(row2,0) <strong>as add</strong> from table</p>\n<p>不等于： <strong>！=</strong>  也可以用**&lt;&gt;**</p>\n<pre><code>        -- 查询年龄22岁，18岁，25岁的信息\n        SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\n        SELECT * FROM student WHERE age IN (22,18,25);\n\n        -- 查询英语成绩为null\n        SELECT * FROM student WHERE english = NULL; -- 不对的！  null值不能使用 = （!=） 判断\n        SELECT * FROM student WHERE english IS NULL;\n        -- 查询英语成绩不为null\n        SELECT * FROM student WHERE english  IS NOT NULL;\n\n        -- 查询姓马的有哪些？ like\n            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n        -- 查询姓名第二个字是化的人\n            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n        -- 查询姓名是3个字的人\n            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n        -- 查询姓名中包含德的人\n            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n</code></pre>\n<ol>\n<li><p>排序查询</p>\n<ul>\n<li><p>语法：order by 子句</p>\n<ul>\n<li>order by 排序字段1 排序方式1 ，  排序字段2 排序方式2…</li>\n</ul>\n</li>\n<li><p>排序方式：</p>\n<ul>\n<li>ASC：升序，默认的。</li>\n<li>DESC：降序。</li>\n</ul>\n</li>\n<li><p>注意：</p>\n<ul>\n<li>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</li>\n</ul>\n<p>  – 按照性别分组。分别查询男、女同学的平均分,人数</p>\n<p>  SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;</p>\n<ol start=\"2\">\n<li>where 和 having 的区别？<ol>\n<li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li>\n<li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h2 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h2></li>\n<li><p>语法：limit 开始的索引,每页查询的条数;</p>\n</li>\n<li><p>公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</p>\n<p> – 每页显示3条记录 </p>\n<p> SELECT * FROM student LIMIT 0,3; – 第1页</p>\n<p> SELECT * FROM student LIMIT 3,3; – 第2页</p>\n<p> SELECT * FROM student LIMIT 6,3; – 第3页</p>\n</li>\n<li><p>limit 是一个MySQL”方言”</p>\n</li>\n</ol>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。\n\n1. 在创建表时，可以添加外键\n   * 语法：\n     create table 表名(\n     \t....\n     \t外键列\n     \tconstraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n     );\n 举例：constraint emp_dept_fk foreign key (dep_id) references department(id)\n \n\n2. 删除外键\n   ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n3. 创建表之后，添加外键\n   ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre>\n\n<ol start=\"4\">\n<li><p>```</p>\n<p> 级联操作</p>\n<pre><code> 1. 添加级联操作\n     语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \n             FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;\n 2. 分类：\n     1. 级联更新：ON UPDATE CASCADE \n     2. 级联删除：ON DELETE CASCADE \n</code></pre>\n <pre class=\"line-numbers language-none\"><code class=\"language-none\">  \t\n  \t 多对多：\n  \t\t\t\t* 如：学生和课程\n  \t\t\t\t* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 \n\n# SQL\n\n\t1.什么是SQL？\n\t\tStructured Query Language：结构化查询语言\n\t\t其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\n\t\t\n\t2.SQL通用语法\n\t\t1. SQL 语句可以单行或多行书写，以分号结尾。\n\t\t2. 可使用空格和缩进来增强语句的可读性。\n\t\t3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n\t\t4. 3 种注释\n\t\t\t* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \n\t\t\t* 多行注释: &#x2F;* 注释 *&#x2F;\n\t\t\n\t3. SQL分类\n\t\t1) DDL(Data Definition Language)数据定义语言\n\t\t\t用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\n\t\t2) DML(Data Manipulation Language)数据操作语言\n\t\t\t用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\n\t\t3) DQL(Data Query Language)数据查询语言\n\t\t\t用来查询数据库中表的记录(数据)。关键字：select, where 等\n\t\t4) DCL(Data Control Language)数据控制语言(了解)\n\t\t\t用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\n\n## DDL:操作数据库、表\n\n\t1. 操作数据库：CRUD\n\t\t1. C(Create):创建\n\t\t\t* 创建数据库：\n\t\t\t\t* create database 数据库名称;\n\t\t\t* 创建数据库，判断不存在，再创建：\n\t\t\t\t* create database if not exists 数据库名称;\n\t\t\t* 创建数据库，并指定字符集\n\t\t\t\t* create database 数据库名称 character set 字符集名;\n\t\n\t\t\t* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\n\t\t\t\t* create database if not exists db4 character set gbk;\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询所有数据库的名称:\n\t\t\t\t* show databases;\n\t\t\t* 查询某个数据库的字符集:查询某个数据库的创建语句\n\t\t\t\t* show create database 数据库名称;\n\t\t3. U(Update):修改\n\t\t\t* 修改数据库的字符集\n\t\t\t\t* alter database 数据库名称 character set 字符集名称;\n\t\t4. D(Delete):删除\n\t\t\t* 删除数据库\n\t\t\t\t* drop database 数据库名称;\n\t\t\t* 判断数据库存在，存在再删除\n\t\t\t\t* drop database if exists 数据库名称;\n\t\t5. 使用数据库\n\t\t\t* 查询当前正在使用的数据库名称\n\t\t\t\t* select database();\n\t\t\t* 使用数据库\n\t\t\t\t* use 数据库名称;\n\n\n\t2. 操作表\n\t\t1. C(Create):创建\n\t\t\t1. 语法：\n\t\t\t\tcreate table 表名(\n\t\t\t\t\t列名1 数据类型1,\n\t\t\t\t\t列名2 数据类型2,\n\t\t\t\t\t....\n\t\t\t\t\t列名n 数据类型n\n\t\t\t\t);\n\t\t\t\t* 注意：最后一列，不需要加逗号（,）\n\t\t\t\t* 数据库类型：\n\t\t\t\t\t1. int：整数类型\n\t\t\t\t\t\t* age int,\n\t\t\t\t\t2. double:小数类型\n\t\t\t\t\t\t* score double(5,2)\n\t\t\t\t\t3. date:日期，只包含年月日，yyyy-MM-dd\n\t\t\t\t\t4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\n\t\t\t\t\t5. timestamp:时间错类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\n\t\t\t\t\t\t* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\n\t\n\t\t\t\t\t6. varchar：字符串\n\t\t\t\t\t\t* name varchar(20):姓名最大20个字符\n\t\t\t\t\t\t* zhangsan 8个字符  张三 2个字符\n\n\n\t\t\t* 创建表\n\t\t\t\tcreate table student(\n\t\t\t\t\tid int,\n\t\t\t\t\tname varchar(32),\n\t\t\t\t\tage int ,\n\t\t\t\t\tscore double(4,1),\n\t\t\t\t\tbirthday date,\n\t\t\t\t\tinsert_time timestamp\n\t\t\t\t);\n\t\t\t* 复制表：\n\t\t\t\t* create table 表名 like 被复制的表名;\t  \t\n\t\t2. R(Retrieve)：查询\n\t\t\t* 查询某个数据库中所有的表名称\n\t\t\t\t* show tables;\n\t\t\t* 查询表结构\n\t\t\t\t* desc 表名;\n\t\t3. U(Update):修改\n\t\t\t1. 修改表名\n\t\t\t\talter table 表名 rename to 新的表名;\n\t\t\t2. 修改表的字符集\n\t\t\t\talter table 表名 character set 字符集名称;\n\t\t\t3. 添加一列\n\t\t\t\talter table 表名 add 列名 数据类型;\n\t\t\t4. 修改列名称 类型\n\t\t\t\talter table 表名 change 列名 新列别 新数据类型;\n\t\t\t\talter table 表名 modify 列名 新数据类型;\n\t\t\t5. 删除列\n\t\t\t\talter table 表名 drop 列名;\n\t\t4. D(Delete):删除\n\t\t\t* drop table 表名;\n\t\t\t* drop table  if exists 表名 ;\n\n* 客户端图形化工具：SQLYog\n\n## DML：增删改表中数据\n\n\t1. 添加数据：\n\t\t* 语法：\n\t\t\t* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\n\t\t* 注意：\n\t\t\t1. 列名和值要一一对应。\n\t\t\t2. 如果表名后，不定义列名，则默认给所有列添加值\n\t\t\t\tinsert into 表名 values(值1,值2,...值n);\n\t\t\t3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\n\t2. 删除数据：\n\t\t* 语法：\n\t\t\t* delete from 表名 [where 条件]\n\t\t* 注意：\n\t\t\t1. 如果不加条件，则删除表中所有记录。\n\t\t\t2. 如果要删除所有记录\n\t\t\t\t1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\n\t\t\t\t2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\n\t3. 修改数据：\n\t\t* 语法：\n\t\t\t* update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,... [where 条件];\n\t\n\t\t* 注意：\n\t\t\t1. 如果不加任何条件，则会将表中所有记录全部修改。\n\n\n\n## DQL：查询表中的记录\n\n\t* select * from 表名;\n\t\n\t1. 语法：\n\t\tselect\n\t\t\t字段列表\n\t\tfrom\n\t\t\t表名列表\n\t\twhere\n\t\t\t条件列表\n\t\tgroup by\n\t\t\t分组字段\n\t\thaving\n\t\t\t分组之后的条件\n\t\torder by\n\t\t\t排序\n\t\tlimit\n\t\t\t分页限定\n\n\n\t2. 基础查询\n\t\t1. 多个字段的查询\n\t\t\tselect 字段名1，字段名2... from 表名；\n\t\t\t* 注意：\n\t\t\t\t* 如果查询所有字段，则可以使用*来替代字段列表。\n\t\t2. 去除重复：\n\t\t\t* distinct\n\t\t3. 计算列\n\t\t\t* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n\t\t\t* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\n\t\t\t\t* 表达式1：哪个字段需要判断是否为null\n\t\t\t\t* 如果该字段为null后的替换值。\n\t\t4. 起别名：\n\t\t\t* as：as也可以省略\n\n\n\t3. 条件查询\n\t\t1. where子句后跟条件\n\t\t2. 运算符\n\t\t\t* &gt; 、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt;\n\t\t\t* BETWEEN...AND  \n\t\t\t* IN( 集合) \n\t\t\t* LIKE：模糊查询\n\t\t\t\t* 占位符：\n\t\t\t\t\t* _:单个任意字符\n\t\t\t\t\t* %：多个任意字符\n\t\t\t* IS NULL  \n\t\t\t* and  或 &amp;&amp;\n\t\t\t* or  或 || \n\t\t\t* not  或 !\n\t\t\t\n\t\t\t\t-- 查询年龄大于20岁\n\t\n\t\t\t\tSELECT * FROM student WHERE age &gt; 20;\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄等于20岁\n\t\t\t\tSELECT * FROM student WHERE age &#x3D; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄不等于20岁\n\t\t\t\tSELECT * FROM student WHERE age !&#x3D; 20;\n\t\t\t\tSELECT * FROM student WHERE age &lt;&gt; 20;\n\t\t\t\t\n\t\t\t\t-- 查询年龄大于等于20 小于等于30\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp;  age &lt;&#x3D;30;\n\t\t\t\tSELECT * FROM student WHERE age &gt;&#x3D; 20 AND  age &lt;&#x3D;30;\n\t\t\t\tSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n\t\t\t\t\n\t\t\t\t-- 查询年龄22岁，18岁，25岁的信息\n\t\t\t\tSELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25\n\t\t\t\tSELECT * FROM student WHERE age IN (22,18,25);\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩为null\n\t\t\t\tSELECT * FROM student WHERE english &#x3D; NULL; -- 不对的。null值不能使用 &#x3D; （!&#x3D;） 判断\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE english IS NULL;\n\t\t\t\t\n\t\t\t\t-- 查询英语成绩不为null\n\t\t\t\tSELECT * FROM student WHERE english  IS NOT NULL;\n\n\n\n\t\t\t\t-- 查询姓马的有哪些？ like\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n\t\t\t\t-- 查询姓名第二个字是化的人\n\t\t\t\t\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n\t\t\t\t\n\t\t\t\t-- 查询姓名是3个字的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n\n\n​\t\t\t\t\n\n\t\t\t\t-- 查询姓名中包含德的人\n\t\t\t\tSELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n\n## 数据库备份\n\nmysqldump -uroot -p (数据库名) &gt; d:&#x2F;&#x2F;a.sql\n\n\t# 网络编程\n\nudp：\n\n&#96;&#96;&#96;java\n&#x2F;**\n * UDP发送端\n *&#x2F;\npublic class SendDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        DatagramSocket ds &#x3D; new DatagramSocket();\n        byte[] bys &#x3D; &quot;shit!+\\n&quot;.getBytes();\n        DatagramPacket dp &#x3D; new DatagramPacket(bys,bys.length, InetAddress.getByName(&quot;localhost&quot;),65530);\n        ds.send(dp);\n        ds.close();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * UDP接收端\n *&#x2F;\npublic class AcceptDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        DatagramSocket ds &#x3D; new DatagramSocket(65530);\n        byte[] by &#x3D; new byte[1024];\n        DatagramPacket dp &#x3D; new DatagramPacket(by,by.length);\n        ds.receive(dp);\n        int len &#x3D; dp.getLength();\n        String dataString &#x3D; new String(by,0,len);\n        System.out.println(&quot;数据是&quot;+dataString);\n        ds.close();\n    &#125;\n&#125;</code></pre>\n\n<p>tcp断开流程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">假设 Client 端发起中断连接请求，也就是发送 FIN 报文。Server 端接到 FIN 报文后，意思是说 &quot; 我 Client 端没有数据要发给你了 &quot;，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，&quot; 告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息 &quot;。这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，&quot; 告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了 &quot;。Client 端收到 FIN 报文后，&quot; 就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。“，Server 端收到 ACK 后，&quot; 就知道可以断开连接了 &quot;。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！</code></pre>\n\n<p>tcp发送数据的步骤：</p>\n<ol>\n<li><p>创建客户端的Socket对象</p>\n<p>Socket(String host,int port)</p>\n</li>\n<li><p>获取输出流，写数据</p>\n<p>OutputStream getOutputStream()</p>\n</li>\n<li><p>释放资源</p>\n<p>void close()</p>\n</li>\n</ol>\n<p>tcp接收数据的步骤：</p>\n<ol>\n<li><p>创建服务端的Socket对象（ServerSocket）</p>\n<p>ServerSocket(int port)</p>\n</li>\n<li><p>监听客户端连接，返回一个Socket对象</p>\n<p>Socket accept()</p>\n</li>\n<li><p>获取输入流、读数据，并把数据显示在控制台</p>\n<p>InputStream getInputStream()</p>\n</li>\n<li><p>释放资源</p>\n<p>void close()</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Send &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;创建客户端的Socket对象\n        Socket sc &#x3D; new Socket(&quot;192.168.1.51&quot;,65530);\n        &#x2F;&#x2F;获取输出流，写数据\n        OutputStream os &#x3D; sc.getOutputStream();\n        os.write(&quot;hello,tcp&quot;.getBytes());\n        &#x2F;&#x2F;释放资源\n        sc.close();\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Accept &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;创建服务端的Socket对象（ServerSocket）\n        ServerSocket sc &#x3D; new ServerSocket(65530);\n        &#x2F;&#x2F;监听客户端连接，返回一个Socket对象\n        Socket s &#x3D; sc.accept();\n        &#x2F;&#x2F;获取输入流、读数据，并把数据显示在控制台\n        InputStream is &#x3D; s.getInputStream();\n        byte[] bys &#x3D; new byte[1024];\n        int len &#x3D; is.read(bys);\n        String data &#x3D; new String(bys,0,len);\n        System.out.println(&quot;数据是：&quot;+data);\n        &#x2F;&#x2F;释放资源\n        sc.close();\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">input 对应checked 默认\noption 对应 selected </code></pre>\n\n<p>./ 代表当前目录</p>\n<p>../代表上一级目录</p>\n<p></br>换行</p>\n<p><img> 标签的 alt 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。</p>\n<p>如何实现全选功能：</p>\n<p>将全选按钮和列表按钮绑定，用循环遍历来逐个绑定。</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&#x2F;&#x2F;1.获取第一个cb\ndocument.getElementById(&quot;firstCb&quot;).onclick &#x3D; function ()&#123;\n    &#x2F;&#x2F; 2.获取下边列表中所有的cb\nvar cbs &#x3D; document.getElementsByName(&quot;uid&quot;);\nfor(var i &#x3D; 0;i&lt;cbs.length;i++)&#123;\n    &#x2F;&#x2F;4.设置这些cbp[i]的checked状态&#x3D;firstCb.checked\n    cbs[i].checked &#x3D; this.checked; </code></pre>\n\n<p>&nbsp; 空格占位符</p>\n<p>html建立表单快捷代码  table&gt;tr<em>2&gt;td</em>3 再按Tab  两行三列</p>\n<p>style（css样式） 一般在head中，script 一般在body中</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142706038.png\" alt=\"image-20220107142706038\"></p>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>如果写一个类需要动态的获取某个文件的位置，从而能够获取此文件的资源。那么，使用 Class.getResourceAsStream () 方法便可以。</p>\n<p>这样就不用每次去修改代码中文件的绝对地址或详细地址了。</p>\n<h1 id=\"jedis\"><a href=\"#jedis\" class=\"headerlink\" title=\"jedis\"></a>jedis</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">jedis.setex(&quot;activecode&quot;,10,&quot;hehe&quot;);&#x2F;&#x2F;将activecode，hehe键值对存入redis，10秒后删除</code></pre>\n\n<p><img src=\"http://image.1carus.xyz/image-20220107142713629.png\" alt=\"image-20220107142713629\"></p>\n<p>list转json</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ObjectMapper mapper &#x3D; new ObjectMapper();\nString s &#x3D; mapper.writeValueAsString(list);</code></pre>\n\n<h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><p>通过内容来确定类型 var 变量 = 初始化值</p>\n<p>typeof 来确定类型</p>\n<p>js中== 先做类型转换，再进行比较 3==“3“  true</p>\n<p>=== 先做类型比较，如果类型不同， false</p>\n<pre><code>    5. 逻辑运算符\n        &amp;&amp; || !    （短路效果\n        * 其他类型转boolean：\n           1. number：0或NaN为假，其他为真\n           2. string：除了空字符串(&quot;&quot;)，其他都是true\n           3. null&amp;undefined:都是false\n           4. 对象：所有对象都为true\n</code></pre>\n<p>引号的时候，内双外单或者外双内单    ‘     “   “    ‘   </p>\n<p>placeholder 虚化的value</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入性别&quot; id&#x3D;&quot;c3&quot;&gt;</code></pre>\n\n<p>servlet以 .do结尾的路径不能以/开头</p>\n<p>tomcat8 和以后版本已经解决get请求中文乱码</p>\n<p>post中文乱码需要手动解决  </p>\n<ul>\n<li>解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”);</li>\n</ul>\n<p>也可以用过滤器等等</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Enumeration&lt;String&gt; parameterNames &#x3D; request.getParameterNames();\n\nwhile(parameterNames.hasMoreElements)&#123;&#125;\n\n&#x2F;&#x2F;遍历枚举</code></pre>\n\n<p>内部资源转发必须用请求转发</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142721633.png\" alt=\"image-20220107142721633\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; $.get(url,[data],[callback],[type]);  路径，数据，回调函数，接收到的响应数据的格式</code></pre>\n\n<p>post语法一样</p>\n<p>json的三个包</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142728402.png\" alt=\"image-20220107142728402\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    public void Test02() throws JsonProcessingException &#123;\n&#x2F;&#x2F;        将json转为java对象\n        String json &#x3D; &quot;&#123;\\&quot;gender\\&quot;:\\&quot;男\\&quot;,\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;age\\&quot;:23&#125;&quot;;\n        ObjectMapper map &#x3D; new ObjectMapper();\n        Person person &#x3D; map.readValue(json, Person.class);\n        System.out.println(person);\n    &#125;</code></pre>\n\n<p><img src=\"http://image.1carus.xyz/image-20220107142734656.png\" alt=\"image-20220107142734656\"></p>\n<p>修改tomcat启动默认页面。web.xml</p>\n<p>四大域对象 </p>\n<p>pageContext、request、session、ServletContext(全局域对象 随着tomcat启动创建 tomcat消亡而消亡)</p>\n<p>ApplicationContext与ServletContext是一个东西</p>\n<p><img src=\"http://image.1carus.xyz/image-20220107142742060.png\" alt=\"image-20220107142742060\"></p>\n<p>session工作原理</p>\n<p><strong>枚举</strong></p>\n<p>value () 方法可以将枚举类转变为一个枚举类型的数组，因为枚举中没有下标，我们没有办法通过下标来快速找到需要的枚举类，这时候，转变为数组之后，我们就可以通过数组的下标，来找到我们需要的枚举类。接下来就展示代码了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public enum SearchCategory &#123;\n    ALL(&quot;综合查询&quot;),\n    NEWS(&quot;新闻&quot;),\n    TAXPAYER(&quot;纳税人&quot;),\n    QUIZ(&quot;知识问答&quot;),\n    POLICY_LAW(&quot;政策法规&quot;),\n    DOC(&quot;涉税文档&quot;),\n    PIC(&quot;图片&quot;),\n    BAIKE(&quot;税务百科&quot;);\n\n    private String value;\n\n    SearchCategory(String value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public String getValue()&#123;\n        return value;\n    &#125;\n    \n    public static void main(String[] args)&#123;\n        for(SearchCategory s : SearchCategory.values())&#123;\n            System.out.println(s + &quot;---&quot; + s.getValue());\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">转换json并设置格式\n@JsonFormat(pattern &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd&quot;,timezone &#x3D; &quot;GMT+8&quot;)\nprivate Date joinDate;</code></pre>\n\n","text":"继承方法的覆盖重写1.必须保证父子类之间方法的名称相同，参数列表也相同； @Override，写在方法签名，用来检测是不是有效的正确覆盖重写。 写不写都行，写了可以验证一下方法名是否与父类方法对应。 2.子类方法的返回值必须小于等于父类方法的返回值范围 public class ...","link":"","photos":[],"count_time":{"symbolsCount":"38k","symbolsTime":"34 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法的覆盖重写</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">继承的三个特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">抽象方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">多接口的注意事项</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">向上转型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">向下转型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#final\"><span class=\"toc-text\">final</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">匿名内部类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Object\"><span class=\"toc-text\">Object</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Objects\"><span class=\"toc-text\">Objects</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Date%E7%B1%BB\"><span class=\"toc-text\">Date类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#StringBuilder\"><span class=\"toc-text\">StringBuilder</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">装箱和拆箱</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">集合框架</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#foreach\"><span class=\"toc-text\">foreach</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6\"><span class=\"toc-text\">泛型的通配符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashSet\"><span class=\"toc-text\">HashSet</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可变参数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">对象排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Servlet\"><span class=\"toc-text\">Servlet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#request%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">request功能</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#response\"><span class=\"toc-text\">response</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ServletContext%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">ServletContext对象</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">反射</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B5%81\"><span class=\"toc-text\">流</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">自定义注解</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">线程安全问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">线程状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">线程池</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Cookie\"><span class=\"toc-text\">Cookie</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JSP%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">JSP原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Session\"><span class=\"toc-text\">Session</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jsp\"><span class=\"toc-text\">jsp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EL%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">EL表达式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JSTL\"><span class=\"toc-text\">JSTL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#foreach-1\"><span class=\"toc-text\">foreach</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0\"><span class=\"toc-text\">数据库连接池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#template\"><span class=\"toc-text\">template</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">数据库的基本概念</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">MySQL数据库软件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">分页查询</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#html\"><span class=\"toc-text\">html</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">类加载器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jedis\"><span class=\"toc-text\">jedis</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript\"><span class=\"toc-text\">JavaScript</span></a></li></ol>","author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Jquery和原生js的区别","uid":"cf3ece25eb219b32904f64404ccf8150","slug":"Jquery 和 原生js","date":"2021-09-07T14:32:21.000Z","updated":"2022-01-07T14:55:48.161Z","comments":true,"path":"api/articles/Jquery 和 原生js.json","keywords":"Java","cover":null,"text":"Jquery 和 原生js（1）选中dom对象 document.getElementsByClassName(“one”)[0] =$(“.one”) document.getElementsByTagName(“div”)[0] =$(“.div”) document.get...","link":"","photos":[],"count_time":{"symbolsCount":396,"symbolsTime":"1 mins."},"categories":[{"name":"javascript","slug":"javascript","count":1,"path":"api/categories/javascript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":1,"path":"api/tags/JavaScript.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}