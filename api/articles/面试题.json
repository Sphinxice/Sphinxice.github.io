{"title":"面试题","uid":"5f849d772fd372114a5b63b97d1479ef","slug":"面试题","date":"2022-01-01T15:32:53.000Z","updated":"2022-01-08T05:31:25.419Z","comments":true,"path":"api/articles/面试题.json","keywords":"Java","cover":null,"content":"<h2 id=\"object类中的方法：\"><a href=\"#object类中的方法：\" class=\"headerlink\" title=\"object类中的方法：\"></a>object类中的方法：</h2><p>实现对象的浅拷贝的clone方法</p>\n<p>获得运行时类型的getclass方法</p>\n<p>释放资源的finalize方法</p>\n<p>用户哈希查找的hashcode方法</p>\n<p>使当前线程等待该对象的锁wait方法</p>\n<h2 id=\"访问修饰符：\"><a href=\"#访问修饰符：\" class=\"headerlink\" title=\"访问修饰符：\"></a>访问修饰符：</h2><p>​                本类中  同个包  子类  任何地方</p>\n<p>public </p>\n<p>protect </p>\n<p>default </p>\n<p>private</p>\n<p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>\n<p>抽象类必须被继承才能使用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">  CREATE PROCEDURE myproc(OUT s int)\n    BEGIN\n      SELECT COUNT(*) INTO s FROM students;\n    END\n    &#x2F;&#x2F;\nDELIMITER ;</code></pre>\n\n<h2 id=\"Object-类方法\"><a href=\"#Object-类方法\" class=\"headerlink\" title=\"Object 类方法\"></a>Object 类方法</h2><p>Object 是所有类的父类，任何类都默认继承 Object。Object 类到底实现了哪些方法？</p>\n<p>（1）clone 方法</p>\n<p>保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。</p>\n<p>（2）getClass 方法</p>\n<p>final 方法，获得运行时类型。</p>\n<p>（3）toString 方法</p>\n<p>该方法用得比较多，一般子类都有覆盖。</p>\n<p>（4）finalize 方法</p>\n<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p>\n<p>（5）equals 方法</p>\n<p>该方法是非常重要的一个方法。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。</p>\n<p>（6）hashCode 方法</p>\n<p>该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法。这个方法在一些具有哈希功能的 Collection 中用到。</p>\n<p>一般必须满足 obj1.equals (obj2)==true。可以推出 obj1.hash- Code ()==obj2.hashCode ()，但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>\n<p>（7）wait 方法</p>\n<p>wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait () 方法一直等待，直到获得锁或者被中断。wait (long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>\n<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>\n<p>（1）其他线程调用了该对象的 notify 方法。</p>\n<p>（2）其他线程调用了该对象的 notifyAll 方法。</p>\n<p>（3）其他线程调用了 interrupt 中断该线程。</p>\n<p>（4）时间间隔到了。</p>\n<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。</p>\n<p>（8）notify 方法</p>\n<p>该方法唤醒在该对象上等待的某个线程。</p>\n<p>（9）notifyAll 方法</p>\n<p>该方法唤醒在该对象上等待的所有线程。</p>\n<h2 id=\"如何理解面向对象的三个特征的？\"><a href=\"#如何理解面向对象的三个特征的？\" class=\"headerlink\" title=\"如何理解面向对象的三个特征的？\"></a>如何理解面向对象的三个特征的？</h2><p>面向对象的特性是封装、继承和多态，封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性的同时，使代码模块化，这样做使得代码的复用性更高；继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类–有父类的行为和属性，也有自己特有的行为和属性，这样做扩展了已存在的代码块，进一步提高了代码的复用性；多态是为了实现接口重用，多态的一大作用就是为了解耦，允许父类引用 (或接口) 指向子类 (或实现类) 对象。多态的表现形式有重写和重载</p>\n<h2 id=\"说说重写和重载\"><a href=\"#说说重写和重载\" class=\"headerlink\" title=\"说说重写和重载\"></a>说说重写和重载</h2><p>重写发生在父类与子类之间，方法名相同，参数列表相同，返回值可以 “变小”，抛出的异常可以 “变小”，访问修饰符权限不能变小，发生在运行期<br>重载实在一个类中，方法名相同，参数列表不同（参数顺序不同也行），返回值和访问修饰符可以不同，发生在编译期</p>\n<h2 id=\"Spring-IOC-DI-底层实现原理\"><a href=\"#Spring-IOC-DI-底层实现原理\" class=\"headerlink\" title=\"Spring IOC / DI 底层实现原理\"></a>Spring IOC / DI 底层实现原理</h2><p>问题说明：Spring 是如何通过配置文件，就完成了对象的创建和属性的赋值？<br>答案：</p>\n<p>使用工厂设计模式 + 配置文件 + 反射<br>描述：<br>使用工厂设计模式，在工厂中，根据配置文件中标签的 class 属性，反射创建出对象。<br>再根据标签的子标签标签的 name 属性，反射找到对应的 set 方法，反射调用 set 方法将标签的 value 属性的值 赋给属性。</p>\n<h2 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h2><p>Spring AOP 概念<br>问：你对 Spring AOP 有什么理解？</p>\n<p>思想： 面向切面编程<br>在不修改目标类代码的情况下，在运行时，动态的为目标对象的目标方法增加额外功能，实现解耦合，提高代码的可维护性。</p>\n<p>本质： 在不修改目标类代码的情况下，在运行时，动态的为目标对象生成代理对象，用代理对象取而代之，代替目标对象接受调用，变相的实现了功能增强的效果。</p>\n<h2 id=\"Spring-AOP-底层实现原理\"><a href=\"#Spring-AOP-底层实现原理\" class=\"headerlink\" title=\"Spring AOP 底层实现原理\"></a>Spring AOP 底层实现原理</h2><p>问题说明： Spring AOP 是如何生成代理类对象的？</p>\n<p>答案： 使用 JDK 的 Proxy 的静态方法 newProxyInstance，内部执行动态字节码技术，产生代理类对象，产生代理类的对象。基于接口生成的。</p>\n<p>堆和栈的区别有：1、空间分配区别；2、缓存方式区别；3、数据结构区别。堆空间一般由程序员分配释放，栈空间由操作系统（编译器）自动分配释放。栈使用一级缓存，堆使用二级缓存。</p>\n<h2 id=\"堆和栈的区别是什么\"><a href=\"#堆和栈的区别是什么\" class=\"headerlink\" title=\"堆和栈的区别是什么\"></a>堆和栈的区别是什么</h2><p>1、堆栈空间分配区别</p>\n<p>栈（操作系统）：由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>\n<p>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。</p>\n<p>2、堆栈缓存方式区别</p>\n<p>栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。</p>\n<p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>\n<p>3、堆栈数据结构区别</p>\n<p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序。</p>\n<p>栈（数据结构）：一种先进后出的数据结构。</p>\n<p>对象进堆 方法进栈 </p>\n<h2 id=\"流复习\"><a href=\"#流复习\" class=\"headerlink\" title=\"流复习\"></a>流复习</h2><p>直接操作文件——&gt; FileOuputStream、FileInputStream</p>\n<p>语法是：FileOutputStream （可以是String或者是File ，true / false ） 是否拼接可写可不写，默认是false</p>\n<p><strong>节点流</strong>：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如 FileInputStream 和 FileOutputStream，他们直接从文件中读取或往文件中写入字节流。</p>\n<p>在已存在的输入或输出流上操作——&gt; BufferedInputStream 和 BufferedOutputStream</p>\n<p>语法是：BufferedOutputStream（new  FileOutputStream）</p>\n<p><strong>处理流</strong>：“连接” 在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如 BufferedInputStream 和 BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率</p>\n<p> DataInputStream 和 DataOutputStream，使用已经存在的节点流来构造，提供了读写 Java 中的基本数据类型的功能。他们都属于过滤流。用了之后就可以使用writeInt、writeBoolean方法等等来书。</p>\n<p><strong>len = fis.read (bys)</strong>   </p>\n<p>包含两个动作：1. 代表每次最多从目标文件中读取 1024 个字节. 2. 返回每次读取多少个字节长度 (由于 read (bys) 向 bys 写入的数据是覆盖的，并不是替换 , 所以必须要返回字节长度，避免输出以外的字节)<br>fis.read (bys) !=-1  表示当读取的目标文件到末尾了，没有剩余的字节了，就会返回 - 1, 通过是否等于 - 1 的判断，继续是否读取.<br>new String (bys,0,len) 表示每次把 bys 里面的数据，从 0 到 len 的长度读取出去，len 控制了每次 bys 能读取到的字节长度，避免 bys 覆盖造成的错误. 通过构造方法转换成字符串输出</p>\n<p> BufferedOutputStream 输出数据时需要关闭流，否则数据不会输出到文件当中</p>\n<p><strong>字节流和字符流的区别</strong><br>字节流操作的基本单元为字节；字符流操作的基本单元为 Unicode 码元。<br>字节流默认不使用缓冲区；字符流使用缓冲区。<br>字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用 close 或 flush 方法，则不会输出任何内容。<br>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取 Unicode 码元；字符流通常处理文本数据，它支持写入及读取 Unicode 码元。<br>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理 Unicode 字符，而字符流就可以。</p>\n<p><strong>字节流和字符流的转换</strong><br>字节流是最基本的，所有的 InputStream 和 OutputStream 的子类都是，主要用在处理二进制数据，它是按字节来处理的，但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的 encode 来处理，也就是要进行字符集的转化，这两个之间通过 InputStreamReader,OutputStreamWriter 来关联，实际上是通过 byte [] 和 String 来关联。在从字节流转化为字符流时，实际上就是 byte [] 转化为 String 时，而在字符流转化为字节流时，实际上是 String 转化为 byte [] 时。</p>\n<p>字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。所以字符流是由 Java 虚拟机将字节转化为 2 个字节的 Unicode 字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p>\n<p>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的 IO 操作的功能，但它不能直接处理 Unicode 字符，而字符流就可以。</p>\n<p>字节流与字符流主要的区别是他们的的处理方式。</p>\n<p><strong>解决乱码问题</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> File f &#x3D; new File(&quot;a.txt&quot;);\nFileOutputStream fop &#x3D; new FileOutputStream(f);\n&#x2F;&#x2F; 构建 FileOutputStream 对象，文件不存在会自动新建\n \nOutputStreamWriter writer &#x3D; new OutputStreamWriter(fop, &quot;UTF-8&quot;);\n&#x2F;&#x2F; 构建 OutputStreamWriter 对象，参数可以指定编码，默认为操作系统默认编码，windows 上是 gbk</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> writer.append(&quot; 中文输入 &quot;);\n        &#x2F;&#x2F; 写入到缓冲区\n         writer.append(&quot;\\r\\n&quot;);\n        &#x2F;&#x2F; 换行\n         writer.append(&quot;English&quot;);\n        &#x2F;&#x2F; 刷新缓存冲，写入到文件，如果下面已经没有写入的内容了，直接 close 也会写入\n         writer.close();\n        &#x2F;&#x2F; 关闭写入流，同时会把缓冲区内容写入文件，所以上面的注释掉\n         fop.close();\n        &#x2F;&#x2F; 关闭输出流，释放系统资源\n         FileInputStream fip &#x3D; new FileInputStream(f);\n        &#x2F;&#x2F; 构建 FileInputStream 对象\n         InputStreamReader reader &#x3D; new InputStreamReader(fip, &quot;UTF-8&quot;);\n        &#x2F;&#x2F; 构建 InputStreamReader 对象，编码与写入相同\n         StringBuffer sb &#x3D; new StringBuffer();\n        while (reader.ready()) &#123;\n            sb.append((char) reader.read());\n            &#x2F;&#x2F; 转成 char 加到 StringBuffer 对象中\n        &#125;\n        System.out.println(sb.toString());\n        reader.close();\n        &#x2F;&#x2F; 关闭读取流\n         fip.close();\n        &#x2F;&#x2F; 关闭输入流，释放系统资源\n    &#125;\n&#125;</code></pre>\n\n<p>递归删除</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DeleteFileDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 这里修改为自己的测试目录\n         File folder &#x3D; new File(&quot;&#x2F;tmp&#x2F;java&#x2F;&quot;);\n        deleteFolder(folder);\n    &#125;\n \n    &#x2F;&#x2F; 删除文件及目录\n     public static void deleteFolder(File folder) &#123;\n        File[] files &#x3D; folder.listFiles();\n        if (files !&#x3D; null) &#123;\n            for (File f : files) &#123;\n                if (f.isDirectory()) &#123;\n                    deleteFolder(f);\n                &#125; else &#123;\n                    f.delete();\n                &#125;\n            &#125;\n        &#125;\n        folder.delete();\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>事务的四种特性：原子性、一致性、隔离性、持久性</p>\n<p>linux常用命令：cd chgrp cat </p>\n<p>redis五种数据结构：string hash set zset list</p>\n<p>git常用命令：</p>\n<p>新增文件的命令：git add file 或者 git add .<br>提交文件的命令：git commit –m 或者 git commit –a<br>查看工作区状况：git status –s<br>拉取合并远程分支的操作：git fetch/git merge 或者 git pull<br>查看提交记录命令：git reflog</p>\n<p>Git 代码合并有两种：Git Merge 和 Git ReBase</p>\n","text":"object类中的方法：实现对象的浅拷贝的clone方法 获得运行时类型的getclass方法 释放资源的finalize方法 用户哈希查找的hashcode方法 使当前线程等待该对象的锁wait方法 访问修饰符：​ 本类中 同个包 子类 任何地方 public protect ...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"面试题","slug":"面试题","count":1,"path":"api/categories/面试题.json"}],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#object%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">object类中的方法：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A\"><span class=\"toc-text\">访问修饰符：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-%E7%B1%BB%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Object 类方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">如何理解面向对象的三个特征的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E8%AF%B4%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">说说重写和重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-IOC-DI-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Spring IOC &#x2F; DI 底层实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-AOP\"><span class=\"toc-text\">Spring AOP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-AOP-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Spring AOP 底层实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">堆和栈的区别是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E5%A4%8D%E4%B9%A0\"><span class=\"toc-text\">流复习</span></a></li></ol>","author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"hexo命令","uid":"8f31d06ea2e56b4b6405cdb90df6568a","slug":"hexo命令","date":"2022-01-05T14:32:21.000Z","updated":"2022-01-08T05:32:50.148Z","comments":true,"path":"api/articles/hexo命令.json","keywords":"Java","cover":null,"text":"hexo官方文档https://hexo.io/zh-cn/docs/ 常用命令： hexo cl &amp; hexo g ————–重建静态文件 hexo n “文章标题” —————建立新文章 hexo clean &amp; hexo g &amp; hexo serve...","link":"","photos":[],"count_time":{"symbolsCount":592,"symbolsTime":"1 mins."},"categories":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/categories/Hexo.json"}],"tags":[{"name":"hexo","slug":"hexo","count":1,"path":"api/tags/hexo.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"RequestMapping注解","uid":"dae83d1c88f5937753ca40f0c60cab64","slug":"@RequestMapping注解","date":"2021-11-07T14:32:21.000Z","updated":"2022-01-07T15:00:24.874Z","comments":true,"path":"api/articles/@RequestMapping注解.json","keywords":"Java","cover":null,"text":"@RequestMapping注解一个用来处理请求地址映射的注解，可用于类或方法上。 用于类上，表示类中的所有请求的方法都是以该地址作为父路径@RestController @RequestMapping(&quot;&#x2F;test&quot;) public class ...","link":"","photos":[],"count_time":{"symbolsCount":605,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"}],"tags":[{"name":"spring","slug":"spring","count":1,"path":"api/tags/spring.json"}],"author":{"name":"icarus","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"码龄：1年","socials":{"github":"https://github.com/icarusice","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_43287808","juejin":"","customs":{}}}}}